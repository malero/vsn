{"version":3,"sources":["../src/parser/token.ts","../src/parser/lexer.ts","../src/ast/nodes.ts","../src/parser/token-stream.ts","../src/parser/parser.ts","../src/runtime/scope.ts","../src/runtime/bindings.ts","../src/runtime/conditionals.ts","../src/runtime/html.ts","../src/runtime/http.ts","../src/runtime/engine.ts","../src/index.ts"],"sourcesContent":["export enum TokenType {\n  Whitespace = \"Whitespace\",\n  Identifier = \"Identifier\",\n  Number = \"Number\",\n  String = \"String\",\n  Boolean = \"Boolean\",\n  Null = \"Null\",\n\n  Behavior = \"Behavior\",\n  State = \"State\",\n  On = \"On\",\n  Construct = \"Construct\",\n  Destruct = \"Destruct\",\n\n  LBrace = \"LBrace\",\n  RBrace = \"RBrace\",\n  LParen = \"LParen\",\n  RParen = \"RParen\",\n  LBracket = \"LBracket\",\n  RBracket = \"RBracket\",\n\n  Colon = \"Colon\",\n  Semicolon = \"Semicolon\",\n  Comma = \"Comma\",\n\n  Dot = \"Dot\",\n  Hash = \"Hash\",\n  Greater = \"Greater\",\n  Less = \"Less\",\n  Plus = \"Plus\",\n  Tilde = \"Tilde\",\n  Star = \"Star\",\n\n  Equals = \"Equals\",\n  Bang = \"Bang\",\n\n  At = \"At\",\n  Dollar = \"Dollar\",\n  Question = \"Question\"\n}\n\nexport interface Position {\n  index: number;\n  line: number;\n  column: number;\n}\n\nexport interface Token {\n  type: TokenType;\n  value: string;\n  start: Position;\n  end: Position;\n}\n","import { Token, TokenType } from \"./token\";\n\nconst KEYWORDS: Record<string, TokenType> = {\n  behavior: TokenType.Behavior,\n  state: TokenType.State,\n  on: TokenType.On,\n  construct: TokenType.Construct,\n  destruct: TokenType.Destruct,\n  true: TokenType.Boolean,\n  false: TokenType.Boolean,\n  null: TokenType.Null\n};\n\nexport class Lexer {\n  private index = 0;\n  private line = 1;\n  private column = 1;\n\n  constructor(private input: string) {}\n\n  tokenize(): Token[] {\n    const tokens: Token[] = [];\n\n    while (!this.eof()) {\n      const ch = this.peek();\n\n      if (this.isWhitespace(ch)) {\n        tokens.push(this.readWhitespace());\n        continue;\n      }\n\n      if (ch === \"/\" && this.peek(1) === \"/\") {\n        this.readLineComment();\n        continue;\n      }\n\n      if (ch === \"/\" && this.peek(1) === \"*\") {\n        this.readBlockComment();\n        continue;\n      }\n\n      if (this.isAlpha(ch) || ch === \"_\") {\n        tokens.push(this.readIdentifier());\n        continue;\n      }\n\n      if (this.isDigit(ch) || (ch === \"-\" && this.isDigit(this.peek(1)))) {\n        tokens.push(this.readNumber());\n        continue;\n      }\n\n      if (ch === \"\\\"\" || ch === \"'\") {\n        tokens.push(this.readString());\n        continue;\n      }\n\n      const punct = this.readPunctuator();\n      if (punct) {\n        tokens.push(punct);\n        continue;\n      }\n\n      throw new Error(`Unexpected character '${ch}' at ${this.line}:${this.column}`);\n    }\n\n    return tokens;\n  }\n\n  private readWhitespace(): Token {\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof() && this.isWhitespace(this.peek())) {\n      value += this.next();\n    }\n    return this.token(TokenType.Whitespace, value, start);\n  }\n\n  private readLineComment(): void {\n    this.next();\n    this.next();\n    while (!this.eof() && this.peek() !== \"\\n\") {\n      this.next();\n    }\n  }\n\n  private readBlockComment(): void {\n    this.next();\n    this.next();\n    while (!this.eof()) {\n      if (this.peek() === \"*\" && this.peek(1) === \"/\") {\n        this.next();\n        this.next();\n        return;\n      }\n      this.next();\n    }\n  }\n\n  private readIdentifier(): Token {\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof() && (this.isAlphaNumeric(this.peek()) || this.peek() === \"_\" || this.peek() === \"-\")) {\n      value += this.next();\n    }\n\n    const keywordType = KEYWORDS[value];\n    if (keywordType) {\n      return this.token(keywordType, value, start);\n    }\n\n    return this.token(TokenType.Identifier, value, start);\n  }\n\n  private readNumber(): Token {\n    const start = this.position();\n    let value = \"\";\n    if (this.peek() === \"-\") {\n      value += this.next();\n    }\n    while (!this.eof() && this.isDigit(this.peek())) {\n      value += this.next();\n    }\n    if (this.peek() === \".\") {\n      value += this.next();\n      while (!this.eof() && this.isDigit(this.peek())) {\n        value += this.next();\n      }\n    }\n    return this.token(TokenType.Number, value, start);\n  }\n\n  private readString(): Token {\n    const quote = this.next();\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof()) {\n      const ch = this.next();\n      if (ch === \"\\\\\") {\n        const escaped = this.next();\n        value += escaped;\n        continue;\n      }\n      if (ch === quote) {\n        return this.token(TokenType.String, value, start);\n      }\n      value += ch;\n    }\n    throw new Error(`Unterminated string at ${start.line}:${start.column}`);\n  }\n\n  private readPunctuator(): Token | null {\n    const start = this.position();\n    const ch = this.peek();\n    const punctMap: Record<string, TokenType> = {\n      \"{\": TokenType.LBrace,\n      \"}\": TokenType.RBrace,\n      \"(\": TokenType.LParen,\n      \")\": TokenType.RParen,\n      \"[\": TokenType.LBracket,\n      \"]\": TokenType.RBracket,\n      \":\": TokenType.Colon,\n      \";\": TokenType.Semicolon,\n      \",\": TokenType.Comma,\n      \".\": TokenType.Dot,\n      \"#\": TokenType.Hash,\n      \">\": TokenType.Greater,\n      \"<\": TokenType.Less,\n      \"+\": TokenType.Plus,\n      \"~\": TokenType.Tilde,\n      \"*\": TokenType.Star,\n      \"=\": TokenType.Equals,\n      \"!\": TokenType.Bang,\n      \"@\": TokenType.At,\n      \"$\": TokenType.Dollar,\n      \"?\": TokenType.Question\n    };\n\n    const type = punctMap[ch];\n    if (!type) {\n      return null;\n    }\n\n    this.next();\n    return this.token(type, ch, start);\n  }\n\n  private token(type: TokenType, value: string, start: { index: number; line: number; column: number }): Token {\n    return {\n      type,\n      value,\n      start,\n      end: this.position()\n    };\n  }\n\n  private position() {\n    return { index: this.index, line: this.line, column: this.column };\n  }\n\n  private peek(offset = 0): string {\n    return this.input[this.index + offset] ?? \"\";\n  }\n\n  private next(): string {\n    const ch = this.input[this.index++] ?? \"\";\n    if (ch === \"\\n\") {\n      this.line += 1;\n      this.column = 1;\n    } else {\n      this.column += 1;\n    }\n    return ch;\n  }\n\n  private eof(): boolean {\n    return this.index >= this.input.length;\n  }\n\n  private isWhitespace(ch: string): boolean {\n    return ch === \" \" || ch === \"\\t\" || ch === \"\\n\" || ch === \"\\r\";\n  }\n\n  private isAlpha(ch: string): boolean {\n    return (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\");\n  }\n\n  private isDigit(ch: string): boolean {\n    return ch >= \"0\" && ch <= \"9\";\n  }\n\n  private isAlphaNumeric(ch: string): boolean {\n    return this.isAlpha(ch) || this.isDigit(ch);\n  }\n}\n","export interface ExecutionContext {\n  // Placeholder for runtime context\n}\n\nexport interface CFSNode {\n  type: string;\n  prepare(context: ExecutionContext): Promise<void>;\n  evaluate(context: ExecutionContext): Promise<any>;\n}\n\nexport abstract class BaseNode implements CFSNode {\n  constructor(public type: string) {}\n\n  async prepare(_context: ExecutionContext): Promise<void> {\n    return;\n  }\n\n  async evaluate(_context: ExecutionContext): Promise<any> {\n    return undefined;\n  }\n}\n\nexport class ProgramNode extends BaseNode {\n  constructor(public behaviors: BehaviorNode[]) {\n    super(\"Program\");\n  }\n}\n\nexport class BlockNode extends BaseNode {\n  constructor(public statements: CFSNode[]) {\n    super(\"Block\");\n  }\n}\n\nexport class SelectorNode extends BaseNode {\n  constructor(public selectorText: string) {\n    super(\"Selector\");\n  }\n}\n\nexport class BehaviorNode extends BaseNode {\n  constructor(public selector: SelectorNode, public body: BlockNode) {\n    super(\"Behavior\");\n  }\n}\n\nexport class StateEntryNode extends BaseNode {\n  constructor(\n    public name: string,\n    public value: ExpressionNode,\n    public important: boolean\n  ) {\n    super(\"StateEntry\");\n  }\n}\n\nexport class StateBlockNode extends BaseNode {\n  constructor(public entries: StateEntryNode[]) {\n    super(\"StateBlock\");\n  }\n}\n\nexport class OnBlockNode extends BaseNode {\n  constructor(\n    public eventName: string,\n    public args: string[],\n    public body: BlockNode\n  ) {\n    super(\"OnBlock\");\n  }\n}\n\nexport class AssignmentNode extends BaseNode {\n  constructor(public target: AssignmentTarget, public value: ExpressionNode) {\n    super(\"Assignment\");\n  }\n}\n\nexport interface DeclarationFlags {\n  important?: boolean;\n  trusted?: boolean;\n  debounce?: boolean;\n}\n\nexport interface DeclarationFlagArgs {\n  debounce?: number;\n}\n\nexport class DeclarationNode extends BaseNode {\n  constructor(\n    public target: DeclarationTarget,\n    public operator: \":\" | \":=\" | \":<\" | \":>\",\n    public value: ExpressionNode,\n    public flags: DeclarationFlags,\n    public flagArgs: DeclarationFlagArgs\n  ) {\n    super(\"Declaration\");\n  }\n}\n\nexport type ExpressionNode =\n  | IdentifierExpression\n  | LiteralExpression\n  | UnaryExpression\n  | DirectiveExpression\n  | QueryExpression;\n\nexport type DeclarationTarget = IdentifierExpression | DirectiveExpression;\nexport type AssignmentTarget = IdentifierExpression | DirectiveExpression;\n\nexport class IdentifierExpression extends BaseNode {\n  constructor(public name: string) {\n    super(\"Identifier\");\n  }\n}\n\nexport class LiteralExpression extends BaseNode {\n  constructor(public value: string | number | boolean | null) {\n    super(\"Literal\");\n  }\n\n  async evaluate(): Promise<any> {\n    return this.value;\n  }\n}\n\nexport class UnaryExpression extends BaseNode {\n  constructor(public operator: string, public argument: ExpressionNode) {\n    super(\"UnaryExpression\");\n  }\n}\n\nexport class DirectiveExpression extends BaseNode {\n  constructor(public kind: \"attr\" | \"style\", public name: string) {\n    super(\"Directive\");\n  }\n}\n\nexport class QueryExpression extends BaseNode {\n  constructor(public direction: \"self\" | \"descendant\" | \"ancestor\", public selector: string) {\n    super(\"Query\");\n  }\n}\n","import { Token, TokenType } from \"./token\";\n\nexport class TokenStream {\n  private index = 0;\n\n  constructor(private tokens: Token[]) {}\n\n  peek(offset = 0): Token | null {\n    return this.tokens[this.index + offset] ?? null;\n  }\n\n  next(): Token {\n    const token = this.tokens[this.index++];\n    if (!token) {\n      throw new Error(\"Unexpected end of input\");\n    }\n    return token;\n  }\n\n  eof(): boolean {\n    return this.index >= this.tokens.length;\n  }\n\n  match(type: TokenType): boolean {\n    if (this.peek()?.type === type) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n\n  expect(type: TokenType): Token {\n    const token = this.next();\n    if (token.type !== type) {\n      throw new Error(`Expected ${type} but got ${token.type}`);\n    }\n    return token;\n  }\n\n  skipWhitespace(): void {\n    while (this.peek()?.type === TokenType.Whitespace) {\n      this.next();\n    }\n  }\n\n  peekNonWhitespace(offset = 0): Token | null {\n    let count = 0;\n    for (let i = this.index; i < this.tokens.length; i++) {\n      const token = this.tokens[i];\n      if (token.type === TokenType.Whitespace) {\n        continue;\n      }\n      if (count === offset) {\n        return token;\n      }\n      count += 1;\n    }\n    return null;\n  }\n}\n","import {\n  AssignmentNode,\n  BehaviorNode,\n  BlockNode,\n  AssignmentTarget,\n  DeclarationNode,\n  DeclarationTarget,\n  DeclarationFlags,\n  DeclarationFlagArgs,\n  DirectiveExpression,\n  IdentifierExpression,\n  LiteralExpression,\n  OnBlockNode,\n  ProgramNode,\n  QueryExpression,\n  SelectorNode,\n  StateBlockNode,\n  StateEntryNode,\n  UnaryExpression,\n  ExpressionNode\n} from \"../ast/nodes\";\nimport { Lexer } from \"./lexer\";\nimport { TokenStream } from \"./token-stream\";\nimport { TokenType } from \"./token\";\n\nexport class Parser {\n  private stream: TokenStream;\n\n  constructor(input: string) {\n    const lexer = new Lexer(input);\n    this.stream = new TokenStream(lexer.tokenize());\n  }\n\n  parseProgram(): ProgramNode {\n    const behaviors: BehaviorNode[] = [];\n    this.stream.skipWhitespace();\n    while (!this.stream.eof()) {\n      behaviors.push(this.parseBehavior());\n      this.stream.skipWhitespace();\n    }\n    return new ProgramNode(behaviors);\n  }\n\n  private parseBehavior(): BehaviorNode {\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Behavior);\n    const selector = this.parseSelector();\n    const body = this.parseBlock({ allowDeclarations: true });\n    return new BehaviorNode(selector, body);\n  }\n\n  private parseSelector(): SelectorNode {\n    let selectorText = \"\";\n    let sawNonWhitespace = false;\n\n    while (true) {\n      const token = this.stream.peek();\n      if (!token) {\n        break;\n      }\n\n      if (token.type === TokenType.LBrace) {\n        break;\n      }\n\n      if (token.type === TokenType.Whitespace) {\n        this.stream.next();\n        if (sawNonWhitespace && selectorText[selectorText.length - 1] !== \" \") {\n          selectorText += \" \";\n        }\n        continue;\n      }\n\n      sawNonWhitespace = true;\n      selectorText += this.stream.next().value;\n    }\n\n    if (!selectorText.trim()) {\n      throw new Error(\"Behavior selector is required\");\n    }\n\n    return new SelectorNode(selectorText.trim());\n  }\n\n  private parseBlock(options?: { allowDeclarations?: boolean }): BlockNode {\n    const allowDeclarations = options?.allowDeclarations ?? false;\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LBrace);\n    const statements = [];\n    let declarationsOpen = allowDeclarations;\n\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated block\");\n      }\n      if (next.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n\n      const isDeclaration = this.isDeclarationStart();\n      if (isDeclaration) {\n        if (!allowDeclarations) {\n          throw new Error(\"Declarations are only allowed at the behavior root\");\n        }\n        if (!declarationsOpen) {\n          throw new Error(\"Declarations must appear before blocks\");\n        }\n        statements.push(this.parseDeclaration());\n      } else {\n        if (declarationsOpen) {\n          declarationsOpen = false;\n        }\n        statements.push(this.parseStatement());\n      }\n    }\n\n    return new BlockNode(statements);\n  }\n\n  private parseStatement() {\n    this.stream.skipWhitespace();\n    const next = this.stream.peek();\n    if (!next) {\n      throw new Error(\"Unexpected end of input\");\n    }\n\n    if (next.type === TokenType.On) {\n      return this.parseOnBlock();\n    }\n\n    if (next.type === TokenType.Construct) {\n      return this.parseConstructBlock();\n    }\n\n    if (next.type === TokenType.Destruct) {\n      return this.parseDestructBlock();\n    }\n\n    if (next.type === TokenType.Behavior) {\n      return this.parseBehavior();\n    }\n\n    if (this.isAssignmentStart()) {\n      return this.parseAssignment();\n    }\n\n    throw new Error(`Unexpected token ${next.type}`);\n  }\n\n  private parseStateBlock(): StateBlockNode {\n    this.stream.expect(TokenType.State);\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LBrace);\n\n    const entries: StateEntryNode[] = [];\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated state block\");\n      }\n      if (next.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n\n      const nameToken = this.stream.expect(TokenType.Identifier);\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Colon);\n      this.stream.skipWhitespace();\n      const value = this.parseExpression();\n      this.stream.skipWhitespace();\n\n      let important = false;\n      if (this.stream.peek()?.type === TokenType.Bang) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const importantToken = this.stream.next();\n        if (importantToken.type === TokenType.Identifier && importantToken.value === \"important\") {\n          important = true;\n        } else {\n          throw new Error(\"Expected 'important' after '!'\");\n        }\n      }\n\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Semicolon);\n      entries.push(new StateEntryNode(nameToken.value, value, important));\n    }\n\n    return new StateBlockNode(entries);\n  }\n\n  private parseOnBlock(): OnBlockNode {\n    this.stream.expect(TokenType.On);\n    this.stream.skipWhitespace();\n    const event = this.stream.expect(TokenType.Identifier);\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    const args: string[] = [];\n\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated on() arguments\");\n      }\n      if (next.type === TokenType.RParen) {\n        this.stream.next();\n        break;\n      }\n      if (next.type === TokenType.Identifier) {\n        args.push(this.stream.next().value);\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.Comma) {\n          this.stream.next();\n        }\n        continue;\n      }\n      throw new Error(`Unexpected token in on() args: ${next.type}`);\n    }\n\n    const body = this.parseBlock({ allowDeclarations: false });\n    return new OnBlockNode(event.value, args, body);\n  }\n\n  private parseAssignment(): AssignmentNode {\n    const target = this.parseAssignmentTarget();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Equals);\n    this.stream.skipWhitespace();\n    const value = this.parseExpression();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Semicolon);\n    return new AssignmentNode(target, value);\n  }\n\n  private parseExpression(): ExpressionNode {\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected expression\");\n    }\n\n    if (token.type === TokenType.Bang) {\n      this.stream.next();\n      const argument = this.parseExpression();\n      return new UnaryExpression(\"!\", argument);\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier);\n      return new DirectiveExpression(kind, name.value);\n    }\n\n    if (token.type === TokenType.Question) {\n      return this.parseQueryExpression();\n    }\n\n    if (token.type === TokenType.Identifier) {\n      return new IdentifierExpression(this.parseIdentifierPath());\n    }\n\n    if (token.type === TokenType.Boolean) {\n      return new LiteralExpression(this.stream.next().value === \"true\");\n    }\n\n    if (token.type === TokenType.Null) {\n      this.stream.next();\n      return new LiteralExpression(null);\n    }\n\n    if (token.type === TokenType.Number) {\n      return new LiteralExpression(Number(this.stream.next().value));\n    }\n\n    if (token.type === TokenType.String) {\n      return new LiteralExpression(this.stream.next().value);\n    }\n\n    throw new Error(`Unsupported expression token ${token.type}`);\n  }\n\n  private parseAssignmentTarget(): AssignmentTarget {\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected assignment target\");\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier);\n      return new DirectiveExpression(kind, name.value);\n    }\n\n    if (token.type === TokenType.Identifier) {\n      return new IdentifierExpression(this.parseIdentifierPath());\n    }\n\n    throw new Error(`Invalid assignment target ${token.type}`);\n  }\n\n  private isAssignmentStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first) {\n      return false;\n    }\n\n    if (first.type === TokenType.Identifier) {\n      const second = this.stream.peekNonWhitespace(1);\n      return second?.type === TokenType.Equals || second?.type === TokenType.Dot;\n    }\n\n    if (first.type === TokenType.At || first.type === TokenType.Dollar) {\n      const second = this.stream.peekNonWhitespace(1);\n      const third = this.stream.peekNonWhitespace(2);\n      return second?.type === TokenType.Identifier && third?.type === TokenType.Equals;\n    }\n\n    return false;\n  }\n\n  private parseIdentifierPath(): string {\n    let value = this.stream.expect(TokenType.Identifier).value;\n    while (this.stream.peek()?.type === TokenType.Dot) {\n      this.stream.next();\n      const part = this.stream.expect(TokenType.Identifier).value;\n      value = `${value}.${part}`;\n    }\n    return value;\n  }\n\n  private parseQueryExpression(): QueryExpression {\n    this.stream.expect(TokenType.Question);\n    let direction: \"self\" | \"descendant\" | \"ancestor\" = \"self\";\n\n    if (this.stream.peek()?.type === TokenType.Greater) {\n      this.stream.next();\n      direction = \"descendant\";\n    } else if (this.stream.peek()?.type === TokenType.Less) {\n      this.stream.next();\n      direction = \"ancestor\";\n    }\n\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    const selector = this.readSelectorUntil(TokenType.RParen);\n    return new QueryExpression(direction, selector);\n  }\n\n  private readSelectorUntil(terminator: TokenType): string {\n    let selectorText = \"\";\n    let sawNonWhitespace = false;\n\n    while (true) {\n      const token = this.stream.peek();\n      if (!token) {\n        throw new Error(\"Unterminated selector\");\n      }\n      if (token.type === terminator) {\n        this.stream.next();\n        break;\n      }\n\n      if (token.type === TokenType.Whitespace) {\n        this.stream.next();\n        if (sawNonWhitespace && selectorText[selectorText.length - 1] !== \" \") {\n          selectorText += \" \";\n        }\n        continue;\n      }\n\n      sawNonWhitespace = true;\n      selectorText += this.stream.next().value;\n    }\n\n    return selectorText.trim();\n  }\n\n  private parseDeclaration(): DeclarationNode {\n    const target = this.parseDeclarationTarget();\n    this.stream.skipWhitespace();\n    const operator = this.parseDeclarationOperator();\n    this.stream.skipWhitespace();\n    const value = this.parseExpression();\n    const { flags, flagArgs } = this.parseFlags();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Semicolon);\n    return new DeclarationNode(target, operator, value, flags, flagArgs);\n  }\n\n  private parseDeclarationTarget(): DeclarationTarget {\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected declaration target\");\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier);\n      return new DirectiveExpression(kind, name.value);\n    }\n\n    if (token.type === TokenType.Identifier) {\n      return new IdentifierExpression(this.stream.next().value);\n    }\n\n    throw new Error(`Invalid declaration target ${token.type}`);\n  }\n\n  private parseDeclarationOperator(): \":\" | \":=\" | \":<\" | \":>\" {\n    this.stream.expect(TokenType.Colon);\n    const next = this.stream.peek();\n    if (!next) {\n      return \":\";\n    }\n    if (next.type === TokenType.Equals) {\n      this.stream.next();\n      return \":=\";\n    }\n    if (next.type === TokenType.Less) {\n      this.stream.next();\n      return \":<\";\n    }\n    if (next.type === TokenType.Greater) {\n      this.stream.next();\n      return \":>\";\n    }\n    return \":\";\n  }\n\n  private parseFlags(): { flags: DeclarationFlags; flagArgs: DeclarationFlagArgs } {\n    const flags: DeclarationFlags = {};\n    const flagArgs: DeclarationFlagArgs = {};\n\n    while (true) {\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type !== TokenType.Bang) {\n        break;\n      }\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier).value;\n\n      if (name === \"important\") {\n        flags.important = true;\n      } else if (name === \"trusted\") {\n        flags.trusted = true;\n      } else if (name === \"debounce\") {\n        flags.debounce = true;\n        if (this.stream.peek()?.type === TokenType.LParen) {\n          this.stream.next();\n          this.stream.skipWhitespace();\n          const numberToken = this.stream.expect(TokenType.Number);\n          flagArgs.debounce = Number(numberToken.value);\n          this.stream.skipWhitespace();\n          this.stream.expect(TokenType.RParen);\n        } else {\n          flagArgs.debounce = 200;\n        }\n      } else {\n        throw new Error(`Unknown flag ${name}`);\n      }\n    }\n\n    return { flags, flagArgs };\n  }\n\n  private isDeclarationStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first) {\n      return false;\n    }\n\n    if (first.type === TokenType.Identifier) {\n      const second = this.stream.peekNonWhitespace(1);\n      return second?.type === TokenType.Colon;\n    }\n\n    if (first.type === TokenType.At || first.type === TokenType.Dollar) {\n      const second = this.stream.peekNonWhitespace(1);\n      const third = this.stream.peekNonWhitespace(2);\n      return second?.type === TokenType.Identifier && third?.type === TokenType.Colon;\n    }\n\n    return false;\n  }\n\n  private parseConstructBlock(): BlockNode {\n    this.stream.expect(TokenType.Construct);\n    const body = this.parseBlock({ allowDeclarations: false });\n    body.type = \"Construct\";\n    return body;\n  }\n\n  private parseDestructBlock(): BlockNode {\n    this.stream.expect(TokenType.Destruct);\n    const body = this.parseBlock({ allowDeclarations: false });\n    body.type = \"Destruct\";\n    return body;\n  }\n}\n","export class Scope {\n  private data = new Map<string, any>();\n\n  get(key: string): any {\n    return this.getPath(key);\n  }\n\n  set(key: string, value: any): void {\n    this.setPath(key, value);\n  }\n\n  getPath(path: string): any {\n    const parts = path.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return undefined;\n    }\n    let value = this.data.get(root);\n    for (let i = 1; i < parts.length; i += 1) {\n      if (value == null) {\n        return undefined;\n      }\n      const key = parts[i];\n      if (!key) {\n        return undefined;\n      }\n      value = value[key];\n    }\n    return value;\n  }\n\n  setPath(path: string, value: any): void {\n    const parts = path.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return;\n    }\n    if (parts.length === 1) {\n      this.data.set(root, value);\n      return;\n    }\n    let obj = this.data.get(root);\n    if (obj == null || typeof obj !== \"object\") {\n      obj = {};\n      this.data.set(root, obj);\n    }\n    let cursor = obj;\n    for (let i = 1; i < parts.length - 1; i += 1) {\n      const key = parts[i];\n      if (!key) {\n        return;\n      }\n      if (cursor[key] == null || typeof cursor[key] !== \"object\") {\n        cursor[key] = {};\n      }\n      cursor = cursor[key];\n    }\n    const lastKey = parts[parts.length - 1];\n    if (!lastKey) {\n      return;\n    }\n    cursor[lastKey] = value;\n  }\n}\n","import { Scope } from \"./scope\";\n\nexport function applyBind(element: Element, expression: string, scope: Scope): void {\n  const key = expression.trim();\n  if (!key) {\n    return;\n  }\n\n  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n    const value = element.value;\n    if (value !== undefined && value !== \"\") {\n      scope.set(key, value);\n    }\n    return;\n  }\n\n  const text = element.textContent?.trim();\n  if (text) {\n    scope.set(key, text);\n  }\n}\n","import { Scope } from \"./scope\";\n\nfunction readCondition(expression: string, scope: Scope): boolean {\n  const key = expression.trim();\n  if (!key) {\n    return false;\n  }\n  return !!scope.get(key);\n}\n\nexport function applyIf(element: HTMLElement, expression: string, scope: Scope): void {\n  element.style.display = readCondition(expression, scope) ? \"\" : \"none\";\n}\n\nexport function applyShow(element: HTMLElement, expression: string, scope: Scope): void {\n  element.style.display = readCondition(expression, scope) ? \"\" : \"none\";\n}\n","import { Scope } from \"./scope\";\n\nfunction sanitizeHtml(value: string): string {\n  return value.replace(/<script\\b[^>]*>[\\s\\S]*?<\\/script>/gi, \"\");\n}\n\nexport function applyHtml(\n  element: HTMLElement,\n  expression: string,\n  scope: Scope,\n  trusted: boolean\n): void {\n  const key = expression.trim();\n  if (!key) {\n    return;\n  }\n  const value = scope.get(key);\n  const html = value == null ? \"\" : String(value);\n  element.innerHTML = trusted ? html : sanitizeHtml(html);\n}\n","import { applyHtml } from \"./html\";\nimport { Scope } from \"./scope\";\n\nexport interface GetConfig {\n  url: string;\n  targetSelector?: string;\n  swap?: \"inner\" | \"outer\";\n  trusted: boolean;\n}\n\nexport async function applyGet(\n  element: Element,\n  config: GetConfig,\n  scope: Scope\n): Promise<void> {\n  if (!globalThis.fetch) {\n    throw new Error(\"fetch is not available\");\n  }\n\n  const response = await globalThis.fetch(config.url);\n  if (!response || !response.ok) {\n    return;\n  }\n\n  const html = await response.text();\n  const target = resolveTarget(element, config.targetSelector);\n  if (!target) {\n    element.dispatchEvent(new CustomEvent(\"vsn:targetError\", { detail: { selector: config.targetSelector } }));\n    return;\n  }\n\n  if (config.swap === \"outer\") {\n    const wrapper = document.createElement(\"div\");\n    applyHtml(wrapper, \"__html\", { get: () => html } as Scope, config.trusted);\n    const replacement = wrapper.firstElementChild;\n    if (replacement && target.parentNode) {\n      target.parentNode.replaceChild(replacement, target);\n    }\n    return;\n  }\n\n  applyHtml(target as HTMLElement, \"__html\", { get: () => html } as Scope, config.trusted);\n}\n\nfunction resolveTarget(element: Element, selector?: string): Element | null {\n  if (!selector) {\n    return element;\n  }\n  return element.ownerDocument.querySelector(selector);\n}\n","import { Scope } from \"./scope\";\nimport { applyBind } from \"./bindings\";\nimport { applyIf, applyShow } from \"./conditionals\";\nimport { applyHtml } from \"./html\";\nimport { applyGet, GetConfig } from \"./http\";\n\nexport class Engine {\n  private scopes = new WeakMap<Element, Scope>();\n  private ifBindings = new WeakMap<Element, string>();\n  private showBindings = new WeakMap<Element, string>();\n  private htmlBindings = new WeakMap<Element, { expr: string; trusted: boolean }>();\n  private getBindings = new WeakMap<Element, GetConfig>();\n\n  async mount(root: HTMLElement): Promise<void> {\n    const elements: Element[] = [root, ...Array.from(root.querySelectorAll(\"*\"))];\n    for (const element of elements) {\n      this.attachAttributes(element);\n    }\n  }\n\n  getScope(element: Element): Scope {\n    const existing = this.scopes.get(element);\n    if (existing) {\n      return existing;\n    }\n    const scope = new Scope();\n    this.scopes.set(element, scope);\n    return scope;\n  }\n\n  evaluate(element: Element): void {\n    const scope = this.getScope(element);\n    const ifExpr = this.ifBindings.get(element);\n    if (ifExpr && element instanceof HTMLElement) {\n      applyIf(element, ifExpr, scope);\n    }\n    const showExpr = this.showBindings.get(element);\n    if (showExpr && element instanceof HTMLElement) {\n      applyShow(element, showExpr, scope);\n    }\n    const htmlBinding = this.htmlBindings.get(element);\n    if (htmlBinding && element instanceof HTMLElement) {\n      applyHtml(element, htmlBinding.expr, scope, htmlBinding.trusted);\n    }\n  }\n\n  private attachAttributes(element: Element): void {\n    const scope = this.getScope(element);\n    for (const name of element.getAttributeNames()) {\n      if (name === \"vsn-bind\") {\n        const value = element.getAttribute(name) ?? \"\";\n        applyBind(element, value, scope);\n        continue;\n      }\n\n      if (name === \"vsn-if\") {\n        const value = element.getAttribute(name) ?? \"\";\n        this.ifBindings.set(element, value);\n        if (element instanceof HTMLElement) {\n          applyIf(element, value, scope);\n        }\n        continue;\n      }\n\n      if (name === \"vsn-show\") {\n        const value = element.getAttribute(name) ?? \"\";\n        this.showBindings.set(element, value);\n        if (element instanceof HTMLElement) {\n          applyShow(element, value, scope);\n        }\n        continue;\n      }\n\n      if (name.startsWith(\"vsn-html\")) {\n        const trusted = name.includes(\"!trusted\");\n        const value = element.getAttribute(name) ?? \"\";\n        this.htmlBindings.set(element, { expr: value, trusted });\n        if (element instanceof HTMLElement) {\n          applyHtml(element, value, scope, trusted);\n        }\n        continue;\n      }\n\n      if (name.startsWith(\"vsn-get\")) {\n        const trusted = name.includes(\"!trusted\");\n        const url = element.getAttribute(name) ?? \"\";\n        const target = element.getAttribute(\"vsn-target\") ?? undefined;\n        const swap = (element.getAttribute(\"vsn-swap\") as \"inner\" | \"outer\" | null) ?? \"inner\";\n        const config: GetConfig = {\n          url,\n          swap,\n          trusted,\n          ...(target ? { targetSelector: target } : {})\n        };\n        this.getBindings.set(element, config);\n        this.attachGetHandler(element);\n        continue;\n      }\n\n      const eventName = this.getOnEventName(name, null, null);\n      if (eventName) {\n        const value = element.getAttribute(name) ?? \"\";\n        this.attachOnHandler(element, eventName, value);\n      }\n    }\n  }\n\n  private getOnEventName(name: string, prefix: string | null, localName: string | null): string | null {\n    if (name.startsWith(\"vsn-on:\")) {\n      return name.slice(\"vsn-on:\".length);\n    }\n    if (prefix === \"vsn-on\" && localName) {\n      return localName;\n    }\n    return null;\n  }\n\n  private attachOnHandler(element: Element, eventName: string, code: string): void {\n    element.addEventListener(eventName, () => {\n      const scope = this.getScope(element);\n      this.execute(code, scope);\n      this.evaluate(element);\n    });\n  }\n\n  private attachGetHandler(element: Element): void {\n    element.addEventListener(\"click\", async () => {\n      const config = this.getBindings.get(element);\n      if (!config) {\n        return;\n      }\n      await applyGet(element, config, this.getScope(element));\n    });\n  }\n\n  private execute(code: string, scope: Scope): void {\n    const statements = code.split(\";\").map((s) => s.trim()).filter(Boolean);\n    for (const statement of statements) {\n      const assignmentMatch = statement.match(/^([_a-zA-Z][_a-zA-Z0-9.]+)\\s*=\\s*(.+)$/);\n      if (assignmentMatch) {\n        const target = assignmentMatch[1];\n        const expr = assignmentMatch[2];\n        if (!target || !expr) {\n          continue;\n        }\n        const value = this.evaluateExpression(expr, scope);\n        scope.setPath(target, value);\n        continue;\n      }\n      this.evaluateExpression(statement, scope);\n    }\n  }\n\n  private evaluateExpression(expr: string, scope: Scope): any {\n    const parts = expr.split(\"+\").map((part) => part.trim()).filter(Boolean);\n    if (parts.length > 1) {\n      return parts.reduce((sum, part) => {\n        const value = this.evaluateExpression(part, scope);\n        return (sum as any) + (value as any);\n      }, 0 as any);\n    }\n\n    const token = parts[0];\n    if (!token) {\n      return undefined;\n    }\n    if (token === \"true\") return true;\n    if (token === \"false\") return false;\n    if (token === \"null\") return null;\n    if (/^-?\\d+(?:\\.\\d+)?$/.test(token)) {\n      return Number(token);\n    }\n    if ((token.startsWith(\"\\\"\") && token.endsWith(\"\\\"\")) || (token.startsWith(\"'\") && token.endsWith(\"'\"))) {\n      return token.slice(1, -1);\n    }\n    return scope.getPath(token);\n  }\n}\n","export const VERSION = \"0.1.0\";\n\nexport { Lexer } from \"./parser/lexer\";\nimport { Parser } from \"./parser/parser\";\nexport { Parser };\nexport { TokenType } from \"./parser/token\";\nexport * from \"./ast/nodes\";\nexport { Engine } from \"./runtime/engine\";\n\nexport function parseCFS(source: string) {\n  const parser = new Parser(source);\n  return parser.parseProgram();\n}\n"],"mappings":"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","names":["TokenType"]}