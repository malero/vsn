{"version":3,"sources":["../src/parser/token.ts","../src/parser/lexer.ts","../src/ast/nodes.ts","../src/parser/token-stream.ts","../src/parser/parser.ts","../src/runtime/scope.ts","../src/runtime/bindings.ts","../src/runtime/conditionals.ts","../src/runtime/html.ts","../src/runtime/http.ts","../src/runtime/debounce.ts","../src/runtime/engine.ts","../src/index.ts"],"sourcesContent":["export enum TokenType {\n  Whitespace = \"Whitespace\",\n  Identifier = \"Identifier\",\n  Number = \"Number\",\n  String = \"String\",\n  Template = \"Template\",\n  Boolean = \"Boolean\",\n  Null = \"Null\",\n\n  Behavior = \"Behavior\",\n  Use = \"Use\",\n  State = \"State\",\n  On = \"On\",\n  Construct = \"Construct\",\n  Destruct = \"Destruct\",\n  Return = \"Return\",\n  If = \"If\",\n  Else = \"Else\",\n  For = \"For\",\n  While = \"While\",\n  Try = \"Try\",\n  Catch = \"Catch\",\n  Assert = \"Assert\",\n  Break = \"Break\",\n  Continue = \"Continue\",\n\n  LBrace = \"LBrace\",\n  RBrace = \"RBrace\",\n  LParen = \"LParen\",\n  RParen = \"RParen\",\n  LBracket = \"LBracket\",\n  RBracket = \"RBracket\",\n\n  Colon = \"Colon\",\n  Semicolon = \"Semicolon\",\n  Comma = \"Comma\",\n\n  Ellipsis = \"Ellipsis\",\n  Dot = \"Dot\",\n  Hash = \"Hash\",\n  Greater = \"Greater\",\n  Less = \"Less\",\n  Plus = \"Plus\",\n  PlusPlus = \"PlusPlus\",\n  Minus = \"Minus\",\n  MinusMinus = \"MinusMinus\",\n  Tilde = \"Tilde\",\n  Star = \"Star\",\n  Slash = \"Slash\",\n  Percent = \"Percent\",\n\n  Equals = \"Equals\",\n  Arrow = \"Arrow\",\n  DoubleEquals = \"DoubleEquals\",\n  TripleEquals = \"TripleEquals\",\n  NotEquals = \"NotEquals\",\n  StrictNotEquals = \"StrictNotEquals\",\n  LessEqual = \"LessEqual\",\n  GreaterEqual = \"GreaterEqual\",\n  And = \"And\",\n  Or = \"Or\",\n  Pipe = \"Pipe\",\n  NullishCoalesce = \"NullishCoalesce\",\n  OptionalChain = \"OptionalChain\",\n  Bang = \"Bang\",\n\n  At = \"At\",\n  Dollar = \"Dollar\",\n  Question = \"Question\"\n}\n\nexport interface Position {\n  index: number;\n  line: number;\n  column: number;\n}\n\nexport interface Token {\n  type: TokenType;\n  value: string;\n  start: Position;\n  end: Position;\n}\n","import { Token, TokenType } from \"./token\";\n\nconst KEYWORDS: Record<string, TokenType> = {\n  behavior: TokenType.Behavior,\n  use: TokenType.Use,\n  state: TokenType.State,\n  on: TokenType.On,\n  construct: TokenType.Construct,\n  destruct: TokenType.Destruct,\n  return: TokenType.Return,\n  if: TokenType.If,\n  else: TokenType.Else,\n  for: TokenType.For,\n  while: TokenType.While,\n  try: TokenType.Try,\n  catch: TokenType.Catch,\n  assert: TokenType.Assert,\n  break: TokenType.Break,\n  continue: TokenType.Continue,\n  true: TokenType.Boolean,\n  false: TokenType.Boolean,\n  null: TokenType.Null\n};\n\nexport class Lexer {\n  private index = 0;\n  private line = 1;\n  private column = 1;\n  private pendingTokens: Token[] = [];\n  private templateMode = false;\n  private templateExpressionMode = false;\n  private templateBraceDepth = 0;\n\n  constructor(private input: string) {}\n\n  tokenize(): Token[] {\n    const tokens: Token[] = [];\n\n    while (!this.eof()) {\n      if (this.pendingTokens.length > 0) {\n        const pending = this.pendingTokens.shift();\n        if (pending) {\n          tokens.push(pending);\n          this.trackTemplateBrace(pending);\n          continue;\n        }\n      }\n\n      if (this.templateMode) {\n        const chunk = this.readTemplateChunk();\n        tokens.push(chunk);\n        continue;\n      }\n\n      const ch = this.peek();\n\n      if (this.isWhitespace(ch)) {\n        tokens.push(this.readWhitespace());\n        continue;\n      }\n\n      if (ch === \"`\") {\n        this.next();\n        this.templateMode = true;\n        continue;\n      }\n\n      if (ch === \"/\" && this.peek(1) === \"/\") {\n        this.readLineComment();\n        continue;\n      }\n\n      if (ch === \"/\" && this.peek(1) === \"*\") {\n        this.readBlockComment();\n        continue;\n      }\n\n      if (this.isAlpha(ch) || ch === \"_\") {\n        tokens.push(this.readIdentifier());\n        continue;\n      }\n\n    if (this.isDigit(ch) || (ch === \"-\" && this.isDigit(this.peek(1)))) {\n      tokens.push(this.readNumber());\n      continue;\n    }\n\n    if (ch === \"\\\"\" || ch === \"'\") {\n      tokens.push(this.readString());\n      continue;\n    }\n\n      const punct = this.readPunctuator();\n      if (punct) {\n        tokens.push(punct);\n        this.trackTemplateBrace(punct);\n        continue;\n      }\n\n      throw new Error(`Unexpected character '${ch}' at ${this.line}:${this.column}`);\n    }\n\n    return tokens;\n  }\n\n  private readWhitespace(): Token {\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof() && this.isWhitespace(this.peek())) {\n      value += this.next();\n    }\n    return this.token(TokenType.Whitespace, value, start);\n  }\n\n  private readLineComment(): void {\n    this.next();\n    this.next();\n    while (!this.eof() && this.peek() !== \"\\n\") {\n      this.next();\n    }\n  }\n\n  private readBlockComment(): void {\n    this.next();\n    this.next();\n    while (!this.eof()) {\n      if (this.peek() === \"*\" && this.peek(1) === \"/\") {\n        this.next();\n        this.next();\n        return;\n      }\n      this.next();\n    }\n  }\n\n  private readIdentifier(): Token {\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof()) {\n      const ch = this.peek();\n      if (this.isAlphaNumeric(ch) || ch === \"_\") {\n        value += this.next();\n        continue;\n      }\n      if (ch === \"-\") {\n        if (this.peek(1) === \"-\") {\n          break;\n        }\n        value += this.next();\n        continue;\n      }\n      break;\n    }\n\n    const keywordType = KEYWORDS[value];\n    if (keywordType) {\n      return this.token(keywordType, value, start);\n    }\n\n    return this.token(TokenType.Identifier, value, start);\n  }\n\n  private readNumber(): Token {\n    const start = this.position();\n    let value = \"\";\n    if (this.peek() === \"-\") {\n      value += this.next();\n    }\n    while (!this.eof() && this.isDigit(this.peek())) {\n      value += this.next();\n    }\n    if (this.peek() === \".\") {\n      value += this.next();\n      while (!this.eof() && this.isDigit(this.peek())) {\n        value += this.next();\n      }\n    }\n    return this.token(TokenType.Number, value, start);\n  }\n\n  private readString(): Token {\n    const quote = this.next();\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof()) {\n      const ch = this.next();\n      if (ch === \"\\\\\") {\n        const escaped = this.next();\n        value += escaped;\n        continue;\n      }\n      if (ch === quote) {\n        return this.token(TokenType.String, value, start);\n      }\n      value += ch;\n    }\n    throw new Error(`Unterminated string at ${start.line}:${start.column}`);\n  }\n\n  private readTemplateChunk(): Token {\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof()) {\n      const ch = this.peek();\n      if (ch === \"`\") {\n        this.next();\n        this.templateMode = false;\n        return this.token(TokenType.Template, value, start);\n      }\n      if (ch === \"$\" && this.peek(1) === \"{\") {\n        const dollarStart = this.position();\n        this.next();\n        const braceStart = this.position();\n        this.next();\n        this.templateMode = false;\n        this.templateExpressionMode = true;\n        this.templateBraceDepth = 0;\n        this.pendingTokens.push(this.token(TokenType.Dollar, \"$\", dollarStart));\n        this.pendingTokens.push(this.token(TokenType.LBrace, \"{\", braceStart));\n        return this.token(TokenType.Template, value, start);\n      }\n      if (ch === \"\\\\\") {\n        this.next();\n        const escaped = this.next();\n        value += escaped;\n        continue;\n      }\n      value += this.next();\n    }\n    throw new Error(`Unterminated template literal at ${start.line}:${start.column}`);\n  }\n\n  private readPunctuator(): Token | null {\n    const start = this.position();\n    const ch = this.peek();\n    const next = this.peek(1);\n\n    if (ch === \"=\" && next === \"=\" && this.peek(2) === \"=\") {\n      this.next();\n      this.next();\n      this.next();\n      return this.token(TokenType.TripleEquals, \"===\", start);\n    }\n    if (ch === \"=\" && next === \"=\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.DoubleEquals, \"==\", start);\n    }\n    if (ch === \"=\" && next === \">\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.Arrow, \"=>\", start);\n    }\n    if (ch === \"!\" && next === \"=\" && this.peek(2) === \"=\") {\n      this.next();\n      this.next();\n      this.next();\n      return this.token(TokenType.StrictNotEquals, \"!==\", start);\n    }\n    if (ch === \"!\" && next === \"=\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.NotEquals, \"!=\", start);\n    }\n    if (ch === \"<\" && next === \"=\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.LessEqual, \"<=\", start);\n    }\n    if (ch === \">\" && next === \"=\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.GreaterEqual, \">=\", start);\n    }\n    if (ch === \"&\" && next === \"&\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.And, \"&&\", start);\n    }\n    if (ch === \"|\" && next === \"|\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.Or, \"||\", start);\n    }\n    if (ch === \"?\" && next === \"?\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.NullishCoalesce, \"??\", start);\n    }\n    if (ch === \"?\" && next === \".\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.OptionalChain, \"?.\", start);\n    }\n    if (ch === \"|\" && next === \">\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.Pipe, \"|>\", start);\n    }\n    if (ch === \"+\" && next === \"+\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.PlusPlus, \"++\", start);\n    }\n    if (ch === \"-\" && next === \"-\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.MinusMinus, \"--\", start);\n    }\n    if (ch === \".\" && next === \".\" && this.peek(2) === \".\") {\n      this.next();\n      this.next();\n      this.next();\n      return this.token(TokenType.Ellipsis, \"...\", start);\n    }\n    const punctMap: Record<string, TokenType> = {\n      \"{\": TokenType.LBrace,\n      \"}\": TokenType.RBrace,\n      \"(\": TokenType.LParen,\n      \")\": TokenType.RParen,\n      \"[\": TokenType.LBracket,\n      \"]\": TokenType.RBracket,\n      \":\": TokenType.Colon,\n      \";\": TokenType.Semicolon,\n      \",\": TokenType.Comma,\n      \".\": TokenType.Dot,\n      \"#\": TokenType.Hash,\n      \">\": TokenType.Greater,\n      \"<\": TokenType.Less,\n      \"+\": TokenType.Plus,\n      \"-\": TokenType.Minus,\n      \"~\": TokenType.Tilde,\n      \"*\": TokenType.Star,\n      \"/\": TokenType.Slash,\n      \"%\": TokenType.Percent,\n      \"=\": TokenType.Equals,\n      \"!\": TokenType.Bang,\n      \"@\": TokenType.At,\n      \"$\": TokenType.Dollar,\n      \"?\": TokenType.Question\n    };\n\n    const type = punctMap[ch];\n    if (!type) {\n      return null;\n    }\n\n    this.next();\n    return this.token(type, ch, start);\n  }\n\n  private trackTemplateBrace(token: Token): void {\n    if (!this.templateExpressionMode) {\n      return;\n    }\n    if (token.type === TokenType.LBrace) {\n      this.templateBraceDepth += 1;\n    } else if (token.type === TokenType.RBrace) {\n      this.templateBraceDepth -= 1;\n      if (this.templateBraceDepth <= 0) {\n        this.templateExpressionMode = false;\n        this.templateMode = true;\n      }\n    }\n  }\n\n  private token(type: TokenType, value: string, start: { index: number; line: number; column: number }): Token {\n    return {\n      type,\n      value,\n      start,\n      end: this.position()\n    };\n  }\n\n  private position() {\n    return { index: this.index, line: this.line, column: this.column };\n  }\n\n  private peek(offset = 0): string {\n    return this.input[this.index + offset] ?? \"\";\n  }\n\n  private next(): string {\n    const ch = this.input[this.index++] ?? \"\";\n    if (ch === \"\\n\") {\n      this.line += 1;\n      this.column = 1;\n    } else {\n      this.column += 1;\n    }\n    return ch;\n  }\n\n  private eof(): boolean {\n    return this.index >= this.input.length;\n  }\n\n  private isWhitespace(ch: string): boolean {\n    return ch === \" \" || ch === \"\\t\" || ch === \"\\n\" || ch === \"\\r\";\n  }\n\n  private isAlpha(ch: string): boolean {\n    return (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\");\n  }\n\n  private isDigit(ch: string): boolean {\n    return ch >= \"0\" && ch <= \"9\";\n  }\n\n  private isAlphaNumeric(ch: string): boolean {\n    return this.isAlpha(ch) || this.isDigit(ch);\n  }\n}\n","export interface ExecutionContext {\n  scope: {\n    getPath(key: string): any;\n    setPath?(key: string, value: any): void;\n    hasKey?(key: string): boolean;\n    createChild?(): ExecutionContext[\"scope\"];\n  } | undefined;\n  rootScope: ExecutionContext[\"scope\"];\n  globals?: Record<string, any>;\n  element?: Element;\n  returnValue?: any;\n  returning?: boolean;\n  breaking?: boolean;\n  continuing?: boolean;\n}\n\nexport interface CFSNode {\n  type: string;\n  prepare(context: ExecutionContext): Promise<void>;\n  evaluate(context: ExecutionContext): any;\n}\n\nexport abstract class BaseNode implements CFSNode {\n  constructor(public type: string) {}\n\n  async prepare(_context: ExecutionContext): Promise<void> {\n    return;\n  }\n\n  evaluate(_context: ExecutionContext): any {\n    return undefined;\n  }\n}\n\nfunction isPromiseLike<T>(value: T | Promise<T>): value is Promise<T> {\n  return Boolean(value) && typeof (value as Promise<T>).then === \"function\";\n}\n\nfunction resolveMaybe<T, R>(value: T | Promise<T>, next: (value: T) => R | Promise<R>): R | Promise<R> {\n  if (isPromiseLike(value)) {\n    return value.then(next);\n  }\n  return next(value);\n}\n\nfunction evaluateWithChildScope(context: ExecutionContext, block: BlockNode): any {\n  const scope = context.scope;\n  if (!scope || !scope.createChild) {\n    return block.evaluate(context);\n  }\n  const previousScope = context.scope;\n  context.scope = scope.createChild();\n  try {\n    return block.evaluate(context);\n  } finally {\n    context.scope = previousScope;\n  }\n}\n\nexport class ProgramNode extends BaseNode {\n  constructor(public behaviors: BehaviorNode[], public uses: UseNode[] = []) {\n    super(\"Program\");\n  }\n}\n\nexport interface UseFlags {\n  wait?: boolean;\n}\n\nexport interface UseFlagArgs {\n  wait?: { timeoutMs?: number; intervalMs?: number };\n}\n\nexport class UseNode extends BaseNode {\n  constructor(\n    public name: string,\n    public alias: string,\n    public flags: UseFlags = {},\n    public flagArgs: UseFlagArgs = {}\n  ) {\n    super(\"Use\");\n  }\n}\n\nexport class BlockNode extends BaseNode {\n  constructor(public statements: CFSNode[]) {\n    super(\"Block\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    let index = 0;\n    const run = (): any => {\n      while (index < this.statements.length) {\n        if (context.returning || context.breaking || context.continuing) {\n          break;\n        }\n        const statement = this.statements[index];\n        index += 1;\n        if (statement && typeof statement.evaluate === \"function\") {\n          const result = statement.evaluate(context);\n          if (isPromiseLike(result)) {\n            return result.then(() => run());\n          }\n        }\n      }\n      return undefined;\n    };\n    return run();\n  }\n}\n\nexport class SelectorNode extends BaseNode {\n  constructor(public selectorText: string) {\n    super(\"Selector\");\n  }\n}\n\nexport class BehaviorNode extends BaseNode {\n  constructor(\n    public selector: SelectorNode,\n    public body: BlockNode,\n    public flags: BehaviorFlags = {},\n    public flagArgs: BehaviorFlagArgs = {}\n  ) {\n    super(\"Behavior\");\n  }\n}\n\n\nexport class OnBlockNode extends BaseNode {\n  constructor(\n    public eventName: string,\n    public args: string[],\n    public body: BlockNode,\n    public flags: DeclarationFlags = {},\n    public flagArgs: DeclarationFlagArgs = {}\n  ) {\n    super(\"OnBlock\");\n  }\n}\n\nexport class AssignmentNode extends BaseNode {\n  constructor(\n    public target: AssignmentTarget,\n    public value: ExpressionNode,\n    public operator: \"=\" | \"+=\" | \"-=\" | \"*=\" | \"/=\" | \"~=\" | \"++\" | \"--\" = \"=\",\n    public prefix = false\n  ) {\n    super(\"Assignment\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const target = this.target;\n    if (target instanceof DirectiveExpression) {\n      const value = this.value.evaluate(context);\n      return resolveMaybe(value, (resolvedValue) => {\n        this.assignDirectiveTarget(context, target, resolvedValue, this.operator);\n        return resolvedValue;\n      });\n    }\n    if (!context.scope || !context.scope.setPath) {\n      return undefined;\n    }\n    if (this.operator === \"++\" || this.operator === \"--\") {\n      return this.applyIncrement(context);\n    }\n    const value = this.value.evaluate(context);\n    return resolveMaybe(value, (resolvedValue) => {\n      if (this.operator !== \"=\") {\n        return this.applyCompoundAssignment(context, resolvedValue);\n      }\n      if (this.target instanceof IdentifierExpression && this.target.name.startsWith(\"root.\") && context.rootScope) {\n        const path = this.target.name.slice(\"root.\".length);\n        context.rootScope.setPath?.(`self.${path}`, resolvedValue);\n        return resolvedValue;\n      }\n      if (this.target instanceof MemberExpression || this.target instanceof IndexExpression) {\n        const resolved = this.resolveAssignmentTarget(context);\n        return resolveMaybe(resolved, (resolvedTarget) => {\n          if (resolvedTarget?.scope?.setPath) {\n            resolvedTarget.scope.setPath(resolvedTarget.path, resolvedValue);\n            return resolvedValue;\n          }\n          this.assignTarget(context, this.target, resolvedValue);\n          return resolvedValue;\n        });\n      }\n      this.assignTarget(context, this.target, resolvedValue, this.operator);\n      return resolvedValue;\n    });\n  }\n\n  private applyCompoundAssignment(context: ExecutionContext, value: any): any {\n    if (!context.scope || !context.scope.setPath) {\n      return undefined;\n    }\n    const resolved = this.resolveAssignmentTarget(context);\n    return resolveMaybe(resolved, (resolvedTarget) => {\n      if (!resolvedTarget) {\n        throw new Error(\"Compound assignment requires a simple identifier or member path\");\n      }\n      const { scope, path } = resolvedTarget;\n      const current = scope?.getPath ? scope.getPath(path) : undefined;\n      let result: any;\n      if (this.operator === \"+=\") {\n        result = current + value;\n      } else if (this.operator === \"-=\") {\n        result = current - value;\n      } else if (this.operator === \"*=\") {\n        result = current * value;\n      } else {\n        result = current / value;\n      }\n      scope?.setPath?.(path, result);\n      return result;\n    });\n  }\n\n  private applyIncrement(context: ExecutionContext): any {\n    if (!context.scope || !context.scope.setPath) {\n      return undefined;\n    }\n    const resolved = this.resolveAssignmentTarget(context);\n    return resolveMaybe(resolved, (resolvedTarget) => {\n      if (!resolvedTarget) {\n        throw new Error(\"Increment/decrement requires a simple identifier or member path\");\n      }\n      const { scope, path } = resolvedTarget;\n      const current = scope?.getPath ? scope.getPath(path) : undefined;\n      const numeric = typeof current === \"number\" ? current : Number(current);\n      const delta = this.operator === \"++\" ? 1 : -1;\n      const next = (Number.isNaN(numeric) ? 0 : numeric) + delta;\n      scope?.setPath?.(path, next);\n      return this.prefix ? next : numeric;\n    });\n  }\n\n  private resolveAssignmentTarget(\n    context: ExecutionContext\n  ): { scope: ExecutionContext[\"scope\"]; path: string } | null | Promise<{ scope: ExecutionContext[\"scope\"]; path: string } | null> {\n    if (this.target instanceof IdentifierExpression) {\n      const isRoot = this.target.name.startsWith(\"root.\");\n      const rawPath = isRoot ? this.target.name.slice(\"root.\".length) : this.target.name;\n      if (isRoot) {\n        if (context.rootScope) {\n          return { scope: context.rootScope, path: `self.${rawPath}` };\n        }\n        return { scope: context.scope, path: `root.${rawPath}` };\n      }\n      return { scope: context.scope, path: rawPath };\n    }\n    if (this.target instanceof MemberExpression) {\n      const resolvedPath = this.target.getIdentifierPath();\n      if (resolvedPath) {\n        const path = resolvedPath.path;\n        const isRoot = path.startsWith(\"root.\");\n        const rawPath = isRoot ? path.slice(\"root.\".length) : path;\n        if (isRoot) {\n          if (context.rootScope) {\n            return { scope: context.rootScope, path: `self.${rawPath}` };\n          }\n          return { scope: context.scope, path: `root.${rawPath}` };\n        }\n        return { scope: context.scope, path: rawPath };\n      }\n      const targetExpr = this.target;\n      const basePath = this.resolveTargetPath(context, targetExpr.target);\n      return resolveMaybe(basePath, (resolvedBase) => {\n        if (!resolvedBase) {\n          return null;\n        }\n        const path = `${resolvedBase}.${targetExpr.property}`;\n        const isRoot = path.startsWith(\"root.\");\n        const rawPath = isRoot ? path.slice(\"root.\".length) : path;\n        if (isRoot) {\n          if (context.rootScope) {\n            return { scope: context.rootScope, path: `self.${rawPath}` };\n          }\n          return { scope: context.scope, path: `root.${rawPath}` };\n        }\n        return { scope: context.scope, path: rawPath };\n      });\n    }\n    if (this.target instanceof IndexExpression) {\n      const path = this.resolveIndexPath(context, this.target);\n      return resolveMaybe(path, (resolvedPath) => {\n        if (!resolvedPath) {\n          return null;\n        }\n        const isRoot = resolvedPath.startsWith(\"root.\");\n        const rawPath = isRoot ? resolvedPath.slice(\"root.\".length) : resolvedPath;\n        if (isRoot) {\n          if (context.rootScope) {\n            return { scope: context.rootScope, path: `self.${rawPath}` };\n          }\n          return { scope: context.scope, path: `root.${rawPath}` };\n        }\n        return { scope: context.scope, path: rawPath };\n      });\n    }\n    return null;\n  }\n\n  private resolveIndexPath(context: ExecutionContext, expr: IndexExpression): string | null | Promise<string | null> {\n    const base = this.resolveTargetPath(context, expr.target);\n    return resolveMaybe(base, (resolvedBase) => {\n      if (!resolvedBase) {\n        return null;\n      }\n      const indexValue = expr.index.evaluate(context);\n      return resolveMaybe(indexValue, (resolvedIndex) => {\n        if (resolvedIndex == null) {\n          return null;\n        }\n        return `${resolvedBase}.${resolvedIndex}`;\n      });\n    });\n  }\n\n  private resolveTargetPath(context: ExecutionContext, target: ExpressionNode): string | null | Promise<string | null> {\n    if (target instanceof IdentifierExpression) {\n      return target.name;\n    }\n    if (target instanceof MemberExpression) {\n      return target.getIdentifierPath()?.path ?? null;\n    }\n    if (target instanceof IndexExpression) {\n      return this.resolveIndexPath(context, target);\n    }\n    return null;\n  }\n\n  private assignTarget(\n    context: ExecutionContext,\n    target: AssignmentTarget,\n    value: any,\n    operator: AssignmentNode[\"operator\"] = \"=\"\n  ): void {\n    if (!context.scope || !context.scope.setPath) {\n      return;\n    }\n    if (target instanceof DirectiveExpression) {\n      this.assignDirectiveTarget(context, target, value, operator);\n      return;\n    }\n    if (target instanceof IdentifierExpression) {\n      context.scope.setPath(target.name, value);\n      return;\n    }\n    if (target instanceof ArrayPattern) {\n      const source = Array.isArray(value) ? value : [];\n      let index = 0;\n      for (const element of target.elements) {\n        if (element instanceof RestElement) {\n          context.scope.setPath(element.target.name, source.slice(index));\n          return;\n        }\n        if (element === null) {\n          index += 1;\n          continue;\n        }\n        this.assignTarget(context, element, source[index], operator);\n        index += 1;\n      }\n      return;\n    }\n    if (target instanceof ObjectPattern) {\n      const source = value && typeof value === \"object\" ? value : {};\n      const usedKeys = new Set<string>();\n      for (const entry of target.entries) {\n        if (\"rest\" in entry) {\n          const rest: Record<string, any> = {};\n          for (const key of Object.keys(source)) {\n            if (!usedKeys.has(key)) {\n              rest[key] = (source as any)[key];\n            }\n          }\n          context.scope.setPath(entry.rest.name, rest);\n          continue;\n        }\n        usedKeys.add(entry.key);\n        this.assignTarget(context, entry.target, (source as any)[entry.key], operator);\n      }\n      return;\n    }\n  }\n\n  private assignDirectiveTarget(\n    context: ExecutionContext,\n    target: DirectiveExpression,\n    value: any,\n    operator: AssignmentNode[\"operator\"] = \"=\"\n  ): void {\n    const element = context.element;\n    if (!element) {\n      return;\n    }\n    if (target.kind === \"attr\") {\n      if (target.name === \"class\" && element instanceof HTMLElement && operator !== \"=\") {\n        const classes = normalizeClassList(value);\n        if (classes.length === 0) {\n          return;\n        }\n        if (operator === \"+=\") {\n          element.classList.add(...classes);\n          return;\n        }\n        if (operator === \"-=\") {\n          element.classList.remove(...classes);\n          return;\n        }\n        if (operator === \"~=\") {\n          for (const name of classes) {\n            element.classList.toggle(name);\n          }\n          return;\n        }\n      }\n      if (target.name === \"value\") {\n        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n          element.value = value == null ? \"\" : String(value);\n          element.setAttribute(\"value\", element.value);\n          return;\n        }\n        if (element instanceof HTMLSelectElement) {\n          element.value = value == null ? \"\" : String(value);\n          return;\n        }\n      }\n      if (target.name === \"checked\" && element instanceof HTMLInputElement) {\n        const checked = value === true || value === \"true\" || value === 1 || value === \"1\";\n        element.checked = checked;\n        if (checked) {\n          element.setAttribute(\"checked\", \"\");\n        } else {\n          element.removeAttribute(\"checked\");\n        }\n        return;\n      }\n      if (target.name === \"html\" && element instanceof HTMLElement) {\n        element.innerHTML = value == null ? \"\" : String(value);\n        return;\n      }\n      element.setAttribute(target.name, value == null ? \"\" : String(value));\n      return;\n    }\n    if (target.kind === \"style\" && element instanceof HTMLElement) {\n      element.style.setProperty(target.name, value == null ? \"\" : String(value));\n    }\n  }\n}\n\nfunction normalizeClassList(value: any): string[] {\n  if (value == null) {\n    return [];\n  }\n  if (Array.isArray(value)) {\n    return value\n      .flatMap((entry) => String(entry).split(/\\s+/))\n      .map((entry) => entry.trim())\n      .filter(Boolean);\n  }\n  return String(value)\n    .split(/\\s+/)\n    .map((entry) => entry.trim())\n    .filter(Boolean);\n}\n\nexport class ReturnNode extends BaseNode {\n  constructor(public value?: ExpressionNode) {\n    super(\"Return\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    if (context.returning) {\n      return context.returnValue;\n    }\n    const nextValue = this.value ? this.value.evaluate(context) : undefined;\n    return resolveMaybe(nextValue, (resolved) => {\n      context.returnValue = resolved;\n      context.returning = true;\n      return context.returnValue;\n    });\n  }\n}\n\nexport class BreakNode extends BaseNode {\n  constructor() {\n    super(\"Break\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    context.breaking = true;\n    return undefined;\n  }\n}\n\nexport class ContinueNode extends BaseNode {\n  constructor() {\n    super(\"Continue\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    context.continuing = true;\n    return undefined;\n  }\n}\n\nexport class AssertError extends Error {\n  constructor(message = \"Assertion failed\") {\n    super(message);\n    this.name = \"AssertError\";\n  }\n}\n\nexport class AssertNode extends BaseNode {\n  constructor(public test: ExpressionNode) {\n    super(\"Assert\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const value = this.test.evaluate(context);\n    return resolveMaybe(value, (resolved) => {\n      if (!resolved) {\n        throw new AssertError();\n      }\n      return resolved;\n    });\n  }\n}\n\nexport class IfNode extends BaseNode {\n  constructor(\n    public test: ExpressionNode,\n    public consequent: BlockNode,\n    public alternate?: BlockNode\n  ) {\n    super(\"If\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const condition = this.test.evaluate(context);\n    return resolveMaybe(condition, (resolved) => {\n      if (resolved) {\n        return evaluateWithChildScope(context, this.consequent);\n      }\n      if (this.alternate) {\n        return evaluateWithChildScope(context, this.alternate);\n      }\n      return undefined;\n    });\n  }\n}\n\nexport class WhileNode extends BaseNode {\n  constructor(public test: ExpressionNode, public body: BlockNode) {\n    super(\"While\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const previousScope = context.scope;\n    if (context.scope?.createChild) {\n      context.scope = context.scope.createChild();\n    }\n    const run = (): any => {\n      const condition = this.test.evaluate(context);\n      return resolveMaybe(condition, (resolved) => {\n        if (!resolved || context.returning) {\n          return undefined;\n        }\n        const bodyResult = this.body.evaluate(context);\n        return resolveMaybe(bodyResult, () => {\n          if (context.breaking) {\n            context.breaking = false;\n            return undefined;\n          }\n          if (context.continuing) {\n            context.continuing = false;\n          }\n          return run();\n        });\n      });\n    };\n    const result = run();\n    if (isPromiseLike(result)) {\n      return result.finally(() => {\n        context.scope = previousScope;\n      });\n    }\n    context.scope = previousScope;\n    return result;\n  }\n}\n\nexport class ForEachNode extends BaseNode {\n  constructor(\n    public target: IdentifierExpression,\n    public iterable: ExpressionNode,\n    public kind: \"in\" | \"of\",\n    public body: BlockNode\n  ) {\n    super(\"ForEach\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const iterableValue = this.iterable.evaluate(context);\n    return resolveMaybe(iterableValue, (resolved) => {\n      const entries = this.getEntries(resolved);\n      const previousScope = context.scope;\n      let bodyScope = context.scope;\n      if (context.scope?.createChild) {\n        bodyScope = context.scope.createChild();\n      }\n      let index = 0;\n      const loop = (): any => {\n        if (index >= entries.length || context.returning) {\n          context.scope = previousScope;\n          return undefined;\n        }\n        const value = entries[index]!;\n        index += 1;\n        context.scope = bodyScope;\n        context.scope?.setPath?.(this.target.name, value);\n        const bodyResult = this.body.evaluate(context);\n        return resolveMaybe(bodyResult, () => {\n          if (context.breaking) {\n            context.breaking = false;\n            context.scope = previousScope;\n            return undefined;\n          }\n          if (context.continuing) {\n            context.continuing = false;\n          }\n          context.scope = previousScope;\n          return loop();\n        });\n      };\n      return loop();\n    });\n  }\n\n  private getEntries(value: any): any[] {\n    if (value == null) {\n      return [];\n    }\n    if (this.kind === \"in\") {\n      if (typeof value === \"object\") {\n        return Object.keys(value);\n      }\n      return [];\n    }\n    if (typeof value === \"string\") {\n      return Array.from(value);\n    }\n    if (typeof value[Symbol.iterator] === \"function\") {\n      return Array.from(value as Iterable<any>);\n    }\n    if (typeof value === \"object\") {\n      return Object.values(value);\n    }\n    return [];\n  }\n}\n\nexport class ForNode extends BaseNode {\n  constructor(\n    public init: CFSNode | undefined,\n    public test: ExpressionNode | undefined,\n    public update: CFSNode | undefined,\n    public body: BlockNode\n  ) {\n    super(\"For\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const initResult = this.init ? this.init.evaluate(context) : undefined;\n    const run = (): any => {\n      const previousScope = context.scope;\n      let bodyScope = context.scope;\n      if (context.scope?.createChild) {\n        bodyScope = context.scope.createChild();\n      }\n      const loop = (): any => {\n        const testResult = this.test ? this.test.evaluate(context) : true;\n        return resolveMaybe(testResult, (passed) => {\n          if (!passed || context.returning) {\n            context.scope = previousScope;\n            return undefined;\n          }\n          context.scope = bodyScope;\n          const bodyResult = this.body.evaluate(context);\n          return resolveMaybe(bodyResult, () => {\n            if (context.returning) {\n              context.scope = previousScope;\n              return undefined;\n            }\n            if (context.breaking) {\n              context.breaking = false;\n              context.scope = previousScope;\n              return undefined;\n            }\n            context.scope = previousScope;\n            if (context.continuing) {\n              context.continuing = false;\n            }\n            const updateResult = this.update ? this.update.evaluate(context) : undefined;\n            return resolveMaybe(updateResult, () => loop());\n          });\n        });\n      };\n      return loop();\n    };\n    return resolveMaybe(initResult, () => run());\n  }\n}\n\nexport class TryNode extends BaseNode {\n  constructor(\n    public body: BlockNode,\n    public errorName: string,\n    public handler: BlockNode\n  ) {\n    super(\"Try\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const handleError = (error: any): any => {\n      if (context.returning) {\n        return context.returnValue;\n      }\n      const previousScope = context.scope;\n      let handlerScope = context.scope;\n      if (context.scope?.createChild) {\n        handlerScope = context.scope.createChild();\n      }\n      context.scope = handlerScope;\n      const scope = context.scope;\n      let previous: any = undefined;\n      if (scope) {\n        previous = scope.getPath(this.errorName);\n        if (scope.setPath) {\n          scope.setPath(`self.${this.errorName}`, error);\n        }\n      }\n      const handlerResult = this.handler.evaluate(context);\n      return resolveMaybe(handlerResult, () => {\n        if (scope && scope.setPath && handlerScope === previousScope) {\n          scope.setPath(this.errorName, previous);\n        }\n        context.scope = previousScope;\n        return undefined;\n      });\n    };\n\n    try {\n      const bodyResult = evaluateWithChildScope(context, this.body);\n      if (isPromiseLike(bodyResult)) {\n        return bodyResult.catch((error) => handleError(error));\n      }\n      return bodyResult;\n    } catch (error) {\n      return handleError(error);\n    }\n  }\n}\n\nexport class FunctionDeclarationNode extends BaseNode {\n  constructor(\n    public name: string,\n    public params: FunctionParam[],\n    public body: BlockNode,\n    public isAsync = false\n  ) {\n    super(\"FunctionDeclaration\");\n  }\n}\n\nexport class FunctionExpression extends BaseNode {\n  constructor(\n    public params: FunctionParam[],\n    public body: BlockNode,\n    public isAsync = false\n  ) {\n    super(\"FunctionExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const scope = context.scope;\n    const globals = context.globals;\n    const element = context.element;\n\n    if (this.isAsync) {\n      return (...args: any[]) => {\n        const activeScope = scope?.createChild ? scope.createChild() : scope;\n        const inner: ExecutionContext = {\n          scope: activeScope,\n          rootScope: context.rootScope,\n          ...(globals ? { globals } : {}),\n          ...(element ? { element } : {}),\n          returnValue: undefined,\n          returning: false,\n          breaking: false,\n          continuing: false\n        };\n        const previousValues = new Map<string, any>();\n        const applyResult = activeScope\n          ? this.applyParams(activeScope, previousValues, inner, args)\n          : undefined;\n        const bodyResult = resolveMaybe(applyResult, () => this.body.evaluate(inner));\n        const finalResult = resolveMaybe(bodyResult, () => inner.returnValue);\n        return Promise.resolve(finalResult).finally(() => {\n          if (activeScope && activeScope === scope) {\n            this.restoreParams(activeScope, previousValues);\n          }\n        });\n      };\n    }\n\n    return (...args: any[]) => {\n      const activeScope = scope?.createChild ? scope.createChild() : scope;\n      const inner: ExecutionContext = {\n        scope: activeScope,\n        rootScope: context.rootScope,\n        ...(globals ? { globals } : {}),\n        ...(element ? { element } : {}),\n        returnValue: undefined,\n        returning: false,\n        breaking: false,\n        continuing: false\n      };\n      const previousValues = new Map<string, any>();\n      const applyResult = activeScope\n        ? this.applyParams(activeScope, previousValues, inner, args)\n        : undefined;\n      const bodyResult = resolveMaybe(applyResult, () => this.body.evaluate(inner));\n      const finalResult = resolveMaybe(bodyResult, () => inner.returnValue);\n      if (isPromiseLike(finalResult)) {\n        return finalResult.finally(() => {\n          if (activeScope && activeScope === scope) {\n            this.restoreParams(activeScope, previousValues);\n          }\n        });\n      }\n      if (activeScope && activeScope === scope) {\n        this.restoreParams(activeScope, previousValues);\n      }\n      return finalResult;\n    };\n  }\n\n  private applyParams(\n    scope: ExecutionContext[\"scope\"],\n    previousValues: Map<string, any>,\n    context: ExecutionContext,\n    args: any[]\n  ): any {\n    if (!scope) {\n      return;\n    }\n    const setPath = scope.setPath?.bind(scope);\n    if (!setPath) {\n      return;\n    }\n    const params = this.params;\n    const applyAt = (paramIndex: number, argIndex: number): any => {\n      for (let i = paramIndex; i < params.length; i += 1) {\n        const param = params[i]!;\n        const name = param.name;\n        if (!name) {\n          continue;\n        }\n        previousValues.set(name, scope.getPath(name));\n        if (param.rest) {\n          setPath(`self.${name}`, args.slice(argIndex));\n          return;\n        }\n        let value = args[argIndex];\n        if (value === undefined && param.defaultValue) {\n          const defaultValue = param.defaultValue.evaluate(context);\n          return resolveMaybe(defaultValue, (resolvedDefault) => {\n            setPath(`self.${name}`, resolvedDefault);\n            return applyAt(i + 1, argIndex + 1);\n          });\n        }\n        setPath(`self.${name}`, value);\n        argIndex += 1;\n      }\n      return;\n    };\n    return applyAt(0, 0);\n  }\n\n  private restoreParams(scope: ExecutionContext[\"scope\"], previousValues: Map<string, any>): void {\n    if (!scope) {\n      return;\n    }\n    const setPath = scope.setPath?.bind(scope);\n    if (!setPath) {\n      return;\n    }\n    for (const param of this.params) {\n      const name = param.name;\n      if (!name) {\n        continue;\n      }\n      setPath(name, previousValues.get(name));\n    }\n  }\n}\n\nexport interface DeclarationFlags {\n  important?: boolean;\n  debounce?: boolean;\n  [key: string]: boolean | undefined;\n}\n\nexport interface DeclarationFlagArgs {\n  debounce?: number;\n  [key: string]: any;\n}\n\nexport interface BehaviorFlags {\n  [key: string]: boolean | undefined;\n}\n\nexport interface BehaviorFlagArgs {\n  [key: string]: any;\n}\n\nexport class DeclarationNode extends BaseNode {\n  constructor(\n    public target: DeclarationTarget,\n    public operator: \":\" | \":=\" | \":<\" | \":>\",\n    public value: ExpressionNode,\n    public flags: DeclarationFlags,\n    public flagArgs: DeclarationFlagArgs\n  ) {\n    super(\"Declaration\");\n  }\n}\n\nexport type ExpressionNode =\n  | AssignmentNode\n  | IdentifierExpression\n  | LiteralExpression\n  | TemplateExpression\n  | UnaryExpression\n  | BinaryExpression\n  | MemberExpression\n  | CallExpression\n  | ArrayExpression\n  | ObjectExpression\n  | IndexExpression\n  | FunctionExpression\n  | AwaitExpression\n  | TernaryExpression\n  | DirectiveExpression\n  | QueryExpression;\n\nexport type DeclarationTarget = IdentifierExpression | DirectiveExpression;\nexport type AssignmentTarget =\n  | IdentifierExpression\n  | MemberExpression\n  | IndexExpression\n  | DirectiveExpression\n  | ArrayPattern\n  | ObjectPattern;\n\nexport type FunctionParam = {\n  name: string;\n  defaultValue?: ExpressionNode;\n  rest?: boolean;\n};\n\nexport type PatternNode = IdentifierExpression | ArrayPattern | ObjectPattern;\n\nexport class IdentifierExpression extends BaseNode {\n  constructor(public name: string) {\n    super(\"Identifier\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    if (this.name.startsWith(\"root.\") && context.rootScope) {\n      const path = this.name.slice(\"root.\".length);\n      return context.rootScope.getPath(`self.${path}`);\n    }\n    if (context.scope) {\n      const value = context.scope.getPath(this.name);\n      const root = this.name.split(\".\")[0];\n      const explicit = this.name.startsWith(\"parent.\")\n        || this.name.startsWith(\"root.\")\n        || this.name.startsWith(\"self.\");\n      if (explicit || value !== undefined || (root && context.scope.hasKey?.(root))) {\n        return value;\n      }\n    }\n    return context.globals ? context.globals[this.name] : undefined;\n  }\n}\n\nexport class SpreadElement extends BaseNode {\n  constructor(public value: ExpressionNode) {\n    super(\"SpreadElement\");\n  }\n}\n\nexport class RestElement extends BaseNode {\n  constructor(public target: IdentifierExpression) {\n    super(\"RestElement\");\n  }\n}\n\nexport type ArrayPatternElement = PatternNode | RestElement | null;\n\nexport class ArrayPattern extends BaseNode {\n  constructor(public elements: ArrayPatternElement[]) {\n    super(\"ArrayPattern\");\n  }\n}\n\nexport type ObjectPatternEntry =\n  | { key: string; target: PatternNode }\n  | { rest: IdentifierExpression };\n\nexport class ObjectPattern extends BaseNode {\n  constructor(public entries: ObjectPatternEntry[]) {\n    super(\"ObjectPattern\");\n  }\n}\n\nexport class LiteralExpression extends BaseNode {\n  constructor(public value: string | number | boolean | null) {\n    super(\"Literal\");\n  }\n\n  evaluate(): any {\n    return this.value;\n  }\n}\n\nexport class TemplateExpression extends BaseNode {\n  constructor(public parts: ExpressionNode[]) {\n    super(\"TemplateExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    let result = \"\";\n    let index = 0;\n    const run = (): any => {\n      while (index < this.parts.length) {\n        const part = this.parts[index]!;\n        index += 1;\n        const value = part.evaluate(context);\n        return resolveMaybe(value, (resolved) => {\n          result += resolved == null ? \"\" : String(resolved);\n          return run();\n        });\n      }\n      return result;\n    };\n    return run();\n  }\n}\n\nexport class UnaryExpression extends BaseNode {\n  constructor(public operator: string, public argument: ExpressionNode) {\n    super(\"UnaryExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const value = this.argument.evaluate(context);\n    return resolveMaybe(value, (resolved) => {\n      if (this.operator === \"!\") {\n        return !resolved;\n      }\n      if (this.operator === \"-\") {\n        return -(resolved as any);\n      }\n      return resolved;\n    });\n  }\n}\n\nexport class BinaryExpression extends BaseNode {\n  constructor(\n    public operator: string,\n    public left: ExpressionNode,\n    public right: ExpressionNode\n  ) {\n    super(\"BinaryExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const leftValue = this.left.evaluate(context);\n    return resolveMaybe(leftValue, (resolvedLeft) => {\n      if (this.operator === \"&&\") {\n        if (!resolvedLeft) {\n          return resolvedLeft;\n        }\n        return this.right.evaluate(context);\n      }\n      if (this.operator === \"||\") {\n        if (resolvedLeft) {\n          return resolvedLeft;\n        }\n        return this.right.evaluate(context);\n      }\n      if (this.operator === \"??\") {\n        if (resolvedLeft !== null && resolvedLeft !== undefined) {\n          return resolvedLeft;\n        }\n        return this.right.evaluate(context);\n      }\n      const rightValue = this.right.evaluate(context);\n      return resolveMaybe(rightValue, (resolvedRight) => {\n        if (this.operator === \"+\") {\n          return (resolvedLeft as any) + (resolvedRight as any);\n        }\n        if (this.operator === \"-\") {\n          return (resolvedLeft as any) - (resolvedRight as any);\n        }\n        if (this.operator === \"*\") {\n          return (resolvedLeft as any) * (resolvedRight as any);\n        }\n        if (this.operator === \"/\") {\n          return (resolvedLeft as any) / (resolvedRight as any);\n        }\n        if (this.operator === \"%\") {\n          return (resolvedLeft as any) % (resolvedRight as any);\n        }\n        if (this.operator === \"==\") {\n          return resolvedLeft == resolvedRight;\n        }\n        if (this.operator === \"!=\") {\n          return resolvedLeft != resolvedRight;\n        }\n        if (this.operator === \"===\") {\n          return resolvedLeft === resolvedRight;\n        }\n        if (this.operator === \"!==\") {\n          return resolvedLeft !== resolvedRight;\n        }\n        if (this.operator === \"<\") {\n          return (resolvedLeft as any) < (resolvedRight as any);\n        }\n        if (this.operator === \">\") {\n          return (resolvedLeft as any) > (resolvedRight as any);\n        }\n        if (this.operator === \"<=\") {\n          return (resolvedLeft as any) <= (resolvedRight as any);\n        }\n        if (this.operator === \">=\") {\n          return (resolvedLeft as any) >= (resolvedRight as any);\n        }\n        return undefined;\n      });\n    });\n  }\n}\n\nexport class TernaryExpression extends BaseNode {\n  constructor(\n    public test: ExpressionNode,\n    public consequent: ExpressionNode,\n    public alternate: ExpressionNode\n  ) {\n    super(\"TernaryExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const condition = this.test.evaluate(context);\n    return resolveMaybe(condition, (resolved) => {\n      if (resolved) {\n        return this.consequent.evaluate(context);\n      }\n      return this.alternate.evaluate(context);\n    });\n  }\n}\n\nexport class MemberExpression extends BaseNode {\n  constructor(\n    public target: ExpressionNode,\n    public property: string,\n    public optional = false\n  ) {\n    super(\"MemberExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const resolved = this.resolve(context);\n    return resolveMaybe(resolved, (resolvedValue) => resolvedValue?.value);\n  }\n\n  resolve(\n    context: ExecutionContext\n  ): { value: any; target?: any; optional?: boolean } | undefined | Promise<{ value: any; target?: any; optional?: boolean } | undefined> {\n    const path = this.getIdentifierPath();\n    if (path) {\n      const resolved = this.resolveFromScope(context, path);\n      if (resolved) {\n        return resolved;\n      }\n      const resolvedGlobal = this.resolveFromGlobals(context, path);\n      if (resolvedGlobal) {\n        return resolvedGlobal;\n      }\n    }\n\n    const target = this.target.evaluate(context);\n    return resolveMaybe(target, (resolvedTarget) => {\n      if (resolvedTarget == null) {\n        return { value: undefined, target: resolvedTarget, optional: this.optional };\n      }\n      return { value: (resolvedTarget as any)[this.property], target: resolvedTarget, optional: this.optional };\n    });\n  }\n\n  getIdentifierPath(): { path: string; root: string } | undefined {\n    const targetPath = this.getTargetIdentifierPath();\n    if (!targetPath) {\n      return undefined;\n    }\n    const path = `${targetPath.path}.${this.property}`;\n    return { path, root: targetPath.root };\n  }\n\n  private getTargetIdentifierPath(): { path: string; root: string } | undefined {\n    if (this.target instanceof IdentifierExpression) {\n      const name = this.target.name;\n      const root = name.split(\".\")[0];\n      if (!root) {\n        return undefined;\n      }\n      return { path: name, root };\n    }\n    if (this.target instanceof MemberExpression) {\n      return this.target.getIdentifierPath();\n    }\n    return undefined;\n  }\n\n  private resolveFromScope(\n    context: ExecutionContext,\n    path: { path: string; root: string }\n  ): { value: any; target?: any; optional?: boolean } | undefined {\n    if (!context.scope) {\n      return undefined;\n    }\n    if (path.path.startsWith(\"root.\") && context.rootScope) {\n      const localPath = path.path.slice(\"root.\".length);\n      const value = context.rootScope.getPath(`self.${localPath}`);\n      const targetPath = localPath.split(\".\").slice(0, -1).join(\".\");\n      const target = targetPath\n        ? context.rootScope.getPath(`self.${targetPath}`)\n        : context.rootScope;\n      return { value, target, optional: this.optional };\n    }\n    const value = context.scope.getPath(path.path);\n    const explicit = path.path.startsWith(\"parent.\")\n      || path.path.startsWith(\"root.\")\n      || path.path.startsWith(\"self.\");\n    if (!explicit && value === undefined && !context.scope.hasKey?.(path.root)) {\n      return undefined;\n    }\n    const targetPath = this.getTargetPath(path.path);\n    const target = targetPath ? context.scope.getPath(targetPath) : undefined;\n    return { value, target, optional: this.optional };\n  }\n\n  private resolveFromGlobals(\n    context: ExecutionContext,\n    path: { path: string; root: string }\n  ): { value: any; target?: any; optional?: boolean } | undefined {\n    const globals = context.globals ?? {};\n    if (!path.root || !(path.root in globals)) {\n      return undefined;\n    }\n    let value = globals[path.root];\n    let parent: any = undefined;\n    const parts = path.path.split(\".\");\n    for (let i = 1; i < parts.length; i += 1) {\n      parent = value;\n      const part = parts[i];\n      if (!part) {\n        return { value: undefined, target: parent, optional: this.optional };\n      }\n      value = value?.[part];\n    }\n    return { value, target: parent, optional: this.optional };\n  }\n\n  private getTargetPath(path: string): string | undefined {\n    const parts = path.split(\".\");\n    if (parts.length <= 1) {\n      return undefined;\n    }\n    return parts.slice(0, -1).join(\".\");\n  }\n}\n\nexport class CallExpression extends BaseNode {\n  constructor(public callee: ExpressionNode, public args: ExpressionNode[]) {\n    super(\"CallExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const resolved = this.resolveCallee(context);\n    return resolveMaybe(resolved, (resolvedCallee) => {\n      const fnValue = resolvedCallee?.fn ?? this.callee.evaluate(context);\n      return resolveMaybe(fnValue, (resolvedFn) => {\n        if (typeof resolvedFn !== \"function\") {\n          return undefined;\n        }\n        const values: any[] = [];\n        const evalArgs = (index: number): any => {\n          for (let i = index; i < this.args.length; i += 1) {\n            const arg = this.args[i]!;\n            const argValue = arg.evaluate(context);\n            return resolveMaybe(argValue, (resolvedArg) => {\n              values.push(resolvedArg);\n              return evalArgs(i + 1);\n            });\n          }\n          return resolvedFn.apply(resolvedCallee?.thisArg, values);\n        };\n        return evalArgs(0);\n      });\n    });\n  }\n\n  private resolveCallee(\n    context: ExecutionContext\n  ): { fn: any; thisArg?: any } | undefined | Promise<{ fn: any; thisArg?: any } | undefined> {\n    if (this.callee instanceof MemberExpression) {\n      const resolved = this.callee.resolve(context);\n      return resolveMaybe(resolved, (resolvedValue) => {\n        if (!resolvedValue) {\n          return undefined;\n        }\n        return { fn: resolvedValue.value, thisArg: resolvedValue.target };\n      });\n    }\n    if (!(this.callee instanceof IdentifierExpression)) {\n      return undefined;\n    }\n    const name = this.callee.name;\n    const globals = context.globals ?? {};\n    const parts = name.split(\".\");\n    const root = parts[0];\n    if (!root || !(root in globals)) {\n      if (parts.length > 1 && context.scope) {\n        const parentPath = parts.slice(0, -1).join(\".\");\n        const methodName = parts[parts.length - 1];\n        if (!methodName) {\n          return undefined;\n        }\n        const parentValue = context.scope.getPath(parentPath);\n        if (parentValue == null) {\n          return undefined;\n        }\n        return { fn: parentValue?.[methodName], thisArg: parentValue };\n      }\n      return undefined;\n    }\n    let value = globals[root];\n    let parent: any = undefined;\n    for (let i = 1; i < parts.length; i += 1) {\n      parent = value;\n      const part = parts[i];\n      if (!part) {\n        return undefined;\n      }\n      value = value?.[part];\n    }\n    return { fn: value, thisArg: parent };\n  }\n}\n\nexport type ArrayElement = ExpressionNode | SpreadElement;\n\nexport class ArrayExpression extends BaseNode {\n  constructor(public elements: ArrayElement[]) {\n    super(\"ArrayExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const values: any[] = [];\n    const pushElements = (value: any) => {\n      if (value == null) {\n        return;\n      }\n      const iterator = (value as any)[Symbol.iterator];\n      if (typeof iterator === \"function\") {\n        for (const entry of value as any) {\n          values.push(entry);\n        }\n      } else {\n        values.push(value);\n      }\n    };\n    const evalAt = (index: number): any => {\n      for (let i = index; i < this.elements.length; i += 1) {\n        const element = this.elements[i]!;\n        if (element instanceof SpreadElement) {\n          const spreadValue = element.value.evaluate(context);\n          return resolveMaybe(spreadValue, (resolvedSpread) => {\n            pushElements(resolvedSpread);\n            return evalAt(i + 1);\n          });\n        }\n        const value = element.evaluate(context);\n        return resolveMaybe(value, (resolvedValue) => {\n          values.push(resolvedValue);\n          return evalAt(i + 1);\n        });\n      }\n      return values;\n    };\n    return evalAt(0);\n  }\n}\n\nexport type ObjectEntry =\n  | { key: string; value: ExpressionNode; computed?: false }\n  | { keyExpr: ExpressionNode; value: ExpressionNode; computed: true }\n  | { spread: ExpressionNode };\n\nexport class ObjectExpression extends BaseNode {\n  constructor(public entries: ObjectEntry[]) {\n    super(\"ObjectExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const result: Record<string, any> = {};\n    const evalAt = (index: number): any => {\n      for (let i = index; i < this.entries.length; i += 1) {\n        const entry = this.entries[i]!;\n        if (\"spread\" in entry) {\n          const spreadValue = entry.spread.evaluate(context);\n          return resolveMaybe(spreadValue, (resolvedSpread) => {\n            if (resolvedSpread != null) {\n              Object.assign(result, resolvedSpread);\n            }\n            return evalAt(i + 1);\n          });\n        }\n        if (\"computed\" in entry && entry.computed) {\n          const keyValue = entry.keyExpr.evaluate(context);\n          return resolveMaybe(keyValue, (resolvedKey) => {\n            const entryValue = entry.value.evaluate(context);\n            return resolveMaybe(entryValue, (resolvedValue) => {\n              result[String(resolvedKey)] = resolvedValue;\n              return evalAt(i + 1);\n            });\n          });\n        }\n        const value = entry.value.evaluate(context);\n        return resolveMaybe(value, (resolvedValue) => {\n          result[entry.key] = resolvedValue;\n          return evalAt(i + 1);\n        });\n      }\n      return result;\n    };\n    return evalAt(0);\n  }\n}\n\nexport class IndexExpression extends BaseNode {\n  constructor(public target: ExpressionNode, public index: ExpressionNode) {\n    super(\"IndexExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const target = this.target.evaluate(context);\n    return resolveMaybe(target, (resolvedTarget) => {\n      if (resolvedTarget == null) {\n        return undefined;\n      }\n      const index = this.index.evaluate(context);\n      return resolveMaybe(index, (resolvedIndex) => {\n        if (resolvedIndex == null) {\n          return undefined;\n        }\n        const key = this.normalizeIndexKey(resolvedTarget, resolvedIndex);\n        return (resolvedTarget as any)[key as any];\n      });\n    });\n  }\n\n  private normalizeIndexKey(target: unknown, index: unknown): unknown {\n    if (Array.isArray(target) && typeof index === \"string\" && index.trim() !== \"\") {\n      const numeric = Number(index);\n      if (!Number.isNaN(numeric)) {\n        return numeric;\n      }\n    }\n    return index;\n  }\n}\n\nexport class DirectiveExpression extends BaseNode {\n  constructor(public kind: \"attr\" | \"style\", public name: string) {\n    super(\"Directive\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const element = context.element;\n    if (!element) {\n      return `${this.kind}:${this.name}`;\n    }\n    if (this.kind === \"attr\") {\n      if (this.name === \"value\") {\n        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n          return element.value;\n        }\n        if (element instanceof HTMLSelectElement) {\n          return element.value;\n        }\n      }\n      if (this.name === \"text\" && element instanceof HTMLElement) {\n        return element.innerText;\n      }\n      if (this.name === \"content\" && element instanceof HTMLElement) {\n        return element.textContent ?? \"\";\n      }\n      if (this.name === \"checked\" && element instanceof HTMLInputElement) {\n        return element.checked;\n      }\n      if (this.name === \"html\" && element instanceof HTMLElement) {\n        return element.innerHTML;\n      }\n      return element.getAttribute(this.name) ?? undefined;\n    }\n    if (this.kind === \"style\" && element instanceof HTMLElement) {\n      return element.style.getPropertyValue(this.name) ?? undefined;\n    }\n    return undefined;\n  }\n}\n\nexport class AwaitExpression extends BaseNode {\n  constructor(public argument: ExpressionNode) {\n    super(\"AwaitExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const value = this.argument.evaluate(context);\n    return Promise.resolve(value);\n  }\n}\n\nexport class QueryExpression extends BaseNode {\n  constructor(public direction: \"self\" | \"descendant\" | \"ancestor\", public selector: string) {\n    super(\"Query\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const selector = this.selector.trim();\n    if (!selector) {\n      return [];\n    }\n    if (this.direction === \"ancestor\") {\n      const results: Element[] = [];\n      let cursor = context.element?.parentElement;\n      while (cursor) {\n        if (cursor.matches(selector)) {\n          results.push(cursor);\n        }\n        cursor = cursor.parentElement;\n      }\n      return results;\n    }\n    const root = this.direction === \"descendant\"\n      ? context.element ?? (typeof document !== \"undefined\" ? document : undefined)\n      : (typeof document !== \"undefined\" ? document : undefined);\n    if (!root || !(\"querySelectorAll\" in root)) {\n      return [];\n    }\n    return Array.from((root as ParentNode).querySelectorAll(selector));\n  }\n}\n","import { Token, TokenType } from \"./token\";\n\nexport class TokenStream {\n  private index = 0;\n\n  constructor(private tokens: Token[]) {}\n\n  peek(offset = 0): Token | null {\n    return this.tokens[this.index + offset] ?? null;\n  }\n\n  next(): Token {\n    const token = this.tokens[this.index++];\n    if (!token) {\n      throw new Error(\"Unexpected end of input\");\n    }\n    return token;\n  }\n\n  eof(): boolean {\n    return this.index >= this.tokens.length;\n  }\n\n  match(type: TokenType): boolean {\n    if (this.peek()?.type === type) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n\n  expect(type: TokenType): Token {\n    const token = this.next();\n    if (token.type !== type) {\n      throw new Error(`Expected ${type} but got ${token.type}`);\n    }\n    return token;\n  }\n\n  skipWhitespace(): void {\n    while (this.peek()?.type === TokenType.Whitespace) {\n      this.next();\n    }\n  }\n\n  peekNonWhitespace(offset = 0): Token | null {\n    let count = 0;\n    for (let i = this.index; i < this.tokens.length; i++) {\n      const token = this.tokens[i];\n      if (!token) {\n        continue;\n      }\n      if (token.type === TokenType.Whitespace) {\n        continue;\n      }\n      if (count === offset) {\n        return token;\n      }\n      count += 1;\n    }\n    return null;\n  }\n\n  indexAfterDelimited(openType: TokenType, closeType: TokenType, offset = 0): number | null {\n    const first = this.peekNonWhitespace(offset);\n    if (!first || first.type !== openType) {\n      return null;\n    }\n    let index = offset + 1;\n    let depth = 1;\n    while (true) {\n      const token = this.peekNonWhitespace(index);\n      if (!token) {\n        return null;\n      }\n      if (token.type === openType) {\n        depth += 1;\n      } else if (token.type === closeType) {\n        depth -= 1;\n        if (depth === 0) {\n          return index + 1;\n        }\n      }\n      index += 1;\n    }\n  }\n}\n","import {\n  AssignmentNode,\n  ArrayExpression,\n  ArrayPattern,\n  AssertNode,\n  BreakNode,\n  CFSNode,\n  BehaviorNode,\n  BehaviorFlags,\n  BehaviorFlagArgs,\n  BinaryExpression,\n  BlockNode,\n  AssignmentTarget,\n  CallExpression,\n  DeclarationNode,\n  DeclarationTarget,\n  DeclarationFlags,\n  DeclarationFlagArgs,\n  MemberExpression,\n  DirectiveExpression,\n  FunctionDeclarationNode,\n  FunctionExpression,\n  FunctionParam,\n  IdentifierExpression,\n  LiteralExpression,\n  RestElement,\n  SpreadElement,\n  TemplateExpression,\n  ForNode,\n  ForEachNode,\n  IfNode,\n  TryNode,\n  WhileNode,\n  ObjectPattern,\n  ObjectExpression,\n  ObjectEntry,\n  OnBlockNode,\n  ProgramNode,\n  QueryExpression,\n  ReturnNode,\n  ContinueNode,\n  SelectorNode,\n  TernaryExpression,\n  UnaryExpression,\n  UseNode,\n  IndexExpression,\n  ExpressionNode,\n  AwaitExpression,\n  UseFlags,\n  UseFlagArgs\n} from \"../ast/nodes\";\nimport { Lexer } from \"./lexer\";\nimport { TokenStream } from \"./token-stream\";\nimport { Token, TokenType } from \"./token\";\n\nexport class Parser {\n  private stream: TokenStream;\n  private source: string;\n  private customFlags: Set<string>;\n  private behaviorFlags: Set<string>;\n  private allowImplicitSemicolon = false;\n  private awaitStack: boolean[] = [];\n  private functionDepth = 0;\n\n  constructor(input: string, options?: { customFlags?: Set<string>; behaviorFlags?: Set<string> }) {\n    this.source = input;\n    this.customFlags = options?.customFlags ?? new Set<string>([\"important\", \"debounce\"]);\n    this.behaviorFlags = options?.behaviorFlags ?? new Set<string>();\n    const lexer = new Lexer(input);\n    this.stream = new TokenStream(lexer.tokenize());\n  }\n\n  static parseInline(code: string): BlockNode {\n    const parser = new Parser(`{${code}}`);\n    return parser.parseInlineBlock();\n  }\n\n  parseProgram(): ProgramNode {\n    return this.wrapErrors(() => {\n      const behaviors: BehaviorNode[] = [];\n      const uses: UseNode[] = [];\n      this.stream.skipWhitespace();\n      while (!this.stream.eof()) {\n        const next = this.stream.peek();\n        if (!next) {\n          break;\n        }\n        if (next.type === TokenType.Use) {\n          uses.push(this.parseUseStatement());\n        } else {\n          behaviors.push(this.parseBehavior());\n        }\n        this.stream.skipWhitespace();\n      }\n      return new ProgramNode(behaviors, uses);\n    });\n  }\n\n  parseInlineBlock(): BlockNode {\n    return this.wrapErrors(() => {\n      this.stream.skipWhitespace();\n      this.allowImplicitSemicolon = true;\n      return this.parseBlock({ allowDeclarations: false });\n    });\n  }\n\n  private parseBehavior(): BehaviorNode {\n    return this.wrapErrors(() => {\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Behavior);\n      const selector = this.parseSelector();\n      const { flags, flagArgs } = this.parseBehaviorFlags();\n      const body = this.parseBlock({ allowDeclarations: true });\n      return new BehaviorNode(selector, body, flags, flagArgs);\n    });\n  }\n\n  private parseSelector(): SelectorNode {\n    let selectorText = \"\";\n    let sawNonWhitespace = false;\n\n    while (true) {\n      const token = this.stream.peek();\n      if (!token) {\n        break;\n      }\n\n      if (token.type === TokenType.LBrace) {\n        break;\n      }\n      if (token.type === TokenType.Bang) {\n        break;\n      }\n\n      if (token.type === TokenType.Whitespace) {\n        this.stream.next();\n        if (sawNonWhitespace && selectorText[selectorText.length - 1] !== \" \") {\n          selectorText += \" \";\n        }\n        continue;\n      }\n\n      sawNonWhitespace = true;\n      selectorText += this.stream.next().value;\n    }\n\n    if (!selectorText.trim()) {\n      throw new Error(\"Behavior selector is required\");\n    }\n\n    return new SelectorNode(selectorText.trim());\n  }\n\n  private parseBehaviorFlags(): { flags: BehaviorFlags; flagArgs: BehaviorFlagArgs } {\n    const result = this.parseFlags(this.behaviorFlags, \"behavior modifier\");\n    return { flags: result.flags, flagArgs: result.flagArgs };\n  }\n\n  private parseUseStatement(): UseNode {\n    return this.wrapErrors(() => {\n      this.stream.expect(TokenType.Use);\n      this.stream.skipWhitespace();\n      const name = this.parseIdentifierPath();\n      this.stream.skipWhitespace();\n      let alias = name;\n      const next = this.stream.peek();\n      if (next?.type === TokenType.Identifier && next.value === \"as\") {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        alias = this.stream.expect(TokenType.Identifier).value;\n      }\n      const { flags, flagArgs } = this.parseUseFlags();\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Semicolon);\n      return new UseNode(name, alias, flags, flagArgs);\n    });\n  }\n\n  private parseUseFlags(): { flags: UseFlags; flagArgs: UseFlagArgs } {\n    const flags: UseFlags = {};\n    const flagArgs: UseFlagArgs = {};\n\n    while (true) {\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type !== TokenType.Bang) {\n        break;\n      }\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier).value;\n      if (name !== \"wait\") {\n        throw new Error(`Unknown flag ${name}`);\n      }\n      flags.wait = true;\n      if (this.stream.peek()?.type === TokenType.LParen) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const timeoutToken = this.stream.expect(TokenType.Number);\n        const timeoutMs = Number(timeoutToken.value);\n        let intervalMs: number | undefined;\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.Comma) {\n          this.stream.next();\n          this.stream.skipWhitespace();\n          const intervalToken = this.stream.expect(TokenType.Number);\n          intervalMs = Number(intervalToken.value);\n          this.stream.skipWhitespace();\n        }\n        this.stream.expect(TokenType.RParen);\n        flagArgs.wait = { timeoutMs, ...(intervalMs !== undefined ? { intervalMs } : {}) };\n      }\n    }\n\n    return { flags, flagArgs };\n  }\n\n  private wrapErrors<T>(fn: () => T): T {\n    try {\n      return fn();\n    } catch (error) {\n      if (error instanceof Error && !/\\(line\\s+\\d+, column\\s+\\d+\\)/i.test(error.message)) {\n        throw new Error(this.formatError(error.message));\n      }\n      throw error;\n    }\n  }\n\n  private formatError(message: string): string {\n    const token = this.stream.peek() ?? this.stream.peekNonWhitespace(0);\n    if (!token) {\n      return `Parse error: ${message}`;\n    }\n    const line = token.start.line;\n    const column = token.start.column;\n    const snippet = this.getLineSnippet(line, column);\n    return `Parse error (line ${line}, column ${column}): ${message}\\n${snippet}`;\n  }\n\n  private getLineSnippet(line: number, column: number): string {\n    const lines = this.source.split(/\\r?\\n/);\n    const content = lines[line - 1] ?? \"\";\n    const caret = `${\" \".repeat(Math.max(column - 1, 0))}^`;\n    return `${content}\\n${caret}`;\n  }\n\n  private parseBlock(options?: { allowDeclarations?: boolean; allowReturn?: boolean }): BlockNode {\n    const allowDeclarations = options?.allowDeclarations ?? false;\n    const allowReturn = options?.allowReturn ?? this.functionDepth > 0;\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LBrace);\n    const statements = [];\n    let declarationsOpen = allowDeclarations;\n    let sawConstruct = false;\n    let sawFunctionOrOn = false;\n    let sawNestedBehavior = false;\n\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated block\");\n      }\n      if (next.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n\n      if (allowDeclarations && next.type === TokenType.Behavior) {\n        sawNestedBehavior = true;\n      }\n\n      if (allowDeclarations && sawNestedBehavior && next.type !== TokenType.Behavior) {\n        throw new Error(\"Nested behaviors must appear after construct, function, and on blocks\");\n      }\n\n      const isFunctionDeclaration = allowDeclarations && this.isFunctionDeclarationStart();\n      if (isFunctionDeclaration) {\n        if (!sawConstruct) {\n          sawFunctionOrOn = true;\n        }\n        statements.push(this.parseFunctionDeclaration());\n        continue;\n      }\n      const isFunctionExpressionAssignment = allowDeclarations && this.isFunctionExpressionAssignmentStart();\n      if (isFunctionExpressionAssignment) {\n        if (!declarationsOpen) {\n          throw new Error(\"Declarations must appear before blocks\");\n        }\n        statements.push(this.parseAssignment());\n        continue;\n      }\n      const isDeclaration = this.isDeclarationStart();\n      if (isDeclaration) {\n        if (!allowDeclarations) {\n          throw new Error(\"Declarations are only allowed at the behavior root\");\n        }\n        if (!declarationsOpen) {\n          throw new Error(\"Declarations must appear before blocks\");\n        }\n        statements.push(this.parseDeclaration());\n      } else {\n        if (declarationsOpen) {\n          declarationsOpen = false;\n        }\n        if (allowDeclarations && next.type === TokenType.On && !sawConstruct) {\n          sawFunctionOrOn = true;\n        }\n        if (allowDeclarations && next.type === TokenType.Construct) {\n          if (sawFunctionOrOn) {\n            throw new Error(\"Construct blocks must appear before functions and on blocks\");\n          }\n          sawConstruct = true;\n        }\n        statements.push(this.parseStatement({ allowReturn }));\n      }\n    }\n\n    return new BlockNode(statements);\n  }\n\n  private parseStatement(options?: { allowBlocks?: boolean; allowReturn?: boolean }) {\n    this.stream.skipWhitespace();\n    const next = this.stream.peek();\n    if (!next) {\n      throw new Error(\"Unexpected end of input\");\n    }\n\n    const allowBlocks = options?.allowBlocks ?? true;\n    const allowReturn = options?.allowReturn ?? false;\n\n    if (next.type === TokenType.Return) {\n      if (!allowReturn) {\n        throw new Error(\"Return is only allowed inside functions\");\n      }\n      return this.parseReturnStatement();\n    }\n\n    if (next.type === TokenType.Assert) {\n      return this.parseAssertStatement();\n    }\n\n    if (next.type === TokenType.Break) {\n      return this.parseBreakStatement();\n    }\n\n    if (next.type === TokenType.Continue) {\n      return this.parseContinueStatement();\n    }\n\n    if (allowBlocks && next.type === TokenType.On) {\n      return this.parseOnBlock();\n    }\n\n    if (allowBlocks && next.type === TokenType.If) {\n      return this.parseIfBlock();\n    }\n\n    if (allowBlocks && next.type === TokenType.For) {\n      return this.parseForBlock();\n    }\n\n    if (allowBlocks && next.type === TokenType.While) {\n      return this.parseWhileBlock();\n    }\n\n    if (allowBlocks && next.type === TokenType.Try) {\n      return this.parseTryBlock();\n    }\n\n    if (allowBlocks && next.type === TokenType.Construct) {\n      return this.parseConstructBlock();\n    }\n\n    if (allowBlocks && next.type === TokenType.Destruct) {\n      return this.parseDestructBlock();\n    }\n\n    if (allowBlocks && next.type === TokenType.Behavior) {\n      return this.parseBehavior();\n    }\n\n    if (this.isAwaitAllowed() && next.type === TokenType.Identifier && next.value === \"await\") {\n      return this.parseExpressionStatement();\n    }\n\n    if (this.isAssignmentStart()) {\n      return this.parseAssignment();\n    }\n\n    if (this.isExpressionStatementStart()) {\n      return this.parseExpressionStatement();\n    }\n\n    throw new Error(`Unexpected token ${next.type}`);\n  }\n\n  private parseOnBlock(): OnBlockNode {\n    this.stream.expect(TokenType.On);\n    this.stream.skipWhitespace();\n    const event = this.parseIdentifierPath();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    const args: string[] = [];\n\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated on() arguments\");\n      }\n      if (next.type === TokenType.RParen) {\n        this.stream.next();\n        break;\n      }\n      if (next.type === TokenType.Identifier) {\n        args.push(this.stream.next().value);\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.Comma) {\n          this.stream.next();\n        }\n        continue;\n      }\n      throw new Error(`Unexpected token in on() args: ${next.type}`);\n    }\n\n    const { flags, flagArgs } = this.parseFlags(this.customFlags, \"flag\");\n    const body = this.parseBlock({ allowDeclarations: false });\n    return new OnBlockNode(event, args, body, flags, flagArgs);\n  }\n\n  private parseAssignment(): AssignmentNode {\n    const target = this.parseAssignmentTarget();\n    this.stream.skipWhitespace();\n    const operator = this.parseAssignmentOperator();\n    this.stream.skipWhitespace();\n    const value = this.parseExpression();\n    this.consumeStatementTerminator();\n    return new AssignmentNode(target, value, operator);\n  }\n\n  private parseExpression(): ExpressionNode {\n    return this.parsePipeExpression();\n  }\n\n  private parsePipeExpression(): ExpressionNode {\n    let expr = this.parseTernaryExpression();\n    while (true) {\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type !== TokenType.Pipe) {\n        break;\n      }\n      this.stream.next();\n      this.stream.skipWhitespace();\n      let awaitStage = false;\n      const next = this.stream.peek();\n      if (this.isAwaitAllowed() && next?.type === TokenType.Identifier && next.value === \"await\") {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        awaitStage = true;\n      }\n      const stage = this.parseCallExpression();\n      const call = this.buildPipeCall(expr, stage);\n      expr = awaitStage ? new AwaitExpression(call) : call;\n    }\n    return expr;\n  }\n\n  private buildPipeCall(input: ExpressionNode, stage: ExpressionNode): ExpressionNode {\n    if (stage instanceof CallExpression) {\n      return new CallExpression(stage.callee, [input, ...stage.args]);\n    }\n    if (stage instanceof IdentifierExpression || stage instanceof MemberExpression) {\n      return new CallExpression(stage, [input]);\n    }\n    throw new Error(\"Pipe operator requires a function call\");\n  }\n\n  private parseTernaryExpression(): ExpressionNode {\n    let test = this.parseNullishExpression();\n    this.stream.skipWhitespace();\n    if (this.stream.peek()?.type !== TokenType.Question) {\n      return test;\n    }\n    this.stream.next();\n    this.stream.skipWhitespace();\n    const consequent = this.parseExpression();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Colon);\n    this.stream.skipWhitespace();\n    const alternate = this.parseExpression();\n    return new TernaryExpression(test, consequent, alternate);\n  }\n\n  private parseNullishExpression(): ExpressionNode {\n    let expr = this.parseLogicalOrExpression();\n    while (true) {\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type !== TokenType.NullishCoalesce) {\n        break;\n      }\n      this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseLogicalOrExpression();\n      expr = new BinaryExpression(\"??\", expr, right);\n    }\n    return expr;\n  }\n\n  private parseLogicalOrExpression(): ExpressionNode {\n    let left = this.parseLogicalAndExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next || next.type !== TokenType.Or) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseLogicalAndExpression();\n      this.stream.skipWhitespace();\n      left = new BinaryExpression(\"||\", left, right);\n    }\n    return left;\n  }\n\n  private parseLogicalAndExpression(): ExpressionNode {\n    let left = this.parseEqualityExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next || next.type !== TokenType.And) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseEqualityExpression();\n      this.stream.skipWhitespace();\n      left = new BinaryExpression(\"&&\", left, right);\n    }\n    return left;\n  }\n\n  private parseEqualityExpression(): ExpressionNode {\n    let left = this.parseComparisonExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next || (next.type !== TokenType.DoubleEquals &&\n          next.type !== TokenType.NotEquals &&\n          next.type !== TokenType.TripleEquals &&\n          next.type !== TokenType.StrictNotEquals)) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      const op = this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseComparisonExpression();\n      this.stream.skipWhitespace();\n      let operator = \"==\";\n      if (op.type === TokenType.NotEquals) {\n        operator = \"!=\";\n      } else if (op.type === TokenType.TripleEquals) {\n        operator = \"===\";\n      } else if (op.type === TokenType.StrictNotEquals) {\n        operator = \"!==\";\n      }\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n\n  private parseComparisonExpression(): ExpressionNode {\n    let left = this.parseAdditiveExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next) {\n        break;\n      }\n      if (next.type !== TokenType.Less &&\n          next.type !== TokenType.Greater &&\n          next.type !== TokenType.LessEqual &&\n          next.type !== TokenType.GreaterEqual) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      const op = this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseAdditiveExpression();\n      this.stream.skipWhitespace();\n      let operator = \"<\";\n      if (op.type === TokenType.Greater) {\n        operator = \">\";\n      } else if (op.type === TokenType.LessEqual) {\n        operator = \"<=\";\n      } else if (op.type === TokenType.GreaterEqual) {\n        operator = \">=\";\n      }\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n\n  private parseMultiplicativeExpression(): ExpressionNode {\n    let left = this.parseUnaryExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next) {\n        break;\n      }\n      if (next.type !== TokenType.Star &&\n          next.type !== TokenType.Slash &&\n          next.type !== TokenType.Percent) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      const op = this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseUnaryExpression();\n      this.stream.skipWhitespace();\n      let operator = \"*\";\n      if (op.type === TokenType.Slash) {\n        operator = \"/\";\n      } else if (op.type === TokenType.Percent) {\n        operator = \"%\";\n      }\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n\n  private parseAdditiveExpression(): ExpressionNode {\n    let left = this.parseMultiplicativeExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next || (next.type !== TokenType.Plus && next.type !== TokenType.Minus)) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      const op = this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseMultiplicativeExpression();\n      this.stream.skipWhitespace();\n      left = new BinaryExpression(op.type === TokenType.Plus ? \"+\" : \"-\", left, right);\n    }\n    return left;\n  }\n\n  private parseUnaryExpression(): ExpressionNode {\n    this.stream.skipWhitespace();\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected expression\");\n    }\n    if (token.type === TokenType.PlusPlus || token.type === TokenType.MinusMinus) {\n      this.stream.next();\n      const argument = this.parseUnaryExpression();\n      return this.createIncrementNode(token, argument, true);\n    }\n    if (token.type === TokenType.Bang) {\n      this.stream.next();\n      const argument = this.parseUnaryExpression();\n      return new UnaryExpression(\"!\", argument);\n    }\n    if (token.type === TokenType.Minus) {\n      this.stream.next();\n      const argument = this.parseUnaryExpression();\n      return new UnaryExpression(\"-\", argument);\n    }\n    if (this.isAwaitAllowed() && token.type === TokenType.Identifier && token.value === \"await\") {\n      this.stream.next();\n      const argument = this.parseUnaryExpression();\n      return new AwaitExpression(argument);\n    }\n    return this.parsePostfixExpression();\n  }\n\n  private parsePostfixExpression(): ExpressionNode {\n    let expr = this.parseCallExpression();\n    while (true) {\n      this.stream.skipWhitespace();\n      const token = this.stream.peek();\n      if (!token) {\n        break;\n      }\n      if (token.type === TokenType.PlusPlus || token.type === TokenType.MinusMinus) {\n        this.stream.next();\n        expr = this.createIncrementNode(token, expr, false);\n        continue;\n      }\n      break;\n    }\n    return expr;\n  }\n\n  private createIncrementNode(token: Token, argument: ExpressionNode, prefix: boolean): ExpressionNode {\n    if (\n      !(argument instanceof IdentifierExpression)\n      && !(argument instanceof MemberExpression)\n      && !(argument instanceof IndexExpression)\n      && !(argument instanceof DirectiveExpression)\n    ) {\n      throw new Error(\"Increment/decrement requires a mutable target\");\n    }\n    const operator = token.type === TokenType.PlusPlus ? \"++\" : \"--\";\n    return new AssignmentNode(argument, new LiteralExpression(1), operator, prefix) as ExpressionNode;\n  }\n\n  private parseCallExpression(): ExpressionNode {\n    let expr = this.parsePrimaryExpression();\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        break;\n      }\n      if (next.type === TokenType.LParen) {\n        this.stream.next();\n        const args: ExpressionNode[] = [];\n        while (true) {\n          this.stream.skipWhitespace();\n          const argToken = this.stream.peek();\n          if (!argToken) {\n            throw new Error(\"Unterminated call expression\");\n          }\n          if (argToken.type === TokenType.RParen) {\n            this.stream.next();\n            break;\n          }\n          args.push(this.parseExpression());\n          this.stream.skipWhitespace();\n          if (this.stream.peek()?.type === TokenType.Comma) {\n            this.stream.next();\n            continue;\n          }\n          if (this.stream.peek()?.type === TokenType.RParen) {\n            this.stream.next();\n            break;\n          }\n          throw new Error(\"Expected ',' or ')' in call arguments\");\n        }\n        expr = new CallExpression(expr, args);\n        continue;\n      }\n      if (next.type === TokenType.OptionalChain) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const chained = this.stream.peek();\n        if (!chained) {\n          throw new Error(\"Expected property or call after ?.\");\n        }\n        if (chained.type === TokenType.LParen) {\n          this.stream.next();\n          const args: ExpressionNode[] = [];\n          while (true) {\n            this.stream.skipWhitespace();\n            const argToken = this.stream.peek();\n            if (!argToken) {\n              throw new Error(\"Unterminated call expression\");\n            }\n            if (argToken.type === TokenType.RParen) {\n              this.stream.next();\n              break;\n            }\n            args.push(this.parseExpression());\n            this.stream.skipWhitespace();\n            if (this.stream.peek()?.type === TokenType.Comma) {\n              this.stream.next();\n              continue;\n            }\n            if (this.stream.peek()?.type === TokenType.RParen) {\n              this.stream.next();\n              break;\n            }\n            throw new Error(\"Expected ',' or ')' in call arguments\");\n          }\n          expr = new CallExpression(expr, args);\n          continue;\n        }\n        if (chained.type === TokenType.Identifier) {\n          const name = this.stream.next();\n          expr = new MemberExpression(expr, name.value, true);\n          continue;\n        }\n        throw new Error(\"Expected property or call after ?.\");\n      }\n      if (next.type === TokenType.Dot) {\n        this.stream.next();\n        const name = this.stream.expect(TokenType.Identifier);\n        expr = new MemberExpression(expr, name.value);\n        continue;\n      }\n      if (next.type === TokenType.LBracket) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const index = this.parseExpression();\n        this.stream.skipWhitespace();\n        this.stream.expect(TokenType.RBracket);\n        expr = new IndexExpression(expr, index);\n        continue;\n      }\n      break;\n    }\n    return expr;\n  }\n\n  private parsePrimaryExpression(): ExpressionNode {\n    this.stream.skipWhitespace();\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected expression\");\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier);\n      return new DirectiveExpression(kind, name.value);\n    }\n\n    if (token.type === TokenType.Question) {\n      return this.parseQueryExpression();\n    }\n\n    if (token.type === TokenType.LBracket) {\n      return this.parseArrayExpression();\n    }\n\n    if (token.type === TokenType.LBrace) {\n      return this.parseObjectExpression();\n    }\n\n    if (token.type === TokenType.LParen) {\n      if (this.isArrowFunctionStart()) {\n        return this.parseArrowFunctionExpression();\n      }\n      this.stream.next();\n      const value = this.parseExpression();\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.RParen);\n      return value;\n    }\n\n    if (token.type === TokenType.Identifier) {\n      if (this.isAsyncToken(token) && this.isAsyncArrowFunctionStart()) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        return this.parseArrowFunctionExpression(true);\n      }\n      return new IdentifierExpression(this.stream.next().value);\n    }\n\n    if (token.type === TokenType.Boolean) {\n      return new LiteralExpression(this.stream.next().value === \"true\");\n    }\n\n    if (token.type === TokenType.Null) {\n      this.stream.next();\n      return new LiteralExpression(null);\n    }\n\n    if (token.type === TokenType.Number) {\n      return new LiteralExpression(Number(this.stream.next().value));\n    }\n\n    if (token.type === TokenType.String) {\n      return new LiteralExpression(this.stream.next().value);\n    }\n\n    if (token.type === TokenType.Template) {\n      return this.parseTemplateExpression();\n    }\n\n    throw new Error(`Unsupported expression token ${token.type}`);\n  }\n\n  private parseArrayExpression(): ExpressionNode {\n    this.stream.expect(TokenType.LBracket);\n    const elements: (ExpressionNode | SpreadElement)[] = [];\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated array literal\");\n      }\n      if (next.type === TokenType.RBracket) {\n        this.stream.next();\n        break;\n      }\n      if (next.type === TokenType.Ellipsis) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const value = this.parseExpression();\n        elements.push(new SpreadElement(value));\n      } else {\n        elements.push(this.parseExpression());\n      }\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.Comma) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.RBracket) {\n          this.stream.next();\n          break;\n        }\n        continue;\n      }\n      if (this.stream.peek()?.type === TokenType.RBracket) {\n        this.stream.next();\n        break;\n      }\n      throw new Error(\"Expected ',' or ']' in array literal\");\n    }\n    return new ArrayExpression(elements);\n  }\n\n  private parseTemplateExpression(): ExpressionNode {\n    const parts: ExpressionNode[] = [];\n    while (true) {\n      const token = this.stream.peek();\n      if (!token) {\n        throw new Error(\"Unterminated template literal\");\n      }\n      if (token.type !== TokenType.Template) {\n        throw new Error(\"Expected template literal\");\n      }\n      const literal = this.stream.next().value;\n      if (literal) {\n        parts.push(new LiteralExpression(literal));\n      }\n      const next = this.stream.peek();\n      if (!next || next.type !== TokenType.Dollar) {\n        break;\n      }\n      this.stream.next();\n      this.stream.expect(TokenType.LBrace);\n      this.stream.skipWhitespace();\n      const expr = this.parseExpression();\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.RBrace);\n      parts.push(expr);\n    }\n    return new TemplateExpression(parts);\n  }\n\n  private parseObjectExpression(): ExpressionNode {\n    this.stream.expect(TokenType.LBrace);\n    const entries: ObjectEntry[] = [];\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated object literal\");\n      }\n      if (next.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n\n      let value: ExpressionNode | undefined;\n      let entry: ObjectEntry | undefined;\n      if (next.type === TokenType.Ellipsis) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        entry = { spread: this.parseExpression() };\n      } else if (next.type === TokenType.LBracket) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const keyExpr = this.parseExpression();\n        this.stream.skipWhitespace();\n        this.stream.expect(TokenType.RBracket);\n        this.stream.skipWhitespace();\n        this.stream.expect(TokenType.Colon);\n        this.stream.skipWhitespace();\n        value = this.parseExpression();\n        entry = { keyExpr, value, computed: true };\n      } else if (next.type === TokenType.Identifier) {\n        const name = this.stream.next().value;\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.Colon) {\n          this.stream.next();\n          this.stream.skipWhitespace();\n          value = this.parseExpression();\n        } else {\n          value = new IdentifierExpression(name);\n        }\n        entry = { key: name, value };\n      } else if (next.type === TokenType.String) {\n        const key = this.stream.next().value;\n        this.stream.skipWhitespace();\n        this.stream.expect(TokenType.Colon);\n        this.stream.skipWhitespace();\n        value = this.parseExpression();\n        entry = { key, value };\n      } else {\n        throw new Error(`Unexpected token in object literal: ${next.type}`);\n      }\n\n      if (!entry) {\n        throw new Error(\"Invalid object literal entry\");\n      }\n      entries.push(entry);\n\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.Comma) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.RBrace) {\n          this.stream.next();\n          break;\n        }\n        continue;\n      }\n      if (this.stream.peek()?.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n      throw new Error(\"Expected ',' or '}' in object literal\");\n    }\n    return new ObjectExpression(entries);\n  }\n\n  private consumeStatementTerminator(): void {\n    this.stream.skipWhitespace();\n    const next = this.stream.peek();\n    if (next?.type === TokenType.Semicolon) {\n      this.stream.next();\n      return;\n    }\n    if (this.allowImplicitSemicolon && next?.type === TokenType.RBrace) {\n      return;\n    }\n    this.stream.expect(TokenType.Semicolon);\n  }\n\n  private parseFunctionBlockWithAwait(allowAwait: boolean): BlockNode {\n    this.stream.expect(TokenType.LBrace);\n    const statements = [];\n    this.awaitStack.push(allowAwait);\n    this.functionDepth += 1;\n    try {\n      while (true) {\n        this.stream.skipWhitespace();\n        const next = this.stream.peek();\n        if (!next) {\n          throw new Error(\"Unterminated function block\");\n        }\n        if (next.type === TokenType.RBrace) {\n          this.stream.next();\n          break;\n        }\n        statements.push(this.parseStatement({ allowBlocks: true, allowReturn: true }));\n      }\n    } finally {\n      this.functionDepth -= 1;\n      this.awaitStack.pop();\n    }\n    return new BlockNode(statements);\n  }\n\n  private isAsyncToken(token?: Token | null): boolean {\n    return token?.type === TokenType.Identifier && token.value === \"async\";\n  }\n\n  private isAwaitAllowed(): boolean {\n    if (this.awaitStack.length === 0) {\n      return false;\n    }\n    return this.awaitStack[this.awaitStack.length - 1] === true;\n  }\n\n  private parseArrowExpressionBody(allowAwait: boolean): BlockNode {\n    this.awaitStack.push(allowAwait);\n    try {\n      const expression = this.parseExpression();\n      return new BlockNode([new ReturnNode(expression)]);\n    } finally {\n      this.awaitStack.pop();\n    }\n  }\n\n  private parseAssignmentTarget(): AssignmentTarget {\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected assignment target\");\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier);\n      return new DirectiveExpression(kind, name.value);\n    }\n\n    if (token.type === TokenType.LBracket) {\n      return this.parseArrayPattern();\n    }\n\n    if (token.type === TokenType.LBrace) {\n      return this.parseObjectPattern();\n    }\n\n    if (token.type === TokenType.Identifier) {\n      const expr = this.parseCallExpression();\n      if (expr instanceof CallExpression) {\n        throw new Error(\"Invalid assignment target CallExpression\");\n      }\n      if (expr instanceof IdentifierExpression || expr instanceof MemberExpression || expr instanceof IndexExpression) {\n        return expr;\n      }\n      throw new Error(\"Invalid assignment target\");\n    }\n\n    throw new Error(`Invalid assignment target ${token.type}`);\n  }\n\n  private parseArrayPattern(): ArrayPattern {\n    this.stream.expect(TokenType.LBracket);\n    const elements: (IdentifierExpression | ArrayPattern | ObjectPattern | RestElement | null)[] = [];\n    let sawRest = false;\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated array pattern\");\n      }\n      if (next.type === TokenType.RBracket) {\n        this.stream.next();\n        break;\n      }\n      if (next.type === TokenType.Comma) {\n        this.stream.next();\n        elements.push(null);\n        continue;\n      }\n      if (next.type === TokenType.Ellipsis) {\n        if (sawRest) {\n          throw new Error(\"Array patterns can only include one rest element\");\n        }\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const name = this.stream.expect(TokenType.Identifier);\n        elements.push(new RestElement(new IdentifierExpression(name.value)));\n        sawRest = true;\n      } else if (next.type === TokenType.LBracket) {\n        elements.push(this.parseArrayPattern());\n      } else if (next.type === TokenType.LBrace) {\n        elements.push(this.parseObjectPattern());\n      } else if (next.type === TokenType.Identifier) {\n        elements.push(new IdentifierExpression(this.parseIdentifierPath()));\n      } else {\n        throw new Error(`Unexpected token in array pattern: ${next.type}`);\n      }\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.Comma) {\n        this.stream.next();\n        continue;\n      }\n      if (this.stream.peek()?.type === TokenType.RBracket) {\n        this.stream.next();\n        break;\n      }\n      throw new Error(\"Expected ',' or ']' in array pattern\");\n    }\n    if (sawRest) {\n      const last = elements[elements.length - 1];\n      if (!(last instanceof RestElement)) {\n        throw new Error(\"Rest element must be last in array pattern\");\n      }\n    }\n    return new ArrayPattern(elements);\n  }\n\n  private parseObjectPattern(): ObjectPattern {\n    this.stream.expect(TokenType.LBrace);\n    const entries: { key: string; target: IdentifierExpression | ArrayPattern | ObjectPattern }[] = [];\n    let rest: IdentifierExpression | undefined;\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated object pattern\");\n      }\n      if (next.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n      if (next.type === TokenType.Ellipsis) {\n        if (rest) {\n          throw new Error(\"Object patterns can only include one rest element\");\n        }\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const name = this.stream.expect(TokenType.Identifier);\n        rest = new IdentifierExpression(name.value);\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.Comma) {\n          this.stream.next();\n          this.stream.skipWhitespace();\n        }\n        if (this.stream.peek()?.type !== TokenType.RBrace) {\n          throw new Error(\"Rest element must be last in object pattern\");\n        }\n        this.stream.next();\n        break;\n      } else if (next.type === TokenType.Identifier || next.type === TokenType.String) {\n        const keyToken = this.stream.next();\n        const key = keyToken.value;\n        this.stream.skipWhitespace();\n        let target: IdentifierExpression | ArrayPattern | ObjectPattern;\n        if (this.stream.peek()?.type === TokenType.Colon) {\n          this.stream.next();\n          this.stream.skipWhitespace();\n          const valueToken = this.stream.peek();\n          if (!valueToken) {\n            throw new Error(\"Expected object pattern target\");\n          }\n          if (valueToken.type === TokenType.LBracket) {\n            target = this.parseArrayPattern();\n          } else if (valueToken.type === TokenType.LBrace) {\n            target = this.parseObjectPattern();\n          } else if (valueToken.type === TokenType.Identifier) {\n            target = new IdentifierExpression(this.parseIdentifierPath());\n          } else {\n            throw new Error(`Unexpected token in object pattern: ${valueToken.type}`);\n          }\n        } else {\n          target = new IdentifierExpression(key);\n        }\n        entries.push({ key, target });\n      } else {\n        throw new Error(`Unexpected token in object pattern: ${next.type}`);\n      }\n\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.Comma) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.RBrace) {\n          this.stream.next();\n          break;\n        }\n        continue;\n      }\n      if (this.stream.peek()?.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n      throw new Error(\"Expected ',' or '}' in object pattern\");\n    }\n    const patternEntries = rest ? [...entries, { rest }] : entries;\n    if (rest && entries.length === 0) {\n      return new ObjectPattern([{ rest }]);\n    }\n    return new ObjectPattern(patternEntries);\n  }\n\n  private parseDeclaration(): DeclarationNode {\n    const target = this.parseDeclarationTarget();\n    this.stream.skipWhitespace();\n    const operator = this.parseDeclarationOperator();\n    this.stream.skipWhitespace();\n    const value = this.parseExpression();\n    const { flags, flagArgs } = this.parseFlags(this.customFlags, \"flag\");\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Semicolon);\n    return new DeclarationNode(target, operator, value, flags, flagArgs);\n  }\n\n  private parseDeclarationTarget(): DeclarationTarget {\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected declaration target\");\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier);\n      return new DirectiveExpression(kind, name.value);\n    }\n\n    if (token.type === TokenType.Identifier) {\n      return new IdentifierExpression(this.stream.next().value);\n    }\n\n    throw new Error(`Invalid declaration target ${token.type}`);\n  }\n\n  private parseDeclarationOperator(): \":\" | \":=\" | \":<\" | \":>\" {\n    this.stream.expect(TokenType.Colon);\n    const next = this.stream.peek();\n    if (!next) {\n      return \":\";\n    }\n    if (next.type === TokenType.Equals) {\n      this.stream.next();\n      return \":=\";\n    }\n    if (next.type === TokenType.Less) {\n      this.stream.next();\n      return \":<\";\n    }\n    if (next.type === TokenType.Greater) {\n      this.stream.next();\n      return \":>\";\n    }\n    return \":\";\n  }\n\n  private parseFlags(\n    allowed: Set<string> | null,\n    errorLabel: string\n  ): { flags: DeclarationFlags; flagArgs: DeclarationFlagArgs } {\n    const flags: DeclarationFlags = {};\n    const flagArgs: DeclarationFlagArgs = {};\n\n    while (true) {\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type !== TokenType.Bang) {\n        break;\n      }\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier).value;\n      if (allowed && !allowed.has(name)) {\n        throw new Error(`Unknown ${errorLabel} ${name}`);\n      }\n      (flags as Record<string, boolean>)[name] = true;\n      const customArg = this.parseCustomFlagArg();\n      if (customArg !== undefined) {\n        (flagArgs as Record<string, any>)[name] = customArg;\n      }\n    }\n\n    return { flags, flagArgs };\n  }\n\n  private parseCustomFlagArg(): any {\n    if (this.stream.peek()?.type !== TokenType.LParen) {\n      return undefined;\n    }\n    this.stream.next();\n    this.stream.skipWhitespace();\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Unterminated flag arguments\");\n    }\n    const value = this.parseCustomFlagLiteral();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.RParen);\n    return value;\n  }\n\n  private parseCustomFlagLiteral(): any {\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Unterminated flag arguments\");\n    }\n    if (token.type === TokenType.Number) {\n      return Number(this.stream.next().value);\n    }\n    if (token.type === TokenType.String) {\n      return this.stream.next().value;\n    }\n    if (token.type === TokenType.Boolean) {\n      return this.stream.next().value === \"true\";\n    }\n    if (token.type === TokenType.Identifier) {\n      return this.stream.next().value;\n    }\n    if (token.type === TokenType.LBracket) {\n      return this.parseCustomFlagArray();\n    }\n    if (token.type === TokenType.LBrace) {\n      return this.parseCustomFlagObject();\n    }\n    throw new Error(`Unsupported flag argument ${token.type}`);\n  }\n\n  private parseCustomFlagArray(): any[] {\n    this.stream.expect(TokenType.LBracket);\n    const items: any[] = [];\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated flag array\");\n      }\n      if (next.type === TokenType.RBracket) {\n        this.stream.next();\n        break;\n      }\n      items.push(this.parseCustomFlagLiteral());\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.Comma) {\n        this.stream.next();\n      }\n    }\n    return items;\n  }\n\n  private parseCustomFlagObject(): Record<string, any> {\n    this.stream.expect(TokenType.LBrace);\n    const obj: Record<string, any> = {};\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated flag object\");\n      }\n      if (next.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n      let key: string;\n      if (next.type === TokenType.Identifier || next.type === TokenType.String) {\n        key = this.stream.next().value;\n      } else {\n        throw new Error(`Unsupported flag object key ${next.type}`);\n      }\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Colon);\n      this.stream.skipWhitespace();\n      obj[key] = this.parseCustomFlagLiteral();\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.Comma) {\n        this.stream.next();\n      }\n    }\n    return obj;\n  }\n\n  private isDeclarationStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first) {\n      return false;\n    }\n\n    if (first.type === TokenType.Identifier) {\n      const second = this.stream.peekNonWhitespace(1);\n      return second?.type === TokenType.Colon;\n    }\n\n    if (first.type === TokenType.At || first.type === TokenType.Dollar) {\n      const second = this.stream.peekNonWhitespace(1);\n      const third = this.stream.peekNonWhitespace(2);\n      return second?.type === TokenType.Identifier && third?.type === TokenType.Colon;\n    }\n\n    return false;\n  }\n\n  private isAssignmentStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first) {\n      return false;\n    }\n\n    if (first.type === TokenType.Identifier) {\n      let index = 1;\n      while (true) {\n        const token = this.stream.peekNonWhitespace(index);\n        if (!token) {\n          return false;\n        }\n        if (\n          token.type === TokenType.Dot &&\n          this.stream.peekNonWhitespace(index + 1)?.type === TokenType.Identifier\n        ) {\n          index += 2;\n          continue;\n        }\n        if (token.type === TokenType.LBracket) {\n          const indexAfter = this.stream.indexAfterDelimited(TokenType.LBracket, TokenType.RBracket, index);\n          if (indexAfter === null) {\n            return false;\n          }\n          index = indexAfter;\n          continue;\n        }\n        break;\n      }\n      return this.isAssignmentOperatorStart(index);\n    }\n\n    if (first.type === TokenType.At || first.type === TokenType.Dollar) {\n      const second = this.stream.peekNonWhitespace(1);\n      return second?.type === TokenType.Identifier && this.isAssignmentOperatorStart(2);\n    }\n\n    if (first.type === TokenType.LBrace || first.type === TokenType.LBracket) {\n      const stack: TokenType[] = [];\n      let index = 0;\n      while (true) {\n        const token = this.stream.peekNonWhitespace(index);\n        if (!token) {\n          return false;\n        }\n        if (token.type === TokenType.LBrace || token.type === TokenType.LBracket) {\n          stack.push(token.type);\n        } else if (token.type === TokenType.RBrace || token.type === TokenType.RBracket) {\n          stack.pop();\n          if (stack.length === 0) {\n            return this.isAssignmentOperatorStart(index + 1);\n          }\n        }\n        index += 1;\n      }\n    }\n\n    return false;\n  }\n\n  private isAssignmentOperatorStart(index: number): boolean {\n    const token = this.stream.peekNonWhitespace(index);\n    if (!token) {\n      return false;\n    }\n    if (token.type === TokenType.Equals) {\n      return true;\n    }\n    if (token.type === TokenType.Tilde) {\n      const next = this.stream.peekNonWhitespace(index + 1);\n      return next?.type === TokenType.Equals;\n    }\n    if (token.type === TokenType.Plus ||\n        token.type === TokenType.Minus ||\n        token.type === TokenType.Star ||\n        token.type === TokenType.Slash) {\n      const next = this.stream.peekNonWhitespace(index + 1);\n      return next?.type === TokenType.Equals;\n    }\n    return false;\n  }\n\n  private isExpressionStatementStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first) {\n      return false;\n    }\n    if (first.type === TokenType.Identifier) {\n      return true;\n    }\n    return (\n      first.type === TokenType.Number\n      || first.type === TokenType.String\n      || first.type === TokenType.Boolean\n      || first.type === TokenType.Null\n      || first.type === TokenType.LParen\n      || first.type === TokenType.LBracket\n      || first.type === TokenType.LBrace\n      || first.type === TokenType.At\n      || first.type === TokenType.Dollar\n      || first.type === TokenType.Question\n      || first.type === TokenType.Bang\n      || first.type === TokenType.Minus\n    );\n  }\n\n  private isFunctionDeclarationStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first) {\n      return false;\n    }\n    let index = 0;\n    if (this.isAsyncToken(first)) {\n      const next = this.stream.peekNonWhitespace(1);\n      if (!next || next.type !== TokenType.Identifier) {\n        return false;\n      }\n      index = 1;\n    } else if (first.type !== TokenType.Identifier) {\n      return false;\n    }\n    index += 1;\n    if (this.stream.peekNonWhitespace(index)?.type !== TokenType.LParen) {\n      return false;\n    }\n    const indexAfterParams = this.stream.indexAfterDelimited(TokenType.LParen, TokenType.RParen, index);\n    if (indexAfterParams === null) {\n      return false;\n    }\n    return this.stream.peekNonWhitespace(indexAfterParams)?.type === TokenType.LBrace;\n  }\n\n  private isArrowFunctionStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first || first.type !== TokenType.LParen) {\n      return false;\n    }\n    const indexAfterParams = this.stream.indexAfterDelimited(TokenType.LParen, TokenType.RParen, 0);\n    if (indexAfterParams === null) {\n      return false;\n    }\n    return this.stream.peekNonWhitespace(indexAfterParams)?.type === TokenType.Arrow;\n  }\n\n  private isAsyncArrowFunctionStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!this.isAsyncToken(first)) {\n      return false;\n    }\n    if (this.stream.peekNonWhitespace(1)?.type !== TokenType.LParen) {\n      return false;\n    }\n    const indexAfterParams = this.stream.indexAfterDelimited(TokenType.LParen, TokenType.RParen, 1);\n    if (indexAfterParams === null) {\n      return false;\n    }\n    return this.stream.peekNonWhitespace(indexAfterParams)?.type === TokenType.Arrow;\n  }\n\n  private isFunctionExpressionAssignmentStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first || first.type !== TokenType.Identifier) {\n      return false;\n    }\n    if (this.stream.peekNonWhitespace(1)?.type !== TokenType.Equals) {\n      return false;\n    }\n    let index = 2;\n    if (this.isAsyncToken(this.stream.peekNonWhitespace(index))) {\n      index += 1;\n    }\n    if (this.stream.peekNonWhitespace(index)?.type !== TokenType.LParen) {\n      return false;\n    }\n    const indexAfterParams = this.stream.indexAfterDelimited(TokenType.LParen, TokenType.RParen, index);\n    if (indexAfterParams === null) {\n      return false;\n    }\n    return this.stream.peekNonWhitespace(indexAfterParams)?.type === TokenType.Arrow;\n  }\n\n  private parseExpressionStatement(): ExpressionNode {\n    const expr = this.parseExpression();\n    this.consumeStatementTerminator();\n    return expr;\n  }\n\n  private parseIfBlock(): IfNode {\n    this.stream.expect(TokenType.If);\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    this.stream.skipWhitespace();\n    const test = this.parseExpression();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.RParen);\n    const consequent = this.parseConditionalBody();\n    this.stream.skipWhitespace();\n    let alternate: BlockNode | undefined;\n    if (this.stream.peek()?.type === TokenType.Else) {\n      this.stream.next();\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.If) {\n        const nested = this.parseIfBlock();\n        alternate = new BlockNode([nested]);\n      } else {\n        alternate = this.parseConditionalBody();\n      }\n    }\n    return new IfNode(test, consequent, alternate);\n  }\n\n  private parseConditionalBody(): BlockNode {\n    this.stream.skipWhitespace();\n    if (this.stream.peek()?.type === TokenType.LBrace) {\n      return this.parseBlock({ allowDeclarations: false });\n    }\n    const statement = this.parseStatement({ allowBlocks: false, allowReturn: this.functionDepth > 0 });\n    return new BlockNode([statement]);\n  }\n\n  private parseWhileBlock(): WhileNode {\n    this.stream.expect(TokenType.While);\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    this.stream.skipWhitespace();\n    const test = this.parseExpression();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.RParen);\n    const body = this.parseBlock({ allowDeclarations: false });\n    return new WhileNode(test, body);\n  }\n\n  private parseForBlock(): ForNode | ForEachNode {\n    this.stream.expect(TokenType.For);\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    this.stream.skipWhitespace();\n    const eachKind = this.detectForEachKind();\n    if (eachKind) {\n      const target = this.parseForEachTarget();\n      this.stream.skipWhitespace();\n      const keyword = this.stream.expect(TokenType.Identifier);\n      if (keyword.value !== eachKind) {\n        throw new Error(`Expected '${eachKind}' but got '${keyword.value}'`);\n      }\n      this.stream.skipWhitespace();\n      const iterable = this.parseExpression();\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.RParen);\n      const body = this.parseBlock({ allowDeclarations: false });\n      return new ForEachNode(target, iterable, eachKind, body);\n    }\n    let init: CFSNode | undefined;\n    if (this.stream.peek()?.type !== TokenType.Semicolon) {\n      init = this.parseForClause();\n    }\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Semicolon);\n    this.stream.skipWhitespace();\n    let test: ExpressionNode | undefined;\n    if (this.stream.peek()?.type !== TokenType.Semicolon) {\n      test = this.parseExpression();\n    }\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Semicolon);\n    this.stream.skipWhitespace();\n    let update: CFSNode | undefined;\n    if (this.stream.peek()?.type !== TokenType.RParen) {\n      update = this.parseForClause();\n    }\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.RParen);\n    const body = this.parseBlock({ allowDeclarations: false });\n    return new ForNode(init, test, update, body);\n  }\n\n  private detectForEachKind(): \"in\" | \"of\" | null {\n    let offset = 0;\n    let depth = 0;\n    while (true) {\n      const token = this.stream.peekNonWhitespace(offset);\n      if (!token) {\n        return null;\n      }\n      if (token.type === TokenType.LParen || token.type === TokenType.LBracket || token.type === TokenType.LBrace) {\n        depth += 1;\n      } else if (\n        token.type === TokenType.RParen\n        || token.type === TokenType.RBracket\n        || token.type === TokenType.RBrace\n      ) {\n        if (depth === 0) {\n          return null;\n        }\n        depth -= 1;\n      }\n      if (depth === 0) {\n        if (token.type === TokenType.Semicolon) {\n          return null;\n        }\n        if (\n          token.type === TokenType.Identifier\n          && (token.value === \"in\" || token.value === \"of\")\n        ) {\n          return token.value;\n        }\n      }\n      offset += 1;\n    }\n  }\n\n  private parseForEachTarget(): IdentifierExpression {\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected for-each target\");\n    }\n    if (token.type !== TokenType.Identifier) {\n      throw new Error(\"for-in/of target must be an identifier\");\n    }\n    return new IdentifierExpression(this.stream.next().value);\n  }\n\n  private parseForClause(): CFSNode {\n    if (this.isAssignmentStart()) {\n      return this.parseAssignmentExpression();\n    }\n    return this.parseExpression();\n  }\n\n  private parseAssignmentExpression(): AssignmentNode {\n    const target = this.parseAssignmentTarget();\n    this.stream.skipWhitespace();\n    const operator = this.parseAssignmentOperator();\n    this.stream.skipWhitespace();\n    const value = this.parseExpression();\n    return new AssignmentNode(target, value, operator);\n  }\n\n  private parseAssignmentOperator(): \"=\" | \"+=\" | \"-=\" | \"*=\" | \"/=\" | \"~=\" {\n    const next = this.stream.peek();\n    if (!next) {\n      throw new Error(\"Expected assignment operator\");\n    }\n    if (next.type === TokenType.Equals) {\n      this.stream.next();\n      return \"=\";\n    }\n    if (next.type === TokenType.Tilde) {\n      this.stream.next();\n      this.stream.expect(TokenType.Equals);\n      return \"~=\";\n    }\n    if (next.type === TokenType.Plus ||\n        next.type === TokenType.Minus ||\n        next.type === TokenType.Star ||\n        next.type === TokenType.Slash) {\n      const op = this.stream.next();\n      this.stream.expect(TokenType.Equals);\n      if (op.type === TokenType.Plus) {\n        return \"+=\";\n      }\n      if (op.type === TokenType.Minus) {\n        return \"-=\";\n      }\n      if (op.type === TokenType.Star) {\n        return \"*=\";\n      }\n      return \"/=\";\n    }\n    throw new Error(\"Expected assignment operator\");\n  }\n\n  private parseTryBlock(): TryNode {\n    this.stream.expect(TokenType.Try);\n    const body = this.parseBlock({ allowDeclarations: false });\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Catch);\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    this.stream.skipWhitespace();\n    const errorName = this.stream.expect(TokenType.Identifier).value;\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.RParen);\n    const handler = this.parseBlock({ allowDeclarations: false });\n    return new TryNode(body, errorName, handler);\n  }\n\n  private parseConstructBlock(): BlockNode {\n    this.stream.expect(TokenType.Construct);\n    const body = this.parseBlock({ allowDeclarations: false });\n    body.type = \"Construct\";\n    return body;\n  }\n\n  private parseDestructBlock(): BlockNode {\n    this.stream.expect(TokenType.Destruct);\n    const body = this.parseBlock({ allowDeclarations: false });\n    body.type = \"Destruct\";\n    return body;\n  }\n\n  private parseQueryExpression(): QueryExpression {\n    this.stream.expect(TokenType.Question);\n    let direction: \"self\" | \"descendant\" | \"ancestor\" = \"self\";\n\n    if (this.stream.peek()?.type === TokenType.Greater) {\n      this.stream.next();\n      direction = \"descendant\";\n    } else if (this.stream.peek()?.type === TokenType.Less) {\n      this.stream.next();\n      direction = \"ancestor\";\n    }\n\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    const selector = this.readSelectorUntil(TokenType.RParen);\n    return new QueryExpression(direction, selector);\n  }\n\n  private parseFunctionDeclaration(): FunctionDeclarationNode {\n    let isAsync = false;\n    const first = this.stream.peekNonWhitespace(0);\n    if (this.isAsyncToken(first)) {\n      this.stream.next();\n      this.stream.skipWhitespace();\n      isAsync = true;\n    }\n    const name = this.stream.expect(TokenType.Identifier).value;\n    this.stream.skipWhitespace();\n    const params = this.parseFunctionParams();\n    this.stream.skipWhitespace();\n    const body = this.parseFunctionBlockWithAwait(isAsync);\n    return new FunctionDeclarationNode(name, params, body, isAsync);\n  }\n\n  private parseReturnStatement(): ReturnNode {\n    this.stream.expect(TokenType.Return);\n    this.stream.skipWhitespace();\n    if (this.stream.peek()?.type === TokenType.Semicolon) {\n      this.stream.next();\n      return new ReturnNode();\n    }\n    const value = this.parseExpression();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Semicolon);\n    return new ReturnNode(value);\n  }\n\n  private parseAssertStatement(): AssertNode {\n    this.stream.expect(TokenType.Assert);\n    this.stream.skipWhitespace();\n    const test = this.parseExpression();\n    this.consumeStatementTerminator();\n    return new AssertNode(test);\n  }\n\n  private parseBreakStatement(): BreakNode {\n    this.stream.expect(TokenType.Break);\n    this.consumeStatementTerminator();\n    return new BreakNode();\n  }\n\n  private parseContinueStatement(): ContinueNode {\n    this.stream.expect(TokenType.Continue);\n    this.consumeStatementTerminator();\n    return new ContinueNode();\n  }\n\n  private parseArrowFunctionExpression(isAsync = false): FunctionExpression {\n    const params = this.parseFunctionParams();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Arrow);\n    this.stream.skipWhitespace();\n    if (this.stream.peek()?.type === TokenType.LBrace) {\n      const body = this.parseFunctionBlockWithAwait(isAsync);\n      return new FunctionExpression(params, body, isAsync);\n    }\n    const body = this.parseArrowExpressionBody(isAsync);\n    return new FunctionExpression(params, body, isAsync);\n  }\n\n  private parseFunctionParams(): FunctionParam[] {\n    this.stream.expect(TokenType.LParen);\n    const params: FunctionParam[] = [];\n    let sawRest = false;\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated function parameters\");\n      }\n      if (next.type === TokenType.RParen) {\n        this.stream.next();\n        break;\n      }\n      if (next.type === TokenType.Ellipsis) {\n        if (sawRest) {\n          throw new Error(\"Function parameters can only include one rest parameter\");\n        }\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const name = this.stream.expect(TokenType.Identifier).value;\n        params.push({ name, rest: true });\n        sawRest = true;\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.Comma) {\n          throw new Error(\"Rest parameter must be last in function parameters\");\n        }\n        this.stream.expect(TokenType.RParen);\n        break;\n      }\n      const name = this.stream.expect(TokenType.Identifier).value;\n      this.stream.skipWhitespace();\n      let defaultValue: ExpressionNode | undefined;\n      if (this.stream.peek()?.type === TokenType.Equals) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        defaultValue = this.parseExpression();\n      }\n      params.push(defaultValue ? { name, defaultValue } : { name });\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.Comma) {\n        this.stream.next();\n        continue;\n      }\n      if (this.stream.peek()?.type === TokenType.RParen) {\n        this.stream.next();\n        break;\n      }\n      throw new Error(\"Expected ',' or ')' in function parameters\");\n    }\n    return params;\n  }\n\n  private readSelectorUntil(terminator: TokenType): string {\n    let selectorText = \"\";\n    let sawNonWhitespace = false;\n\n    while (true) {\n      const token = this.stream.peek();\n      if (!token) {\n        throw new Error(\"Unterminated selector\");\n      }\n      if (token.type === terminator) {\n        this.stream.next();\n        break;\n      }\n\n      if (token.type === TokenType.Whitespace) {\n        this.stream.next();\n        if (sawNonWhitespace && selectorText[selectorText.length - 1] !== \" \") {\n          selectorText += \" \";\n        }\n        continue;\n      }\n\n      sawNonWhitespace = true;\n      selectorText += this.stream.next().value;\n    }\n\n    return selectorText.trim();\n  }\n\n  private parseIdentifierPath(): string {\n    let value = this.stream.expect(TokenType.Identifier).value;\n    while (this.stream.peek()?.type === TokenType.Dot) {\n      this.stream.next();\n      const part = this.stream.expect(TokenType.Identifier).value;\n      value = `${value}.${part}`;\n    }\n    return value;\n  }\n}\n","export class Scope {\n  private data = new Map<string, any>();\n  private root: Scope;\n  private listeners = new Map<string, Set<() => void>>();\n  private anyListeners = new Set<() => void>();\n  public isEachItem = false;\n\n  constructor(public readonly parent?: Scope) {\n    this.root = parent ? parent.root : this;\n  }\n\n  createChild(): Scope {\n    return new Scope(this);\n  }\n\n  get(key: string): any {\n    return this.getPath(key);\n  }\n\n  set(key: string, value: any): void {\n    this.setPath(key, value);\n  }\n\n  hasKey(path: string): boolean {\n    const parts = path.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return false;\n    }\n    return this.data.has(root);\n  }\n\n  getPath(path: string): any {\n    const explicit = path.startsWith(\"parent.\") || path.startsWith(\"root.\") || path.startsWith(\"self.\");\n    const { targetScope, targetPath } = this.resolveScope(path);\n    if (!targetScope || !targetPath) {\n      return undefined;\n    }\n\n    const localValue = this.getLocalPathValue(targetScope, targetPath);\n    if (explicit || localValue !== undefined) {\n      return localValue;\n    }\n    let cursor = targetScope.parent;\n    while (cursor) {\n      const value = this.getLocalPathValue(cursor, targetPath);\n      if (value !== undefined) {\n        return value;\n      }\n      cursor = cursor.parent;\n    }\n    return undefined;\n  }\n\n  setPath(path: string, value: any): void {\n    const explicit = path.startsWith(\"parent.\") || path.startsWith(\"root.\") || path.startsWith(\"self.\");\n    const { targetScope, targetPath } = this.resolveScope(path);\n    if (!targetScope || !targetPath) {\n      return;\n    }\n\n    const scopeForSet = explicit ? targetScope : this.findNearestScopeWithKey(targetScope, targetPath) ?? targetScope;\n    const parts = targetPath.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return;\n    }\n    if (parts.length === 1) {\n      scopeForSet.data.set(root, value);\n      scopeForSet.emitChange(targetPath);\n      return;\n    }\n    let obj = scopeForSet.data.get(root);\n    if (obj == null || typeof obj !== \"object\") {\n      obj = {};\n      scopeForSet.data.set(root, obj);\n    }\n    let cursor = obj;\n    for (let i = 1; i < parts.length - 1; i += 1) {\n      const key = parts[i];\n      if (!key) {\n        return;\n      }\n      if (cursor[key] == null || typeof cursor[key] !== \"object\") {\n        cursor[key] = {};\n      }\n      cursor = cursor[key];\n    }\n    const lastKey = parts[parts.length - 1];\n    if (!lastKey) {\n      return;\n    }\n    cursor[lastKey] = value;\n    scopeForSet.emitChange(targetPath);\n  }\n\n  on(path: string, handler: () => void): void {\n    const key = path.trim();\n    if (!key) {\n      return;\n    }\n    const set = this.listeners.get(key) ?? new Set<() => void>();\n    set.add(handler);\n    this.listeners.set(key, set);\n  }\n\n  off(path: string, handler: () => void): void {\n    const key = path.trim();\n    const set = this.listeners.get(key);\n    if (!set) {\n      return;\n    }\n    set.delete(handler);\n    if (set.size === 0) {\n      this.listeners.delete(key);\n    }\n  }\n\n  onAny(handler: () => void): void {\n    this.anyListeners.add(handler);\n  }\n\n  offAny(handler: () => void): void {\n    this.anyListeners.delete(handler);\n  }\n\n  private emitChange(path: string): void {\n    const key = path.trim();\n    if (!key) {\n      return;\n    }\n    this.listeners.get(key)?.forEach((fn) => fn());\n    const rootKey = key.split(\".\")[0];\n    if (rootKey && rootKey !== key) {\n      this.listeners.get(rootKey)?.forEach((fn) => fn());\n    }\n    this.anyListeners.forEach((fn) => fn());\n  }\n\n  private resolveScope(path: string): { targetScope: Scope | undefined; targetPath: string | undefined } {\n    let targetScope: Scope | undefined = this;\n    let targetPath = path;\n    while (targetPath.startsWith(\"parent.\")) {\n      targetScope = targetScope?.parent;\n      targetPath = targetPath.slice(\"parent.\".length);\n    }\n    if (targetPath.startsWith(\"root.\")) {\n      targetScope = targetScope?.root;\n      targetPath = targetPath.slice(\"root.\".length);\n    }\n    while (targetPath.startsWith(\"self.\")) {\n      targetScope = targetScope ?? this;\n      targetPath = targetPath.slice(\"self.\".length);\n    }\n    return { targetScope, targetPath };\n  }\n\n  private getLocalPathValue(scope: Scope, path: string): any {\n    const parts = path.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return undefined;\n    }\n    let value = scope.data.get(root);\n    for (let i = 1; i < parts.length; i += 1) {\n      if (value == null) {\n        return undefined;\n      }\n      const key = parts[i];\n      if (!key) {\n        return undefined;\n      }\n      value = value[key];\n    }\n    return value;\n  }\n\n  private findNearestScopeWithKey(start: Scope, path: string): Scope | undefined {\n    const root = path.split(\".\")[0];\n    if (!root) {\n      return undefined;\n    }\n    let cursor: Scope | undefined = start;\n    while (cursor) {\n      if (cursor.data.has(root)) {\n        return cursor;\n      }\n      cursor = cursor.parent;\n    }\n    return undefined;\n  }\n}\n","import { Scope } from \"./scope\";\n\nexport type BindDirection = \"auto\" | \"both\" | \"from\" | \"to\";\n\nfunction getElementValue(element: Element): string {\n  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n    return element.value;\n  }\n  if (element instanceof HTMLSelectElement) {\n    return element.value;\n  }\n  return element.textContent ?? \"\";\n}\n\nfunction setElementValue(element: Element, value: string): void {\n  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n    element.value = value;\n    element.setAttribute(\"value\", value);\n    return;\n  }\n  if (element instanceof HTMLSelectElement) {\n    element.value = value;\n    return;\n  }\n  if (element instanceof HTMLElement && element.querySelector(\"*\")) {\n    return;\n  }\n  element.textContent = value;\n}\n\nexport function applyBindToScope(element: Element, expression: string, scope: Scope): void {\n  const key = expression.trim();\n  if (!key) {\n    return;\n  }\n\n  const value = getElementValue(element);\n  scope.set(key, value);\n}\n\nexport function applyBindToElement(element: Element, expression: string, scope: Scope): void {\n  const key = expression.trim();\n  if (!key) {\n    return;\n  }\n  const value = scope.get(key);\n  if (value == null) {\n    return;\n  }\n  setElementValue(element, String(value));\n}\n","import { Scope } from \"./scope\";\n\nfunction readCondition(expression: string, scope: Scope): boolean {\n  const key = expression.trim();\n  if (!key) {\n    return false;\n  }\n  return !!scope.get(key);\n}\n\nexport function applyIf(element: HTMLElement, expression: string, scope: Scope): void {\n  element.style.display = readCondition(expression, scope) ? \"\" : \"none\";\n}\n\nexport function applyShow(element: HTMLElement, expression: string, scope: Scope): void {\n  element.style.display = readCondition(expression, scope) ? \"\" : \"none\";\n}\n","import { Scope } from \"./scope\";\n\nexport function applyHtml(\n  element: HTMLElement,\n  expression: string,\n  scope: Scope\n): void {\n  const key = expression.trim();\n  if (!key) {\n    return;\n  }\n  const value = scope.get(key);\n  const html = value == null ? \"\" : String(value);\n  element.innerHTML = html;\n}\n","import { applyHtml } from \"./html\";\nimport { Scope } from \"./scope\";\n\nexport interface GetConfig {\n  url: string;\n  targetSelector?: string;\n  swap?: \"inner\" | \"outer\";\n}\n\nexport async function applyGet(\n  element: Element,\n  config: GetConfig,\n  scope: Scope,\n  onHtmlApplied?: (target: Element) => void\n): Promise<void> {\n  if (!globalThis.fetch) {\n    throw new Error(\"fetch is not available\");\n  }\n\n  const response = await globalThis.fetch(config.url);\n  if (!response || !response.ok) {\n    return;\n  }\n\n  const html = await response.text();\n  const target = resolveTarget(element, config.targetSelector);\n  if (!target) {\n    element.dispatchEvent(new CustomEvent(\"vsn:targetError\", { detail: { selector: config.targetSelector } }));\n    return;\n  }\n\n  if (config.swap === \"outer\") {\n    const wrapper = document.createElement(\"div\");\n    applyHtml(wrapper, \"__html\", { get: () => html } as unknown as Scope);\n    const replacement = wrapper.firstElementChild;\n    if (replacement && target.parentNode) {\n      target.parentNode.replaceChild(replacement, target);\n      onHtmlApplied?.(replacement);\n    }\n    return;\n  }\n\n  applyHtml(target as HTMLElement, \"__html\", { get: () => html } as unknown as Scope);\n  onHtmlApplied?.(target);\n}\n\nfunction resolveTarget(element: Element, selector?: string): Element | null {\n  if (!selector) {\n    return element;\n  }\n  return element.ownerDocument.querySelector(selector);\n}\n","type Debounced = (...args: any[]) => void;\n\nexport function debounce<T extends (...args: any[]) => void>(fn: T, waitMs: number): Debounced {\n  let timer: ReturnType<typeof setTimeout> | undefined;\n  return (...args: any[]) => {\n    if (timer) {\n      clearTimeout(timer);\n    }\n    timer = setTimeout(() => {\n      timer = undefined;\n      fn(...args);\n    }, waitMs);\n  };\n}\n","import { Scope } from \"./scope\";\nimport { applyBindToElement, applyBindToScope, BindDirection } from \"./bindings\";\nimport { applyIf, applyShow } from \"./conditionals\";\nimport { applyHtml } from \"./html\";\nimport { applyGet, GetConfig } from \"./http\";\nimport { debounce } from \"./debounce\";\nimport { Parser } from \"../parser/parser\";\nimport {\n  AssignmentNode,\n  BehaviorNode,\n  BehaviorFlags,\n  BehaviorFlagArgs,\n  BlockNode,\n  DeclarationFlags,\n  DeclarationFlagArgs,\n  DeclarationNode,\n  DirectiveExpression,\n  ExecutionContext,\n  ExpressionNode,\n  FunctionDeclarationNode,\n  FunctionParam,\n  FunctionExpression,\n  IdentifierExpression,\n  OnBlockNode,\n  UseNode\n} from \"../ast/nodes\";\n\ninterface OnConfig {\n  event: string;\n  code: string;\n  flags: DeclarationFlags;\n  flagArgs: DeclarationFlagArgs;\n}\n\ninterface BindConfig {\n  expr: string;\n  direction: BindDirection;\n  auto?: boolean;\n}\n\ninterface LifecycleConfig {\n  construct?: string;\n  destruct?: string;\n}\n\ninterface RegisteredBehavior {\n  id: number;\n  hash: string;\n  selector: string;\n  rootSelector: string;\n  parentSelector?: string;\n  specificity: number;\n  order: number;\n  construct?: BlockNode;\n  destruct?: BlockNode;\n  onBlocks: { event: string; body: BlockNode; flags: DeclarationFlags; flagArgs: DeclarationFlagArgs; args: string[] }[];\n  declarations: DeclarationNode[];\n  functions: FunctionBinding[];\n  flags: BehaviorFlags;\n  flagArgs: BehaviorFlagArgs;\n}\n\ntype FunctionBinding = {\n  name: string;\n  params: FunctionParam[];\n  body: BlockNode;\n};\n\ntype AttributeHandler = {\n  id: string;\n  match: (name: string) => boolean;\n  handle: (element: Element, name: string, value: string, scope: Scope) => boolean | void;\n};\n\ntype EachBinding = {\n  listExpr: string;\n  itemName: string;\n  indexName?: string;\n  rendered: Element[];\n};\n\ntype CachedBehavior = {\n  construct?: BlockNode;\n  destruct?: BlockNode;\n  onBlocks: { event: string; body: BlockNode; flags: DeclarationFlags; flagArgs: DeclarationFlagArgs; args: string[] }[];\n  declarations: DeclarationNode[];\n  functions: FunctionBinding[];\n};\n\ntype BehaviorListener = {\n  target: EventTarget;\n  event: string;\n  handler: (event?: Event) => void;\n  options?: AddEventListenerOptions | undefined;\n};\n\ntype FlagApplyContext = {\n  name: string;\n  args: any;\n  element: Element;\n  scope: Scope;\n  declaration: DeclarationNode;\n};\n\ntype FlagHandler = {\n  onApply?: (context: FlagApplyContext) => void;\n  transformValue?: (context: FlagApplyContext, value: any) => any;\n  onEventBind?: (context: EventFlagContext) => EventBindPatch | void;\n  onEventBefore?: (context: EventFlagContext) => boolean | void;\n  onEventAfter?: (context: EventFlagContext) => void;\n  transformEventArgs?: (context: EventFlagContext, args: any[]) => any[];\n};\n\ntype BehaviorModifierHandler = {\n  onBind?: (context: BehaviorModifierContext) => void | Promise<void>;\n  onConstruct?: (context: BehaviorModifierContext) => void | Promise<void>;\n  onDestruct?: (context: BehaviorModifierContext) => void | Promise<void>;\n  onUnbind?: (context: BehaviorModifierContext) => void | Promise<void>;\n};\n\ntype BehaviorModifierContext = {\n  name: string;\n  args: any;\n  element: Element;\n  scope: Scope;\n  rootScope: Scope | undefined;\n  behavior: RegisteredBehavior;\n  engine: Engine;\n};\n\ntype EventBindPatch = {\n  listenerTarget?: EventTarget;\n  options?: AddEventListenerOptions;\n  debounceMs?: number;\n};\n\ntype EventFlagContext = {\n  name: string;\n  args: any;\n  element: Element;\n  scope: Scope;\n  rootScope: Scope | undefined;\n  event: Event | undefined;\n  engine: Engine;\n};\n\ntype EngineOptions = {\n  diagnostics?: boolean;\n  logger?: Partial<Pick<Console, \"info\" | \"warn\">>;\n};\n\nexport class Engine {\n  private static activeEngines = new WeakMap<Document, Engine>();\n  private scopes = new WeakMap<Element, Scope>();\n  private bindBindings = new WeakMap<Element, BindConfig>();\n  private ifBindings = new WeakMap<Element, string>();\n  private showBindings = new WeakMap<Element, string>();\n  private htmlBindings = new WeakMap<Element, { expr: string }>();\n  private getBindings = new WeakMap<Element, GetConfig>();\n  private eachBindings = new WeakMap<Element, EachBinding>();\n  private lifecycleBindings = new WeakMap<Element, LifecycleConfig>();\n  private behaviorRegistry: RegisteredBehavior[] = [];\n  private behaviorRegistryHashes = new Set<string>();\n  private behaviorBindings = new WeakMap<Element, Set<number>>();\n  private behaviorListeners = new WeakMap<Element, Map<number, BehaviorListener[]>>();\n  private behaviorId = 0;\n  private codeCache = new Map<string, BlockNode>();\n  private behaviorCache = new Map<string, CachedBehavior>();\n  private observer: MutationObserver | undefined;\n  private attributeHandlers: AttributeHandler[] = [];\n  private globals: Record<string, any> = {};\n  private importantFlags = new WeakMap<Element, Set<string>>();\n  private inlineDeclarations = new WeakMap<Element, Set<string>>();\n  private flagHandlers = new Map<string, FlagHandler>();\n  private behaviorModifiers = new Map<string, BehaviorModifierHandler>();\n  private pendingAdded = new Set<Element>();\n  private pendingRemoved = new Set<Element>();\n  private pendingUpdated = new Set<Element>();\n  private observerFlush?: () => void;\n  private ignoredAdded = new WeakMap<Element, boolean>();\n  private diagnostics: boolean;\n  private logger: Partial<Pick<Console, \"info\" | \"warn\">>;\n  private pendingUses: Promise<void>[] = [];\n  private pendingAutoBindToScope: Array<{ element: Element; expr: string; scope: Scope }> = [];\n  private scopeWatchers = new WeakMap<Element, { scope: Scope; kind: \"path\" | \"any\"; key?: string; handler: () => void }[]>();\n  private executionStack: Element[] = [];\n  private groupProxyCache = new WeakMap<Scope, Record<string, any>>();\n\n  constructor(options: EngineOptions = {}) {\n    this.diagnostics = options.diagnostics ?? false;\n    this.logger = options.logger ?? console;\n    this.registerGlobal(\"console\", console);\n    this.registerFlag(\"important\");\n    this.registerFlag(\"debounce\", {\n      onEventBind: ({ args }) => ({\n        debounceMs: typeof args === \"number\" ? args : 200\n      })\n    });\n    this.registerFlag(\"prevent\", {\n      onEventBefore: ({ event }) => {\n        event?.preventDefault();\n      }\n    });\n    this.registerFlag(\"stop\", {\n      onEventBefore: ({ event }) => {\n        event?.stopPropagation();\n      }\n    });\n    this.registerFlag(\"self\", {\n      onEventBefore: ({ event, element }) => {\n        const target = event?.target;\n        if (!(target instanceof Node)) {\n          return false;\n        }\n        return target === element;\n      }\n    });\n    this.registerFlag(\"outside\", {\n      onEventBind: ({ element }) => ({ listenerTarget: element.ownerDocument }),\n      onEventBefore: ({ event, element }) => {\n        const target = event?.target;\n        if (!(target instanceof Node)) {\n          return false;\n        }\n        return !element.contains(target);\n      }\n    });\n    this.registerFlag(\"once\", {\n      onEventBind: () => ({ options: { once: true } })\n    });\n    this.registerFlag(\"passive\", {\n      onEventBind: () => ({ options: { passive: true } })\n    });\n    this.registerFlag(\"capture\", {\n      onEventBind: () => ({ options: { capture: true } })\n    });\n    this.registerFlag(\"shift\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"shift\")\n    });\n    this.registerFlag(\"ctrl\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"ctrl\")\n    });\n    this.registerFlag(\"control\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"ctrl\")\n    });\n    this.registerFlag(\"alt\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"alt\")\n    });\n    this.registerFlag(\"meta\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"meta\")\n    });\n    this.registerFlag(\"enter\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"enter\")\n    });\n    this.registerFlag(\"escape\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"escape\")\n    });\n    this.registerFlag(\"esc\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"escape\")\n    });\n    this.registerFlag(\"tab\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"tab\")\n    });\n    this.registerFlag(\"space\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"space\")\n    });\n    this.registerFlag(\"up\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"arrowup\")\n    });\n    this.registerFlag(\"down\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"arrowdown\")\n    });\n    this.registerFlag(\"left\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"arrowleft\")\n    });\n    this.registerFlag(\"right\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"arrowright\")\n    });\n    this.registerFlag(\"arrowup\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"arrowup\")\n    });\n    this.registerFlag(\"arrowdown\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"arrowdown\")\n    });\n    this.registerFlag(\"arrowleft\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"arrowleft\")\n    });\n    this.registerFlag(\"arrowright\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"arrowright\")\n    });\n    this.registerFlag(\"delete\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"delete\")\n    });\n    this.registerFlag(\"backspace\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"backspace\")\n    });\n    this.registerGlobal(\"list\", {\n      async map(items: any[], fn: (item: any, index: number) => any) {\n        if (!Array.isArray(items) || typeof fn !== \"function\") {\n          return [];\n        }\n        const results = [];\n        for (let i = 0; i < items.length; i += 1) {\n          results.push(await fn(items[i], i));\n        }\n        return results;\n      },\n      async filter(items: any[], fn: (item: any, index: number) => any) {\n        if (!Array.isArray(items) || typeof fn !== \"function\") {\n          return [];\n        }\n        const results = [];\n        for (let i = 0; i < items.length; i += 1) {\n          if (await fn(items[i], i)) {\n            results.push(items[i]);\n          }\n        }\n        return results;\n      },\n      async reduce(items: any[], fn: (acc: any, item: any, index: number) => any, initial?: any) {\n        if (!Array.isArray(items) || typeof fn !== \"function\") {\n          return initial;\n        }\n        const hasInitial = arguments.length > 2;\n        let acc = hasInitial ? initial : items[0];\n        let start = hasInitial ? 0 : 1;\n        for (let i = start; i < items.length; i += 1) {\n          acc = await fn(acc, items[i], i);\n        }\n        return acc;\n      }\n    });\n    this.registerDefaultAttributeHandlers();\n    this.registerFlag(\"int\", {\n      transformValue: (_context, value) => this.coerceInt(value)\n    });\n    this.registerFlag(\"float\", {\n      transformValue: (_context, value) => this.coerceFloat(value)\n    });\n    this.registerBehaviorModifier(\"group\", {\n      onConstruct: ({ args, scope, rootScope, behavior, element }) => {\n        const key = typeof args === \"string\" ? args : undefined;\n        if (!key) {\n          return;\n        }\n        const targetScope = this.getGroupTargetScope(element, behavior, scope, rootScope);\n        const existing = targetScope.getPath?.(key);\n        const list = Array.isArray(existing) ? existing : [];\n        const proxy = this.getGroupProxy(scope);\n        if (!list.includes(proxy)) {\n          list.push(proxy);\n          targetScope.setPath?.(key, list);\n        } else if (!Array.isArray(existing)) {\n          targetScope.setPath?.(key, list);\n        }\n      },\n      onUnbind: ({ args, scope, rootScope, behavior, element }) => {\n        const key = typeof args === \"string\" ? args : undefined;\n        if (!key) {\n          return;\n        }\n        const targetScope = this.getGroupTargetScope(element, behavior, scope, rootScope);\n        const existing = targetScope.getPath?.(key);\n        if (!Array.isArray(existing)) {\n          return;\n        }\n        const proxy = this.getGroupProxy(scope);\n        const next = existing.filter((entry) => entry !== proxy);\n        if (next.length !== existing.length) {\n          targetScope.setPath?.(key, next);\n        }\n      }\n    });\n  }\n\n  private getGroupTargetScope(\n    element: Element,\n    behavior: RegisteredBehavior,\n    scope: Scope,\n    rootScope?: Scope\n  ): Scope {\n    let targetScope = rootScope ?? scope;\n    if (behavior.parentSelector) {\n      const parentElement = element.closest(behavior.parentSelector);\n      if (parentElement) {\n        targetScope = this.getScope(parentElement);\n      }\n    }\n    return targetScope;\n  }\n\n  private getGroupProxy(scope: Scope): Record<string, any> {\n    const cached = this.groupProxyCache.get(scope);\n    if (cached) {\n      return cached;\n    }\n    const proxy = new Proxy(\n      {},\n      {\n        get: (_target, prop) => {\n          if (typeof prop === \"symbol\") {\n            return undefined;\n          }\n          if (prop === \"__scope\") {\n            return scope;\n          }\n          return scope.getPath(String(prop));\n        },\n        set: (_target, prop, value) => {\n          if (typeof prop === \"symbol\") {\n            return false;\n          }\n          scope.setPath(String(prop), value);\n          return true;\n        },\n        has: (_target, prop) => {\n          if (typeof prop === \"symbol\") {\n            return false;\n          }\n          return scope.getPath(String(prop)) !== undefined;\n        },\n        getOwnPropertyDescriptor: () => ({\n          enumerable: true,\n          configurable: true\n        }),\n        ownKeys: () => []\n      }\n    );\n    this.groupProxyCache.set(scope, proxy);\n    return proxy;\n  }\n\n  async mount(root: HTMLElement): Promise<void> {\n    const documentRoot = root.ownerDocument;\n    const active = Engine.activeEngines.get(documentRoot);\n    if (active && active !== this) {\n      active.disconnectObserver();\n    }\n    Engine.activeEngines.set(documentRoot, this);\n    const elements: Element[] = [root, ...Array.from(root.querySelectorAll(\"*\"))];\n    for (const element of elements) {\n      if (!this.hasVsnAttributes(element)) {\n        continue;\n      }\n      const parentScope = this.findParentScope(element);\n      this.getScope(element, parentScope);\n      this.attachAttributes(element);\n      this.runConstruct(element);\n    }\n    await this.applyBehaviors(root);\n    this.attachObserver(root);\n  }\n\n  unmount(element: Element): void {\n    this.runDestruct(element);\n    this.disconnectObserver();\n  }\n\n  registerBehaviors(source: string): void {\n    const program = new Parser(source, {\n      customFlags: new Set(this.flagHandlers.keys()),\n      behaviorFlags: new Set(this.behaviorModifiers.keys())\n    }).parseProgram();\n    for (const use of program.uses) {\n      if (use.flags?.wait) {\n        this.pendingUses.push(this.waitForUseGlobal(use));\n        continue;\n      }\n      const value = this.resolveGlobalPath(use.name);\n      if (value === undefined) {\n        console.warn(`vsn: global '${use.name}' not found`);\n        continue;\n      }\n      this.registerGlobal(use.alias, value);\n    }\n    for (const behavior of program.behaviors) {\n      this.collectBehavior(behavior);\n    }\n  }\n\n  registerGlobal(name: string, value: any): void {\n    this.globals[name] = value;\n  }\n\n  registerGlobals(values: Record<string, any>): void {\n    Object.assign(this.globals, values);\n  }\n\n  registerFlag(name: string, handler: FlagHandler = {}): void {\n    this.flagHandlers.set(name, handler);\n  }\n\n  registerBehaviorModifier(name: string, handler: BehaviorModifierHandler = {}): void {\n    const reserved = new Set([\"important\", \"debounce\"]);\n    if (reserved.has(name)) {\n      throw new Error(`Behavior modifier '${name}' is reserved`);\n    }\n    this.behaviorModifiers.set(name, handler);\n  }\n\n  getRegistryStats(): { behaviorCount: number; behaviorCacheSize: number } {\n    return {\n      behaviorCount: this.behaviorRegistry.length,\n      behaviorCacheSize: this.behaviorCache.size\n    };\n  }\n\n  registerAttributeHandler(handler: AttributeHandler): void {\n    this.attributeHandlers.push(handler);\n  }\n\n  private resolveGlobalPath(name: string): any {\n    const parts = name.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return undefined;\n    }\n    let value: any = (globalThis as any)[root];\n    for (let i = 1; i < parts.length; i += 1) {\n      const part = parts[i];\n      if (!part) {\n        return undefined;\n      }\n      value = value?.[part];\n    }\n    return value;\n  }\n\n  private async waitForUses(): Promise<void> {\n    while (this.pendingUses.length > 0) {\n      const pending = this.pendingUses;\n      this.pendingUses = [];\n      await Promise.all(pending);\n    }\n  }\n\n  private waitForUseGlobal(use: UseNode): Promise<void> {\n    const config = use.flagArgs?.wait ?? {};\n    const timeoutMs = config.timeoutMs ?? 10000;\n    const initialDelayMs = config.intervalMs ?? 100;\n    const maxDelayMs = 1000;\n    const existing = this.resolveGlobalPath(use.name);\n    if (existing !== undefined) {\n      this.registerGlobal(use.alias, existing);\n      return Promise.resolve();\n    }\n    if (timeoutMs <= 0) {\n      this.emitUseError(use.name, new Error(`vsn: global '${use.name}' not found`));\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve) => {\n      let elapsedMs = 0;\n      let delayMs = initialDelayMs;\n      const check = () => {\n        const value = this.resolveGlobalPath(use.name);\n        if (value !== undefined) {\n          this.registerGlobal(use.alias, value);\n          resolve();\n          return;\n        }\n        if (elapsedMs >= timeoutMs) {\n          this.emitUseError(use.name, new Error(`vsn: global '${use.name}' not found`));\n          resolve();\n          return;\n        }\n        const scheduledDelay = Math.min(delayMs, timeoutMs - elapsedMs);\n        setTimeout(() => {\n          elapsedMs += scheduledDelay;\n          delayMs = Math.min(delayMs * 2, maxDelayMs);\n          check();\n        }, scheduledDelay);\n      };\n      check();\n    });\n  }\n\n  getScope(element: Element, parentScope?: Scope): Scope {\n    const existing = this.scopes.get(element);\n    if (existing) {\n      return existing;\n    }\n    const scope = new Scope(parentScope ?? this.findParentScope(element));\n    this.scopes.set(element, scope);\n    return scope;\n  }\n\n  evaluate(element: Element): void {\n    const scope = this.getScope(element);\n    const bindConfig = this.bindBindings.get(element);\n    if (bindConfig && (bindConfig.direction === \"from\" || bindConfig.direction === \"both\")) {\n      applyBindToElement(element, bindConfig.expr, scope);\n    }\n    const ifExpr = this.ifBindings.get(element);\n    if (ifExpr && element instanceof HTMLElement) {\n      applyIf(element, ifExpr, scope);\n    }\n    const showExpr = this.showBindings.get(element);\n    if (showExpr && element instanceof HTMLElement) {\n      applyShow(element, showExpr, scope);\n    }\n    const htmlBinding = this.htmlBindings.get(element);\n    if (htmlBinding && element instanceof HTMLElement) {\n      applyHtml(element, htmlBinding.expr, scope);\n      this.handleHtmlBehaviors(element);\n    }\n  }\n\n  private attachObserver(root: HTMLElement): void {\n    if (this.observer) {\n      return;\n    }\n    this.observerFlush = debounce(() => this.flushObserverQueue(), 10);\n    this.observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type === \"attributes\" && mutation.target instanceof Element) {\n          this.pendingUpdated.add(mutation.target);\n        }\n        for (const node of Array.from(mutation.addedNodes)) {\n          if (node && node.nodeType === 1) {\n            const element = node as Element;\n            if (this.ignoredAdded.has(element)) {\n              this.ignoredAdded.delete(element);\n              continue;\n            }\n            this.pendingAdded.add(element);\n          }\n        }\n        for (const node of Array.from(mutation.removedNodes)) {\n          if (node && node.nodeType === 1) {\n            this.pendingRemoved.add(node as Element);\n          }\n        }\n      }\n      this.observerFlush?.();\n    });\n    this.observer.observe(root, { childList: true, subtree: true, attributes: true, attributeFilter: [\"class\"] });\n  }\n\n  private disconnectObserver(): void {\n    this.observer?.disconnect();\n    this.observer = undefined;\n    this.pendingAdded.clear();\n    this.pendingRemoved.clear();\n    this.pendingUpdated.clear();\n  }\n\n  private flushObserverQueue(): void {\n    const removed = Array.from(this.pendingRemoved);\n    this.pendingRemoved.clear();\n    for (const node of removed) {\n      this.handleRemovedNode(node);\n    }\n    const updated = Array.from(this.pendingUpdated);\n    this.pendingUpdated.clear();\n    for (const node of updated) {\n      this.handleUpdatedNode(node);\n    }\n    const added = Array.from(this.pendingAdded);\n    this.pendingAdded.clear();\n    for (const node of added) {\n      this.handleAddedNode(node);\n    }\n  }\n\n  private handleRemovedNode(node: Element): void {\n    if (this.lifecycleBindings.has(node)) {\n      this.runDestruct(node);\n    }\n    if (this.behaviorBindings.has(node)) {\n      this.runBehaviorDestruct(node);\n    }\n    this.cleanupScopeWatchers(node);\n    this.cleanupBehaviorListeners(node);\n    for (const child of Array.from(node.querySelectorAll(\"*\"))) {\n      if (this.lifecycleBindings.has(child)) {\n        this.runDestruct(child);\n      }\n      if (this.behaviorBindings.has(child)) {\n        this.runBehaviorDestruct(child);\n      }\n      this.cleanupScopeWatchers(child);\n      this.cleanupBehaviorListeners(child);\n    }\n  }\n\n  private handleAddedNode(node: Element): void {\n    const elements = [node, ...Array.from(node.querySelectorAll(\"*\"))];\n    for (const element of elements) {\n      if (!this.hasVsnAttributes(element)) {\n        continue;\n      }\n      const parentScope = this.findParentScope(element);\n      this.getScope(element, parentScope);\n      this.attachAttributes(element);\n      this.runConstruct(element);\n    }\n    void this.applyBehaviors(node);\n  }\n\n  private handleUpdatedNode(node: Element): void {\n    const elements = [node, ...Array.from(node.querySelectorAll(\"*\"))];\n    for (const element of elements) {\n      void this.reapplyBehaviorsForElement(element);\n    }\n  }\n\n  private async applyBehaviors(root: Element): Promise<void> {\n    await this.waitForUses();\n    if (this.behaviorRegistry.length > 0) {\n      const elements: Element[] = [root, ...Array.from(root.querySelectorAll(\"*\"))];\n      for (const element of elements) {\n        await this.reapplyBehaviorsForElement(element);\n      }\n    }\n    this.flushAutoBindQueue();\n  }\n\n  private async reapplyBehaviorsForElement(element: Element): Promise<void> {\n    if (this.behaviorRegistry.length === 0) {\n      return;\n    }\n    const bound = this.behaviorBindings.get(element) ?? new Set<number>();\n    const scope = this.getScope(element);\n    const matched = this.behaviorRegistry\n      .filter((behavior) => element.matches(behavior.selector))\n      .sort((a, b) => {\n        if (a.specificity !== b.specificity) {\n          return a.specificity - b.specificity;\n        }\n        return a.order - b.order;\n      });\n\n    for (const behavior of matched) {\n      if (!bound.has(behavior.id)) {\n        await this.applyBehaviorForElement(behavior, element, scope, bound);\n      }\n    }\n\n    const matchedIds = new Set(matched.map((behavior) => behavior.id));\n    for (const behavior of this.behaviorRegistry) {\n      if (bound.has(behavior.id) && !matchedIds.has(behavior.id)) {\n        this.unbindBehaviorForElement(behavior, element, scope, bound);\n      }\n    }\n    this.behaviorBindings.set(element, bound);\n  }\n\n  private async applyBehaviorForElement(\n    behavior: RegisteredBehavior,\n    element: Element,\n    scope: Scope,\n    bound: Set<number>\n  ): Promise<void> {\n    bound.add(behavior.id);\n    const rootScope = this.getBehaviorRootScope(element, behavior);\n    this.applyBehaviorFunctions(element, scope, behavior.functions, rootScope);\n    await this.applyBehaviorDeclarations(element, scope, behavior.declarations, rootScope);\n    await this.applyBehaviorModifierHook(\"onBind\", behavior, element, scope, rootScope);\n    if (behavior.construct) {\n      await this.safeExecuteBlock(behavior.construct, scope, element, rootScope);\n    }\n    await this.applyBehaviorModifierHook(\"onConstruct\", behavior, element, scope, rootScope);\n    for (const onBlock of behavior.onBlocks) {\n      this.attachBehaviorOnHandler(\n        element,\n        onBlock.event,\n        onBlock.body,\n        onBlock.flags,\n        onBlock.flagArgs,\n        onBlock.args,\n        behavior.id,\n        rootScope\n      );\n    }\n    this.logDiagnostic(\"bind\", element, behavior);\n  }\n\n  private unbindBehaviorForElement(\n    behavior: RegisteredBehavior,\n    element: Element,\n    scope: Scope,\n    bound: Set<number>\n  ): void {\n    bound.delete(behavior.id);\n    const rootScope = this.getBehaviorRootScope(element, behavior);\n    if (behavior.destruct) {\n      void this.safeExecuteBlock(behavior.destruct, scope, element, rootScope);\n    }\n    void this.applyBehaviorModifierHook(\"onDestruct\", behavior, element, scope, rootScope);\n    const listenerMap = this.behaviorListeners.get(element);\n    const listeners = listenerMap?.get(behavior.id);\n    if (listeners) {\n      for (const listener of listeners) {\n        listener.target.removeEventListener(listener.event, listener.handler, listener.options);\n      }\n      listenerMap?.delete(behavior.id);\n    }\n    void this.applyBehaviorModifierHook(\"onUnbind\", behavior, element, scope, rootScope);\n    this.logDiagnostic(\"unbind\", element, behavior);\n  }\n\n  private runBehaviorDestruct(element: Element): void {\n    const bound = this.behaviorBindings.get(element);\n    if (!bound) {\n      return;\n    }\n    const scope = this.getScope(element);\n    for (const behavior of this.behaviorRegistry) {\n      if (!bound.has(behavior.id) || (!behavior.destruct && !this.behaviorHasModifierHooks(behavior))) {\n        continue;\n      }\n      const rootScope = this.getBehaviorRootScope(element, behavior);\n      if (behavior.destruct) {\n        void this.safeExecuteBlock(behavior.destruct, scope, element, rootScope);\n      }\n      void this.applyBehaviorModifierHook(\"onDestruct\", behavior, element, scope, rootScope);\n      void this.applyBehaviorModifierHook(\"onUnbind\", behavior, element, scope, rootScope);\n    }\n  }\n\n  private attachAttributes(element: Element): void {\n    const scope = this.getScope(element);\n    for (const name of element.getAttributeNames()) {\n      if (!name.startsWith(\"vsn-\")) {\n        continue;\n      }\n      const value = element.getAttribute(name) ?? \"\";\n      for (const handler of this.attributeHandlers) {\n        if (!handler.match(name)) {\n          continue;\n        }\n        const handled = handler.handle(element, name, value, scope);\n        if (handled !== false) {\n          break;\n        }\n      }\n    }\n  }\n\n  private setLifecycle(element: Element, patch: LifecycleConfig): void {\n    const current = this.lifecycleBindings.get(element) ?? {};\n    this.lifecycleBindings.set(element, { ...current, ...patch });\n  }\n\n  private runConstruct(element: Element): void {\n    const config = this.lifecycleBindings.get(element);\n    if (!config?.construct) {\n      return;\n    }\n    const scope = this.getScope(element);\n    void this.safeExecute(config.construct, scope, element);\n  }\n\n  private runDestruct(element: Element): void {\n    const config = this.lifecycleBindings.get(element);\n    if (!config?.destruct) {\n      return;\n    }\n    const scope = this.getScope(element);\n    void this.safeExecute(config.destruct, scope, element);\n  }\n\n  private parseEachExpression(value: string): { listExpr: string; itemName: string; indexName?: string } | null {\n    const [listPart, rest] = value.split(/\\s+as\\s+/);\n    if (!listPart || !rest) {\n      return null;\n    }\n    const listExpr = listPart.trim();\n    const names = rest.split(\",\").map((entry) => entry.trim()).filter(Boolean);\n    if (!listExpr || names.length === 0) {\n      return null;\n    }\n    const itemName = names[0] ?? \"\";\n    const indexName = names[1];\n    return { listExpr, itemName, ...(indexName ? { indexName } : {}) };\n  }\n\n  private renderEach(element: Element): void {\n    const binding = this.eachBindings.get(element);\n    if (!binding) {\n      return;\n    }\n    if (!(element instanceof HTMLTemplateElement)) {\n      return;\n    }\n    const parent = element.parentElement;\n    if (!parent) {\n      return;\n    }\n\n    for (const node of binding.rendered) {\n      this.handleRemovedNode(node);\n      if (node.parentNode) {\n        node.parentNode.removeChild(node);\n      }\n    }\n    binding.rendered = [];\n\n    const scope = this.getScope(element);\n    const list = scope.get(binding.listExpr);\n    if (!Array.isArray(list)) {\n      return;\n    }\n\n    const rendered: Element[] = [];\n    list.forEach((item, index) => {\n      const fragment = element.content.cloneNode(true) as DocumentFragment;\n      const roots = Array.from(fragment.children) as Element[];\n      const itemScope = new Scope(scope);\n      itemScope.isEachItem = true;\n      itemScope.setPath(`self.${binding.itemName}`, item);\n      if (binding.indexName) {\n        itemScope.setPath(`self.${binding.indexName}`, index);\n      }\n      for (const root of roots) {\n        this.getScope(root, itemScope);\n      }\n      parent.insertBefore(fragment, element);\n      for (const root of roots) {\n        this.ignoredAdded.set(root, true);\n        rendered.push(root);\n        this.handleAddedNode(root);\n        this.evaluate(root);\n        for (const child of Array.from(root.querySelectorAll(\"*\"))) {\n          this.evaluate(child);\n        }\n      }\n    });\n    binding.rendered = rendered;\n  }\n\n  private attachBindInputHandler(element: Element, expr: string): void {\n    if (!(element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement)) {\n      return;\n    }\n    const handler = () => {\n      const scope = this.getScope(element);\n      applyBindToScope(element, expr, scope);\n    };\n    element.addEventListener(\"input\", handler);\n    element.addEventListener(\"change\", handler);\n  }\n\n  private parseBindDirection(name: string): BindDirection {\n    if (name.includes(\":from\")) {\n      return \"from\";\n    }\n    if (name.includes(\":to\")) {\n      return \"to\";\n    }\n    return \"auto\";\n  }\n\n  private resolveBindConfig(element: Element, expr: string, scope: Scope, direction: BindDirection): {\n    direction: BindDirection;\n    seedFromScope: boolean;\n    syncToScope: boolean;\n    deferToScope: boolean;\n  } {\n    if (direction !== \"auto\") {\n      return {\n        direction,\n        seedFromScope: false,\n        syncToScope: direction === \"to\" || direction === \"both\",\n        deferToScope: false\n      };\n    }\n\n    if (this.isInEachScope(scope)) {\n      return { direction: \"both\", seedFromScope: false, syncToScope: false, deferToScope: false };\n    }\n\n    if (this.isFormControl(element)) {\n      if (this.hasScopeValue(scope, expr)) {\n        return { direction: \"both\", seedFromScope: true, syncToScope: false, deferToScope: false };\n      }\n      return { direction: \"both\", seedFromScope: false, syncToScope: false, deferToScope: true };\n    }\n\n    if (this.hasScopeValue(scope, expr)) {\n      return { direction: \"both\", seedFromScope: false, syncToScope: false, deferToScope: false };\n    }\n\n    if (this.hasElementValue(element)) {\n      return { direction: \"both\", seedFromScope: false, syncToScope: false, deferToScope: true };\n    }\n\n    return { direction: \"both\", seedFromScope: false, syncToScope: false, deferToScope: false };\n  }\n\n  private isFormControl(element: Element): boolean {\n    return element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement;\n  }\n\n  private hasScopeValue(scope: Scope, expr: string): boolean {\n    const key = expr.trim();\n    if (!key) {\n      return false;\n    }\n    const value = scope.get(key);\n    return value !== undefined && value !== null;\n  }\n\n  private hasElementValue(element: Element): boolean {\n    if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement) {\n      return element.value.length > 0;\n    }\n    return (element.textContent ?? \"\").trim().length > 0;\n  }\n\n  private coerceInt(value: any): any {\n    if (value == null || value === \"\") {\n      return value;\n    }\n    const num = typeof value === \"number\" ? value : Number.parseInt(String(value), 10);\n    return Number.isNaN(num) ? value : num;\n  }\n\n  private coerceFloat(value: any): any {\n    if (value == null || value === \"\") {\n      return value;\n    }\n    const num = typeof value === \"number\" ? value : Number.parseFloat(String(value));\n    return Number.isNaN(num) ? value : num;\n  }\n\n  private isInEachScope(scope: Scope): boolean {\n    let cursor: Scope | undefined = scope;\n    while (cursor) {\n      if (cursor.isEachItem) {\n        return true;\n      }\n      cursor = cursor.parent;\n    }\n    return false;\n  }\n\n  private flushAutoBindQueue(): void {\n    if (this.pendingAutoBindToScope.length === 0) {\n      return;\n    }\n    const pending = this.pendingAutoBindToScope;\n    this.pendingAutoBindToScope = [];\n    for (const entry of pending) {\n      if (!entry.element.isConnected) {\n        continue;\n      }\n      if (this.hasScopeValue(entry.scope, entry.expr)) {\n        continue;\n      }\n      if (!this.hasElementValue(entry.element)) {\n        continue;\n      }\n      applyBindToScope(entry.element, entry.expr, entry.scope);\n    }\n  }\n\n  private hasVsnAttributes(element: Element): boolean {\n    return element.getAttributeNames().some((name) => name.startsWith(\"vsn-\"));\n  }\n\n  private markInlineDeclaration(element: Element, key: string): void {\n    const set = this.inlineDeclarations.get(element) ?? new Set<string>();\n    set.add(key);\n    this.inlineDeclarations.set(element, set);\n  }\n\n  private isInlineDeclaration(element: Element, key: string): boolean {\n    const set = this.inlineDeclarations.get(element);\n    return set ? set.has(key) : false;\n  }\n\n  private findParentScope(element: Element): Scope | undefined {\n    let parent = element.parentElement;\n    while (parent) {\n      const scope = this.scopes.get(parent);\n      if (scope) {\n        return scope;\n      }\n      parent = parent.parentElement;\n    }\n    return undefined;\n  }\n\n  private watch(scope: Scope, expr: string, handler: () => void, element?: Element): void {\n    const key = expr.trim();\n    if (!key) {\n      return;\n    }\n    const root = key.split(\".\")[0];\n    if (!root) {\n      return;\n    }\n    let target: Scope | undefined = scope;\n    while (target && !target.hasKey(root)) {\n      target = target.parent;\n    }\n    if (target) {\n      target.on(key, handler);\n      if (element) {\n        this.trackScopeWatcher(element, target, \"path\", handler, key);\n      }\n      return;\n    }\n    let cursor: Scope | undefined = scope;\n    while (cursor) {\n      cursor.on(key, handler);\n      if (element) {\n        this.trackScopeWatcher(element, cursor, \"path\", handler, key);\n      }\n      cursor = cursor.parent;\n    }\n  }\n\n  private watchWithDebounce(\n    scope: Scope,\n    expr: string,\n    handler: () => void,\n    debounceMs?: number,\n    element?: Element\n  ): void {\n    const effectiveHandler = debounceMs ? debounce(handler, debounceMs) : handler;\n    this.watch(scope, expr, effectiveHandler, element);\n  }\n\n  private watchAllScopes(scope: Scope, handler: () => void, debounceMs?: number, element?: Element): void {\n    const effectiveHandler = debounceMs ? debounce(handler, debounceMs) : handler;\n    let cursor: Scope | undefined = scope;\n    while (cursor) {\n      cursor.onAny(effectiveHandler);\n      if (element) {\n        this.trackScopeWatcher(element, cursor, \"any\", effectiveHandler);\n      }\n      cursor = cursor.parent;\n    }\n  }\n\n  private trackScopeWatcher(\n    element: Element,\n    scope: Scope,\n    kind: \"path\" | \"any\",\n    handler: () => void,\n    key?: string\n  ): void {\n    const watchers = this.scopeWatchers.get(element) ?? [];\n    watchers.push({ scope, kind, handler, ...(key ? { key } : {}) });\n    this.scopeWatchers.set(element, watchers);\n  }\n\n  private cleanupScopeWatchers(element: Element): void {\n    const watchers = this.scopeWatchers.get(element);\n    if (!watchers) {\n      return;\n    }\n    for (const watcher of watchers) {\n      if (watcher.kind === \"any\") {\n        watcher.scope.offAny(watcher.handler);\n        continue;\n      }\n      if (watcher.key) {\n        watcher.scope.off(watcher.key, watcher.handler);\n      }\n    }\n    this.scopeWatchers.delete(element);\n  }\n\n  private cleanupBehaviorListeners(element: Element): void {\n    const listenerMap = this.behaviorListeners.get(element);\n    if (!listenerMap) {\n      return;\n    }\n    for (const listeners of listenerMap.values()) {\n      for (const listener of listeners) {\n        listener.target.removeEventListener(listener.event, listener.handler, listener.options);\n      }\n    }\n    listenerMap.clear();\n    this.behaviorListeners.delete(element);\n    this.behaviorBindings.delete(element);\n  }\n\n  private parseOnAttribute(name: string, value: string): OnConfig | null {\n    if (!name.startsWith(\"vsn-on:\")) {\n      return null;\n    }\n\n    const eventWithFlags = name.slice(\"vsn-on:\".length);\n    const [event, ...flags] = eventWithFlags.split(\"!\");\n    if (!event) {\n      return null;\n    }\n    if (event.includes(\".\")) {\n      throw new Error(\"vsn:on does not support dot modifiers; use !flags instead\");\n    }\n\n    const { flagMap, flagArgs } = this.parseInlineFlags(flags);\n\n    const config: OnConfig = {\n      event,\n      code: value,\n      flags: flagMap,\n      flagArgs\n    };\n    return config;\n  }\n\n  private parseInlineFlags(parts: string[]): { flagMap: DeclarationFlags; flagArgs: DeclarationFlagArgs } {\n    const flagMap: DeclarationFlags = {};\n    const flagArgs: DeclarationFlagArgs = {};\n    for (const raw of parts) {\n      const trimmed = raw.trim();\n      if (!trimmed) {\n        continue;\n      }\n      const match = trimmed.match(/^([a-zA-Z][\\w-]*)(?:\\((.+)\\))?$/);\n      if (!match) {\n        continue;\n      }\n      const name = match[1] ?? \"\";\n      if (!name) {\n        continue;\n      }\n      if (!this.flagHandlers.has(name)) {\n        throw new Error(`Unknown flag ${name}`);\n      }\n      flagMap[name] = true;\n      if (match[2] !== undefined) {\n        flagArgs[name] = this.parseInlineFlagArg(match[2]);\n      }\n    }\n    return { flagMap, flagArgs };\n  }\n\n  private parseInlineFlagArg(raw: string): any {\n    const trimmed = raw.trim();\n    if (trimmed === \"true\") {\n      return true;\n    }\n    if (trimmed === \"false\") {\n      return false;\n    }\n    if (/^-?\\d+(\\.\\d+)?$/.test(trimmed)) {\n      return Number(trimmed);\n    }\n    return trimmed;\n  }\n\n  private describeElement(element: Element): string {\n    const tag = element.tagName.toLowerCase();\n    const id = element.id ? `#${element.id}` : \"\";\n    const classes = element.classList.length > 0 ? `.${Array.from(element.classList).join(\".\")}` : \"\";\n    return `${tag}${id}${classes}`;\n  }\n\n  private logDiagnostic(type: \"bind\" | \"unbind\", element: Element, behavior: RegisteredBehavior): void {\n    if (!this.diagnostics || !this.logger.info) {\n      return;\n    }\n    this.logger.info(`vsn:${type}`, {\n      element: this.describeElement(element),\n      selector: behavior.selector,\n      behaviorId: behavior.id\n    });\n  }\n\n  private emitError(element: Element, error: unknown): void {\n    const selector = this.describeElement(element);\n    this.logger.warn?.(\"vsn:error\", { error, selector });\n    element.dispatchEvent(\n      new CustomEvent(\"vsn:error\", {\n        detail: { error, selector },\n        bubbles: true\n      })\n    );\n  }\n\n  private emitUseError(name: string, error: unknown): void {\n    const selector = `use:${name}`;\n    this.logger.warn?.(\"vsn:error\", { error, selector });\n    const target = (globalThis as any).document;\n    if (target && typeof target.dispatchEvent === \"function\") {\n      target.dispatchEvent(\n        new CustomEvent(\"vsn:error\", {\n          detail: { error, selector },\n          bubbles: true\n        })\n      );\n    }\n  }\n\n  private attachOnHandler(element: Element, config: OnConfig): void {\n    const { listenerTarget, options, debounceMs } = this.getEventBindingConfig(\n      element,\n      config.flags,\n      config.flagArgs\n    );\n    let effectiveHandler: (event?: Event) => void;\n    const handler = async (event?: Event) => {\n      if (!element.isConnected) {\n        listenerTarget.removeEventListener(config.event, effectiveHandler, options);\n        return;\n      }\n      const scope = this.getScope(element);\n      if (!this.applyEventFlagBefore(element, scope, config.flags, config.flagArgs, event)) {\n        return;\n      }\n      try {\n        await this.execute(config.code, scope, element);\n        this.evaluate(element);\n      } catch (error) {\n        this.emitError(element, error);\n      } finally {\n        this.applyEventFlagAfter(element, scope, config.flags, config.flagArgs, event);\n      }\n    };\n    effectiveHandler = debounceMs ? debounce(handler, debounceMs) : handler;\n    listenerTarget.addEventListener(config.event, effectiveHandler, options);\n  }\n\n  private attachBehaviorOnHandler(\n    element: Element,\n    event: string,\n    body: BlockNode,\n    flags: DeclarationFlags,\n    flagArgs: DeclarationFlagArgs,\n    args: string[] | undefined,\n    behaviorId: number,\n    rootScope?: Scope\n  ): void {\n    if (event.includes(\".\")) {\n      throw new Error(\"vsn:on does not support dot modifiers; use !flags instead\");\n    }\n    const { listenerTarget, options, debounceMs } = this.getEventBindingConfig(element, flags, flagArgs);\n    const handler = async (evt?: Event) => {\n      const scope = this.getScope(element);\n      if (!this.applyEventFlagBefore(element, scope, flags, flagArgs, evt)) {\n        return;\n      }\n      const previousValues = new Map<string, any>();\n      if (args && args.length > 0) {\n        const argName = args[0];\n        if (argName) {\n          previousValues.set(argName, scope.getPath(argName));\n          const [nextArg] = this.applyEventFlagArgTransforms(element, scope, flags, flagArgs, evt);\n          scope.setPath(argName, nextArg);\n        }\n      }\n      let failed = false;\n      try {\n        await this.executeBlock(body, scope, element, rootScope);\n      } catch (error) {\n        failed = true;\n        this.emitError(element, error);\n      } finally {\n        for (const [name, value] of previousValues.entries()) {\n          scope.setPath(name, value);\n        }\n        this.applyEventFlagAfter(element, scope, flags, flagArgs, evt);\n      }\n      if (!failed) {\n        this.evaluate(element);\n      }\n    };\n    const effectiveHandler = debounceMs ? debounce(handler, debounceMs) : handler;\n    listenerTarget.addEventListener(event, effectiveHandler, options);\n    const listenerMap = this.behaviorListeners.get(element) ?? new Map<number, BehaviorListener[]>();\n    const listeners = listenerMap.get(behaviorId) ?? [];\n    listeners.push({ target: listenerTarget, event, handler: effectiveHandler, options });\n    listenerMap.set(behaviorId, listeners);\n    this.behaviorListeners.set(element, listenerMap);\n  }\n\n  private attachGetHandler(element: Element, autoLoad = false): void {\n    const handler = async () => {\n      const config = this.getBindings.get(element);\n      if (!config) {\n        return;\n      }\n      try {\n        await applyGet(element, config, this.getScope(element), (target) => {\n          this.handleHtmlBehaviors(target);\n        });\n      } catch (error) {\n        console.warn(\"vsn:getError\", error);\n        element.dispatchEvent(new CustomEvent(\"vsn:getError\", { detail: { error }, bubbles: true }));\n      }\n    };\n\n    element.addEventListener(\"click\", (event) => {\n      if (event.target !== element) {\n        return;\n      }\n      void handler();\n    });\n    if (autoLoad) {\n      Promise.resolve().then(handler);\n    }\n  }\n\n  private getEventBindingConfig(\n    element: Element,\n    flags: DeclarationFlags,\n    flagArgs: DeclarationFlagArgs\n  ): { listenerTarget: EventTarget; options?: AddEventListenerOptions; debounceMs?: number } {\n    let listenerTarget: EventTarget = element;\n    let options: AddEventListenerOptions = {};\n    let debounceMs: number | undefined;\n    for (const name of Object.keys(flags)) {\n      const handler = this.flagHandlers.get(name);\n      if (!handler?.onEventBind) {\n        continue;\n      }\n      const patch = handler.onEventBind({\n        name,\n        args: flagArgs[name],\n        element,\n        scope: this.getScope(element),\n        rootScope: undefined,\n        event: undefined,\n        engine: this\n      });\n      if (!patch) {\n        continue;\n      }\n      if (patch.listenerTarget) {\n        listenerTarget = patch.listenerTarget;\n      }\n      if (patch.options) {\n        options = { ...options, ...patch.options };\n      }\n      if (patch.debounceMs !== undefined) {\n        debounceMs = patch.debounceMs;\n      }\n    }\n    return {\n      listenerTarget,\n      ...(Object.keys(options).length > 0 ? { options } : {}),\n      ...(debounceMs !== undefined ? { debounceMs } : {})\n    };\n  }\n\n  private applyEventFlagBefore(\n    element: Element,\n    scope: Scope,\n    flags: DeclarationFlags,\n    flagArgs: DeclarationFlagArgs,\n    event?: Event\n  ): boolean {\n    for (const name of Object.keys(flags)) {\n      const handler = this.flagHandlers.get(name);\n      if (!handler?.onEventBefore) {\n        continue;\n      }\n      const result = handler.onEventBefore({\n        name,\n        args: flagArgs[name],\n        element,\n        scope,\n        rootScope: undefined,\n        event,\n        engine: this\n      });\n      if (result === false) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private applyEventFlagAfter(\n    element: Element,\n    scope: Scope,\n    flags: DeclarationFlags,\n    flagArgs: DeclarationFlagArgs,\n    event?: Event\n  ): void {\n    for (const name of Object.keys(flags)) {\n      const handler = this.flagHandlers.get(name);\n      if (!handler?.onEventAfter) {\n        continue;\n      }\n      handler.onEventAfter({\n        name,\n        args: flagArgs[name],\n        element,\n        scope,\n        rootScope: undefined,\n        event,\n        engine: this\n      });\n    }\n  }\n\n  private applyEventFlagArgTransforms(\n    element: Element,\n    scope: Scope,\n    flags: DeclarationFlags,\n    flagArgs: DeclarationFlagArgs,\n    event?: Event\n  ): any[] {\n    let args: any[] = [event];\n    for (const name of Object.keys(flags)) {\n      const handler = this.flagHandlers.get(name);\n      if (!handler?.transformEventArgs) {\n        continue;\n      }\n      const nextArgs = handler.transformEventArgs(\n        {\n          name,\n          args: flagArgs[name],\n          element,\n          scope,\n          rootScope: undefined,\n          event,\n          engine: this\n        },\n        args\n      );\n      if (Array.isArray(nextArgs)) {\n        args = nextArgs;\n      }\n    }\n    return args;\n  }\n\n  private matchesKeyFlag(event: Event | undefined, flag: string): boolean {\n    if (!(event instanceof KeyboardEvent)) {\n      return false;\n    }\n    const modifierChecks: Record<string, boolean> = {\n      shift: event.shiftKey,\n      ctrl: event.ctrlKey,\n      alt: event.altKey,\n      meta: event.metaKey\n    };\n    if (flag in modifierChecks) {\n      return modifierChecks[flag] ?? false;\n    }\n    const keyAliases: Record<string, string> = {\n      escape: \"escape\",\n      esc: \"escape\",\n      enter: \"enter\",\n      tab: \"tab\",\n      space: \"space\",\n      spacebar: \"space\",\n      up: \"arrowup\",\n      down: \"arrowdown\",\n      left: \"arrowleft\",\n      right: \"arrowright\",\n      arrowup: \"arrowup\",\n      arrowdown: \"arrowdown\",\n      arrowleft: \"arrowleft\",\n      arrowright: \"arrowright\",\n      delete: \"delete\",\n      backspace: \"backspace\"\n    };\n    let key = event.key?.toLowerCase() ?? \"\";\n    if (key === \" \") {\n      key = \"space\";\n    }\n    const expectedKey = keyAliases[flag] ?? flag;\n    return key === expectedKey;\n  }\n\n  private async withExecutionElement(element: Element | undefined, fn: () => Promise<void>): Promise<void> {\n    if (!element) {\n      await fn();\n      return;\n    }\n    this.executionStack.push(element);\n    try {\n      await fn();\n    } finally {\n      this.executionStack.pop();\n    }\n  }\n\n  getCurrentElement(): Element | undefined {\n    return this.executionStack[this.executionStack.length - 1];\n  }\n\n  private async execute(code: string, scope: Scope, element?: Element, rootScope?: Scope): Promise<void> {\n    let block = this.codeCache.get(code);\n    if (!block) {\n      block = Parser.parseInline(code);\n      this.codeCache.set(code, block);\n    }\n    await this.withExecutionElement(element, async () => {\n      const context: ExecutionContext = {\n        scope,\n        rootScope,\n        globals: this.globals,\n        ...(element ? { element } : {})\n      };\n      await block.evaluate(context);\n    });\n  }\n\n  private async executeBlock(block: BlockNode, scope: Scope, element?: Element, rootScope?: Scope): Promise<void> {\n    await this.withExecutionElement(element, async () => {\n      const context: ExecutionContext = {\n        scope,\n        rootScope,\n        globals: this.globals,\n        ...(element ? { element } : {})\n      };\n      await block.evaluate(context);\n    });\n  }\n\n  private async safeExecute(code: string, scope: Scope, element?: Element, rootScope?: Scope): Promise<void> {\n    try {\n      await this.execute(code, scope, element, rootScope);\n    } catch (error) {\n      if (element) {\n        this.emitError(element, error);\n      }\n    }\n  }\n\n  private async safeExecuteBlock(\n    block: BlockNode,\n    scope: Scope,\n    element?: Element,\n    rootScope?: Scope\n  ): Promise<void> {\n    try {\n      await this.executeBlock(block, scope, element, rootScope);\n    } catch (error) {\n      if (element) {\n        this.emitError(element, error);\n      }\n    }\n  }\n\n  private collectBehavior(behavior: BehaviorNode, parentSelector?: string, rootSelectorOverride?: string): void {\n    const selector = parentSelector\n      ? `${parentSelector} ${behavior.selector.selectorText}`\n      : behavior.selector.selectorText;\n    const rootSelector = rootSelectorOverride ?? (parentSelector ?? behavior.selector.selectorText);\n    const behaviorHash = this.hashBehavior(behavior);\n    const hash = `${selector}::${rootSelector}::${behaviorHash}`;\n    if (this.behaviorRegistryHashes.has(hash)) {\n      return;\n    }\n    const cached = this.getCachedBehavior(behavior);\n    const entry: RegisteredBehavior = {\n      id: this.behaviorId += 1,\n      hash,\n      selector,\n      rootSelector,\n      specificity: this.computeSpecificity(selector),\n      order: this.behaviorRegistry.length,\n      flags: behavior.flags ?? {},\n      flagArgs: behavior.flagArgs ?? {},\n      ...cached,\n      ...(parentSelector ? { parentSelector } : {})\n    };\n    this.behaviorRegistry.push(entry);\n    this.behaviorRegistryHashes.add(hash);\n    this.collectNestedBehaviors(behavior.body, selector, rootSelector);\n  }\n\n  private collectNestedBehaviors(block: BlockNode, parentSelector: string, rootSelector: string): void {\n    for (const statement of block.statements) {\n      if (statement instanceof BehaviorNode) {\n        this.collectBehavior(statement, parentSelector, rootSelector);\n        continue;\n      }\n      if (statement instanceof OnBlockNode) {\n        this.collectNestedBehaviors(statement.body, parentSelector, rootSelector);\n        continue;\n      }\n      if (statement instanceof BlockNode) {\n        this.collectNestedBehaviors(statement, parentSelector, rootSelector);\n      }\n    }\n  }\n\n  private computeSpecificity(selector: string): number {\n    const idMatches = selector.match(/#[\\w-]+/g)?.length ?? 0;\n    const classMatches = selector.match(/\\.[\\w-]+/g)?.length ?? 0;\n    const attrMatches = selector.match(/\\[[^\\]]+\\]/g)?.length ?? 0;\n    const pseudoMatches = selector.match(/:[\\w-]+/g)?.length ?? 0;\n    const elementMatches = selector.match(/(^|[\\s>+~])([a-zA-Z][\\w-]*)/g)?.length ?? 0;\n    return idMatches * 100 + (classMatches + attrMatches + pseudoMatches) * 10 + elementMatches;\n  }\n\n  private getBehaviorRootScope(element: Element, behavior: RegisteredBehavior): Scope {\n    const rootElement = element.closest(behavior.rootSelector) ?? element;\n    return this.getScope(rootElement);\n  }\n\n\n  private getImportantKey(declaration: DeclarationNode): string | undefined {\n    if (declaration.target instanceof IdentifierExpression) {\n      return `state:${declaration.target.name}`;\n    }\n    if (declaration.target instanceof DirectiveExpression) {\n      return `${declaration.target.kind}:${declaration.target.name}`;\n    }\n    return undefined;\n  }\n\n  private isImportant(element: Element, key: string): boolean {\n    const set = this.importantFlags.get(element);\n    return set ? set.has(key) : false;\n  }\n\n  private markImportant(element: Element, key: string): void {\n    const set = this.importantFlags.get(element) ?? new Set<string>();\n    set.add(key);\n    this.importantFlags.set(element, set);\n  }\n\n  private extractLifecycle(body: BlockNode): { construct?: BlockNode; destruct?: BlockNode } {\n    let construct: BlockNode | undefined;\n    let destruct: BlockNode | undefined;\n    for (const statement of body.statements) {\n      if (!(statement instanceof BlockNode)) {\n        continue;\n      }\n      if (statement.type === \"Construct\") {\n        construct = statement;\n      } else if (statement.type === \"Destruct\") {\n        destruct = statement;\n      }\n    }\n    return {\n      ...(construct ? { construct } : {}),\n      ...(destruct ? { destruct } : {})\n    };\n  }\n\n  private extractOnBlocks(\n    body: BlockNode\n  ): { event: string; body: BlockNode; flags: DeclarationFlags; flagArgs: DeclarationFlagArgs; args: string[] }[] {\n    const blocks: { event: string; body: BlockNode; flags: DeclarationFlags; flagArgs: DeclarationFlagArgs; args: string[] }[] = [];\n    for (const statement of body.statements) {\n      if (statement instanceof OnBlockNode) {\n        blocks.push({\n          event: statement.eventName,\n          body: statement.body,\n          flags: statement.flags,\n          flagArgs: statement.flagArgs,\n          args: statement.args\n        });\n      }\n    }\n    return blocks;\n  }\n\n  private extractDeclarations(body: BlockNode): DeclarationNode[] {\n    const declarations: DeclarationNode[] = [];\n    for (const statement of body.statements) {\n      if (statement instanceof DeclarationNode) {\n        declarations.push(statement);\n      }\n    }\n    return declarations;\n  }\n\n  private extractFunctionDeclarations(body: BlockNode): FunctionBinding[] {\n    const functions: FunctionBinding[] = [];\n    for (const statement of body.statements) {\n      if (statement instanceof FunctionDeclarationNode) {\n        functions.push({ name: statement.name, params: statement.params, body: statement.body });\n        continue;\n      }\n      if (statement instanceof AssignmentNode) {\n        if (statement.target instanceof IdentifierExpression && statement.value instanceof FunctionExpression) {\n          functions.push({\n            name: statement.target.name,\n            params: statement.value.params,\n            body: statement.value.body\n          });\n        }\n      }\n    }\n    return functions;\n  }\n\n  private getCachedBehavior(behavior: BehaviorNode): CachedBehavior {\n    const hash = this.hashBehavior(behavior);\n    const cached = this.behaviorCache.get(hash);\n    if (cached) {\n      return cached;\n    }\n    const lifecycle = this.extractLifecycle(behavior.body);\n    const fresh: CachedBehavior = {\n      onBlocks: this.extractOnBlocks(behavior.body),\n      declarations: this.extractDeclarations(behavior.body),\n      functions: this.extractFunctionDeclarations(behavior.body),\n      ...lifecycle\n    };\n    this.behaviorCache.set(hash, fresh);\n    return fresh;\n  }\n\n  private hashBehavior(behavior: BehaviorNode): string {\n    const normalized = this.normalizeNode(behavior);\n    const json = JSON.stringify(normalized);\n    return this.hashString(json);\n  }\n\n  private normalizeNode(node: any): any {\n    if (!node || typeof node !== \"object\") {\n      return node;\n    }\n    const type = node.type ?? \"Unknown\";\n    if (type === \"Behavior\") {\n      return {\n        type,\n        selector: node.selector?.selectorText ?? \"\",\n        flags: node.flags ?? {},\n        flagArgs: node.flagArgs ?? {},\n        body: this.normalizeNode(node.body)\n      };\n    }\n    if (type === \"Selector\") {\n      return { type, selectorText: node.selectorText ?? \"\" };\n    }\n    if (type === \"Block\" || type === \"Construct\" || type === \"Destruct\") {\n      return {\n        type,\n        statements: Array.isArray(node.statements)\n          ? node.statements.map((statement: any) => this.normalizeNode(statement))\n          : []\n      };\n    }\n    if (type === \"OnBlock\") {\n      return {\n        type,\n        eventName: node.eventName ?? \"\",\n        args: Array.isArray(node.args) ? node.args : [],\n        flags: node.flags ?? {},\n        flagArgs: node.flagArgs ?? {},\n        body: this.normalizeNode(node.body)\n      };\n    }\n    if (type === \"Declaration\") {\n      return {\n        type,\n        target: this.normalizeNode(node.target),\n        operator: node.operator ?? \"\",\n        value: this.normalizeNode(node.value),\n        flags: node.flags ?? {},\n        flagArgs: node.flagArgs ?? {}\n      };\n    }\n    if (type === \"Assignment\") {\n      return {\n        type,\n        target: this.normalizeNode(node.target),\n        value: this.normalizeNode(node.value),\n        operator: node.operator ?? \"\",\n        prefix: Boolean(node.prefix)\n      };\n    }\n    if (type === \"FunctionDeclaration\") {\n      return {\n        type,\n        name: node.name ?? \"\",\n        params: Array.isArray(node.params)\n          ? node.params.map((param: any) => ({\n            name: param?.name ?? \"\",\n            rest: Boolean(param?.rest),\n            defaultValue: this.normalizeNode(param?.defaultValue ?? null)\n          }))\n          : [],\n        body: this.normalizeNode(node.body),\n        isAsync: Boolean(node.isAsync)\n      };\n    }\n    if (type === \"FunctionExpression\") {\n      return {\n        type,\n        params: Array.isArray(node.params)\n          ? node.params.map((param: any) => ({\n            name: param?.name ?? \"\",\n            rest: Boolean(param?.rest),\n            defaultValue: this.normalizeNode(param?.defaultValue ?? null)\n          }))\n          : [],\n        body: this.normalizeNode(node.body),\n        isAsync: Boolean(node.isAsync)\n      };\n    }\n    if (type === \"Return\") {\n      return {\n        type,\n        value: this.normalizeNode(node.value ?? null)\n      };\n    }\n    if (type === \"Assert\") {\n      return {\n        type,\n        test: this.normalizeNode(node.test)\n      };\n    }\n    if (type === \"Break\" || type === \"Continue\") {\n      return { type };\n    }\n    if (type === \"If\") {\n      return {\n        type,\n        test: this.normalizeNode(node.test),\n        consequent: this.normalizeNode(node.consequent),\n        alternate: this.normalizeNode(node.alternate ?? null)\n      };\n    }\n    if (type === \"While\") {\n      return {\n        type,\n        test: this.normalizeNode(node.test),\n        body: this.normalizeNode(node.body)\n      };\n    }\n    if (type === \"For\") {\n      return {\n        type,\n        init: this.normalizeNode(node.init ?? null),\n        test: this.normalizeNode(node.test ?? null),\n        update: this.normalizeNode(node.update ?? null),\n        body: this.normalizeNode(node.body)\n      };\n    }\n    if (type === \"ForEach\") {\n      return {\n        type,\n        kind: node.kind ?? \"of\",\n        target: this.normalizeNode(node.target),\n        iterable: this.normalizeNode(node.iterable),\n        body: this.normalizeNode(node.body)\n      };\n    }\n    if (type === \"Try\") {\n      return {\n        type,\n        errorName: node.errorName ?? \"\",\n        body: this.normalizeNode(node.body),\n        handler: this.normalizeNode(node.handler)\n      };\n    }\n    if (type === \"Identifier\") {\n      return { type, name: node.name ?? \"\" };\n    }\n    if (type === \"Literal\") {\n      return { type, value: node.value };\n    }\n    if (type === \"TemplateExpression\") {\n      return {\n        type,\n        parts: Array.isArray(node.parts) ? node.parts.map((part: any) => this.normalizeNode(part)) : []\n      };\n    }\n    if (type === \"UnaryExpression\") {\n      return {\n        type,\n        operator: node.operator ?? \"\",\n        argument: this.normalizeNode(node.argument)\n      };\n    }\n    if (type === \"BinaryExpression\") {\n      return {\n        type,\n        operator: node.operator ?? \"\",\n        left: this.normalizeNode(node.left),\n        right: this.normalizeNode(node.right)\n      };\n    }\n    if (type === \"TernaryExpression\") {\n      return {\n        type,\n        test: this.normalizeNode(node.test),\n        consequent: this.normalizeNode(node.consequent),\n        alternate: this.normalizeNode(node.alternate)\n      };\n    }\n    if (type === \"MemberExpression\") {\n      return {\n        type,\n        target: this.normalizeNode(node.target),\n        property: node.property ?? \"\",\n        optional: Boolean(node.optional)\n      };\n    }\n    if (type === \"CallExpression\") {\n      return {\n        type,\n        callee: this.normalizeNode(node.callee),\n        args: Array.isArray(node.args) ? node.args.map((arg: any) => this.normalizeNode(arg)) : []\n      };\n    }\n    if (type === \"AwaitExpression\") {\n      return {\n        type,\n        argument: this.normalizeNode(node.argument)\n      };\n    }\n    if (type === \"Directive\") {\n      return { type, kind: node.kind ?? \"\", name: node.name ?? \"\" };\n    }\n    if (type === \"Query\") {\n      return { type, direction: node.direction ?? \"\", selector: node.selector ?? \"\" };\n    }\n    if (type === \"ArrayExpression\") {\n      return {\n        type,\n        elements: Array.isArray(node.elements)\n          ? node.elements.map((element: any) => this.normalizeNode(element))\n          : []\n      };\n    }\n    if (type === \"ObjectExpression\") {\n      return {\n        type,\n        entries: Array.isArray(node.entries)\n          ? node.entries.map((entry: any) => ({\n              key: entry?.key ?? \"\",\n              computed: Boolean(entry?.computed),\n              keyExpr: entry?.keyExpr ? this.normalizeNode(entry.keyExpr) : null,\n              value: this.normalizeNode(entry?.value)\n            }))\n          : []\n      };\n    }\n    if (type === \"IndexExpression\") {\n      return {\n        type,\n        target: this.normalizeNode(node.target),\n        index: this.normalizeNode(node.index)\n      };\n    }\n    return { type };\n  }\n\n  private hashString(value: string): string {\n    let hash = 5381;\n    for (let i = 0; i < value.length; i += 1) {\n      hash = ((hash << 5) + hash) + value.charCodeAt(i);\n      hash |= 0;\n    }\n    return (hash >>> 0).toString(16);\n  }\n\n  private applyBehaviorFunctions(\n    element: Element,\n    scope: Scope,\n    functions: FunctionBinding[],\n    rootScope?: Scope\n  ): void {\n    for (const declaration of functions) {\n      this.applyBehaviorFunction(element, scope, declaration, rootScope);\n    }\n  }\n\n  private applyBehaviorFunction(\n    element: Element,\n    scope: Scope,\n    declaration: FunctionBinding,\n    rootScope?: Scope\n  ): void {\n    const existing = scope.getPath(declaration.name);\n    if (existing !== undefined && typeof existing !== \"function\") {\n      throw new Error(`Cannot override non-function '${declaration.name}' with a function`);\n    }\n    const fn = async (...args: any[]) => {\n      const callScope = scope.createChild ? scope.createChild() : scope;\n      const context: ExecutionContext = {\n        scope: callScope,\n        rootScope: rootScope ?? callScope,\n        globals: this.globals,\n        element,\n        returnValue: undefined,\n        returning: false,\n        breaking: false,\n        continuing: false\n      };\n      const previousValues = new Map<string, any>();\n      await this.applyFunctionParams(callScope, declaration.params, previousValues, context, args);\n      await declaration.body.evaluate(context);\n      if (callScope === scope) {\n        this.restoreFunctionParams(callScope, declaration.params, previousValues);\n      }\n      return context.returnValue;\n    };\n    scope.setPath(declaration.name, fn);\n  }\n\n  private async applyFunctionParams(\n    scope: Scope,\n    params: FunctionParam[],\n    previousValues: Map<string, any>,\n    context: ExecutionContext,\n    args: any[]\n  ): Promise<void> {\n    let argIndex = 0;\n    for (const param of params) {\n      const name = param.name;\n      if (!name) {\n        continue;\n      }\n      previousValues.set(name, scope.getPath(name));\n      if (param.rest) {\n        scope.setPath(`self.${name}`, args.slice(argIndex));\n        argIndex = args.length;\n        continue;\n      }\n      let value = args[argIndex];\n      if (value === undefined && param.defaultValue) {\n        value = await param.defaultValue.evaluate(context);\n      }\n      scope.setPath(`self.${name}`, value);\n      argIndex += 1;\n    }\n  }\n\n  private restoreFunctionParams(\n    scope: Scope,\n    params: FunctionParam[],\n    previousValues: Map<string, any>\n  ): void {\n    for (const param of params) {\n      const name = param.name;\n      if (!name) {\n        continue;\n      }\n      scope.setPath(name, previousValues.get(name));\n    }\n  }\n\n  private async applyBehaviorDeclarations(\n    element: Element,\n    scope: Scope,\n    declarations: DeclarationNode[],\n    rootScope?: Scope\n  ): Promise<void> {\n    for (const declaration of declarations) {\n      await this.applyBehaviorDeclaration(element, scope, declaration, rootScope);\n    }\n  }\n\n  private async applyBehaviorDeclaration(\n    element: Element,\n    scope: Scope,\n    declaration: DeclarationNode,\n    rootScope?: Scope\n  ): Promise<void> {\n    const context: ExecutionContext = { scope, rootScope, element };\n    const operator = declaration.operator;\n    const debounceMs = declaration.flags.debounce\n      ? declaration.flagArgs.debounce ?? 200\n      : undefined;\n    const transform = (value: any) => this.applyCustomFlagTransforms(value, element, scope, declaration);\n    const importantKey = this.getImportantKey(declaration);\n    if (!declaration.flags.important && importantKey && this.isImportant(element, importantKey)) {\n      return;\n    }\n    if (importantKey && this.isInlineDeclaration(element, importantKey)) {\n      return;\n    }\n    this.applyCustomFlags(element, scope, declaration);\n\n    if (declaration.target instanceof IdentifierExpression) {\n      const value = await declaration.value.evaluate(context);\n      const transformed = this.applyCustomFlagTransforms(value, element, scope, declaration);\n      scope.setPath(declaration.target.name, transformed);\n      if (declaration.flags.important && importantKey) {\n        this.markImportant(element, importantKey);\n      }\n      return;\n    }\n\n    if (!(declaration.target instanceof DirectiveExpression)) {\n      return;\n    }\n\n    const target = declaration.target;\n    const exprIdentifier =\n      declaration.value instanceof IdentifierExpression ? declaration.value.name : undefined;\n\n    if (operator === \":>\") {\n      if (exprIdentifier) {\n        this.applyDirectiveToScope(element, target, exprIdentifier, scope, debounceMs, rootScope, transform);\n      }\n      if (declaration.flags.important && importantKey) {\n        this.markImportant(element, importantKey);\n      }\n      return;\n    }\n\n    if (operator === \":=\" && exprIdentifier) {\n      this.applyDirectiveToScope(element, target, exprIdentifier, scope, debounceMs, rootScope, transform);\n    }\n\n    if (!exprIdentifier) {\n      const value = await declaration.value.evaluate(context);\n      const transformed = this.applyCustomFlagTransforms(value, element, scope, declaration);\n      this.setDirectiveValue(element, target, transformed);\n      const shouldWatch = operator === \":<\" || operator === \":=\";\n      if (shouldWatch) {\n        this.applyDirectiveFromExpression(\n          element,\n          target,\n          declaration.value,\n          scope,\n          debounceMs,\n          rootScope\n        );\n      }\n      if (declaration.flags.important && importantKey) {\n        this.markImportant(element, importantKey);\n      }\n      return;\n    }\n\n    const shouldWatch = operator === \":<\" || operator === \":=\";\n    this.applyDirectiveFromScope(\n      element,\n      target,\n      exprIdentifier,\n      scope,\n      debounceMs,\n      shouldWatch,\n      rootScope\n    );\n    if (declaration.flags.important && importantKey) {\n      this.markImportant(element, importantKey);\n    }\n  }\n\n  private applyCustomFlags(element: Element, scope: Scope, declaration: DeclarationNode): void {\n    if (this.flagHandlers.size === 0) {\n      return;\n    }\n    for (const [name, handler] of this.flagHandlers) {\n      if (!declaration.flags[name]) {\n        continue;\n      }\n      handler.onApply?.({\n        name,\n        args: declaration.flagArgs[name],\n        element,\n        scope,\n        declaration\n      });\n    }\n  }\n\n  private applyCustomFlagTransforms(\n    value: any,\n    element: Element,\n    scope: Scope,\n    declaration: DeclarationNode\n  ): any {\n    if (this.flagHandlers.size === 0) {\n      return value;\n    }\n    let nextValue = value;\n    for (const [name, handler] of this.flagHandlers) {\n      if (!declaration.flags[name] || !handler.transformValue) {\n        continue;\n      }\n      nextValue = handler.transformValue(\n        {\n          name,\n          args: declaration.flagArgs[name],\n          element,\n          scope,\n          declaration\n        },\n        nextValue\n      );\n    }\n    return nextValue;\n  }\n\n  private async applyBehaviorModifierHook(\n    hook: keyof BehaviorModifierHandler,\n    behavior: RegisteredBehavior,\n    element: Element,\n    scope: Scope,\n    rootScope?: Scope\n  ): Promise<void> {\n    if (this.behaviorModifiers.size === 0) {\n      return;\n    }\n    for (const [name, handler] of this.behaviorModifiers) {\n      if (!behavior.flags?.[name]) {\n        continue;\n      }\n      const callback = handler[hook];\n      if (!callback) {\n        continue;\n      }\n      await callback({\n        name,\n        args: behavior.flagArgs?.[name],\n        element,\n        scope,\n        rootScope,\n        behavior,\n        engine: this\n      });\n    }\n  }\n\n  private behaviorHasModifierHooks(behavior: RegisteredBehavior): boolean {\n    if (this.behaviorModifiers.size === 0) {\n      return false;\n    }\n    const flags = behavior.flags ?? {};\n    for (const name of Object.keys(flags)) {\n      if (flags[name] && this.behaviorModifiers.has(name)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private applyDirectiveFromScope(\n    element: Element,\n    target: DirectiveExpression,\n    expr: string,\n    scope: Scope,\n    debounceMs?: number,\n    watch = true,\n    rootScope?: Scope\n  ): void {\n    if (target.kind === \"attr\" && target.name === \"html\" && element instanceof HTMLElement) {\n      const handler = () => {\n        const useRoot = expr.startsWith(\"root.\") && rootScope;\n        const sourceScope = useRoot ? rootScope : scope;\n        const localExpr = useRoot ? `self.${expr.slice(\"root.\".length)}` : expr;\n        applyHtml(element, localExpr, sourceScope);\n      };\n      handler();\n      this.handleHtmlBehaviors(element);\n      if (watch) {\n        const useRoot = expr.startsWith(\"root.\") && rootScope;\n        const sourceScope = useRoot ? rootScope : scope;\n        const watchExpr = useRoot ? expr.slice(\"root.\".length) : expr;\n        this.watchWithDebounce(sourceScope, watchExpr, handler, debounceMs, element);\n      }\n      return;\n    }\n    const handler = () => {\n      const useRoot = expr.startsWith(\"root.\") && rootScope;\n      const sourceScope = useRoot ? rootScope : scope;\n      const localExpr = useRoot ? `self.${expr.slice(\"root.\".length)}` : expr;\n      const value = sourceScope.get(localExpr);\n      if (value == null) {\n        return;\n      }\n      this.setDirectiveValue(element, target, value);\n    };\n    handler();\n    if (watch) {\n      const useRoot = expr.startsWith(\"root.\") && rootScope;\n      const sourceScope = useRoot ? rootScope : scope;\n      const watchExpr = useRoot ? expr.slice(\"root.\".length) : expr;\n      this.watchWithDebounce(sourceScope, watchExpr, handler, debounceMs, element);\n    }\n  }\n\n  private applyDirectiveFromExpression(\n    element: Element,\n    target: DirectiveExpression,\n    expr: ExpressionNode,\n    scope: Scope,\n    debounceMs?: number,\n    rootScope?: Scope\n  ): void {\n    const handler = async () => {\n      const context: ExecutionContext = { scope, rootScope, element };\n      const value = await expr.evaluate(context);\n      this.setDirectiveValue(element, target, value);\n    };\n    void handler();\n    this.watchAllScopes(scope, () => {\n      void handler();\n    }, debounceMs, element);\n  }\n\n  private applyDirectiveToScope(\n    element: Element,\n    target: DirectiveExpression,\n    expr: string,\n    scope: Scope,\n    debounceMs?: number,\n    rootScope?: Scope,\n    transform?: (value: any) => any\n  ): void {\n    const useRoot = expr.startsWith(\"root.\") && rootScope;\n    const targetScope = useRoot ? rootScope : scope;\n    const targetExpr = useRoot ? `self.${expr.slice(\"root.\".length)}` : expr;\n    if (target.kind === \"attr\" && target.name === \"value\") {\n      this.applyValueBindingToScope(element, targetExpr, debounceMs, targetScope, transform);\n      return;\n    }\n    if (target.kind === \"attr\" && target.name === \"checked\") {\n      this.applyCheckedBindingToScope(element, targetExpr, debounceMs, targetScope, transform);\n      return;\n    }\n    const value = this.getDirectiveValue(element, target);\n    if (value != null) {\n      const nextValue = transform ? transform(value) : value;\n      targetScope.set(targetExpr, nextValue);\n    }\n  }\n\n  private applyCheckedBindingToScope(\n    element: Element,\n    expr: string,\n    debounceMs?: number,\n    scope?: Scope,\n    transform?: (value: any) => any\n  ): void {\n    if (!(element instanceof HTMLInputElement)) {\n      return;\n    }\n    const handler = () => {\n      const targetScope = scope ?? this.getScope(element);\n      const value = transform ? transform(element.checked) : element.checked;\n      targetScope.set(expr, value);\n    };\n    const effectiveHandler = debounceMs ? debounce(handler, debounceMs) : handler;\n    effectiveHandler();\n    element.addEventListener(\"change\", effectiveHandler);\n    element.addEventListener(\"input\", effectiveHandler);\n  }\n\n  private applyValueBindingToScope(\n    element: Element,\n    expr: string,\n    debounceMs?: number,\n    scope?: Scope,\n    transform?: (value: any) => any\n  ): void {\n    if (!(element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement)) {\n      return;\n    }\n    const handler = () => {\n      const targetScope = scope ?? this.getScope(element);\n      const value = element.value;\n      const nextValue = transform ? transform(value) : value;\n      targetScope.set(expr, nextValue);\n    };\n    const effectiveHandler = debounceMs ? debounce(handler, debounceMs) : handler;\n    effectiveHandler();\n    element.addEventListener(\"input\", effectiveHandler);\n    element.addEventListener(\"change\", effectiveHandler);\n  }\n\n  private setDirectiveValue(\n    element: Element,\n    target: DirectiveExpression,\n    value: unknown\n  ): void {\n    if (target.kind === \"attr\" && target.name === \"html\" && element instanceof HTMLElement) {\n      const html = value == null ? \"\" : String(value);\n      element.innerHTML = html;\n      this.handleHtmlBehaviors(element);\n      return;\n    }\n    if (target.kind === \"attr\") {\n      if (target.name === \"text\" && element instanceof HTMLElement) {\n        element.innerText = value == null ? \"\" : String(value);\n        return;\n      }\n      if (target.name === \"content\" && element instanceof HTMLElement) {\n        element.textContent = value == null ? \"\" : String(value);\n        return;\n      }\n      if (target.name === \"value\") {\n        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n          element.value = value == null ? \"\" : String(value);\n          element.setAttribute(\"value\", element.value);\n          return;\n        }\n        if (element instanceof HTMLSelectElement) {\n          element.value = value == null ? \"\" : String(value);\n          return;\n        }\n      }\n      if (target.name === \"checked\" && element instanceof HTMLInputElement) {\n        const checked = value === true || value === \"true\" || value === 1 || value === \"1\";\n        element.checked = checked;\n        if (checked) {\n          element.setAttribute(\"checked\", \"\");\n        } else {\n          element.removeAttribute(\"checked\");\n        }\n        return;\n      }\n      element.setAttribute(target.name, value == null ? \"\" : String(value));\n      return;\n    }\n    if (target.kind === \"style\" && element instanceof HTMLElement) {\n      element.style.setProperty(target.name, value == null ? \"\" : String(value));\n    }\n  }\n\n  private getDirectiveValue(element: Element, target: DirectiveExpression): unknown {\n    if (target.kind === \"attr\") {\n      if (target.name === \"text\" && element instanceof HTMLElement) {\n        return element.innerText;\n      }\n      if (target.name === \"content\" && element instanceof HTMLElement) {\n        return element.textContent ?? \"\";\n      }\n      if (target.name === \"value\") {\n        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n          return element.value;\n        }\n        if (element instanceof HTMLSelectElement) {\n          return element.value;\n        }\n      }\n      if (target.name === \"checked\" && element instanceof HTMLInputElement) {\n        return element.checked;\n      }\n      return element.getAttribute(target.name) ?? undefined;\n    }\n    if (target.kind === \"style\" && element instanceof HTMLElement) {\n      return element.style.getPropertyValue(target.name) ?? undefined;\n    }\n    return undefined;\n  }\n\n  private handleHtmlBehaviors(root: Element): void {\n    const scripts = Array.from(root.querySelectorAll('script[type=\"text/vsn\"]'));\n    if (scripts.length === 0) {\n      return;\n    }\n    const source = scripts.map((script) => script.textContent ?? \"\").join(\"\\n\");\n    if (!source.trim()) {\n      return;\n    }\n    this.registerBehaviors(source);\n    void this.applyBehaviors(root);\n  }\n\n  private registerDefaultAttributeHandlers(): void {\n    this.registerAttributeHandler({\n      id: \"vsn-bind\",\n      match: (name) => name.startsWith(\"vsn-bind\"),\n      handle: (element, name, value, scope) => {\n        const parsedDirection = this.parseBindDirection(name);\n        const config = this.resolveBindConfig(element, value, scope, parsedDirection);\n        const direction = config.direction;\n        const auto = parsedDirection === \"auto\";\n        this.bindBindings.set(element, { expr: value, direction, auto });\n        if (!auto && (direction === \"to\" || direction === \"both\")) {\n          this.markInlineDeclaration(element, `state:${value}`);\n        }\n        if (config.seedFromScope) {\n          applyBindToElement(element, value, scope);\n        }\n        if (config.deferToScope) {\n          this.pendingAutoBindToScope.push({ element, expr: value, scope });\n        } else if (config.syncToScope) {\n          applyBindToScope(element, value, scope);\n        }\n        if (direction === \"to\" || direction === \"both\") {\n          this.attachBindInputHandler(element, value);\n        }\n        if (direction === \"from\" || direction === \"both\") {\n          this.watch(scope, value, () => applyBindToElement(element, value, scope), element);\n        }\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-if\",\n      match: (name) => name === \"vsn-if\",\n      handle: (element, _name, value, scope) => {\n        this.ifBindings.set(element, value);\n        if (element instanceof HTMLElement) {\n          applyIf(element, value, scope);\n        }\n        this.watch(scope, value, () => this.evaluate(element), element);\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-show\",\n      match: (name) => name === \"vsn-show\",\n      handle: (element, _name, value, scope) => {\n        this.showBindings.set(element, value);\n        if (element instanceof HTMLElement) {\n          applyShow(element, value, scope);\n        }\n        this.watch(scope, value, () => this.evaluate(element), element);\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-html\",\n      match: (name) => name.startsWith(\"vsn-html\"),\n      handle: (element, _name, value, scope) => {\n        this.htmlBindings.set(element, { expr: value });\n        this.markInlineDeclaration(element, \"attr:html\");\n        if (element instanceof HTMLElement) {\n          applyHtml(element, value, scope);\n          this.handleHtmlBehaviors(element);\n        }\n        this.watch(scope, value, () => this.evaluate(element), element);\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-each\",\n      match: (name) => name === \"vsn-each\",\n      handle: (element, _name, value, scope) => {\n        const config = this.parseEachExpression(value);\n        if (!config) {\n          return;\n        }\n        this.eachBindings.set(element, { ...config, rendered: [] });\n        this.renderEach(element);\n        this.watch(scope, config.listExpr, () => this.renderEach(element), element);\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-get\",\n      match: (name) => name.startsWith(\"vsn-get\"),\n      handle: (element, name) => {\n        const autoLoad = name.includes(\"!load\");\n        const url = element.getAttribute(name) ?? \"\";\n        const target = element.getAttribute(\"vsn-target\") ?? undefined;\n        const swap = (element.getAttribute(\"vsn-swap\") as \"inner\" | \"outer\" | null) ?? \"inner\";\n        const config: GetConfig = {\n          url,\n          swap,\n          ...(target ? { targetSelector: target } : {})\n        };\n        this.getBindings.set(element, config);\n        this.attachGetHandler(element, autoLoad);\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-construct\",\n      match: (name) => name === \"vsn-construct\",\n      handle: (element, _name, value) => {\n        this.setLifecycle(element, { construct: value });\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-destruct\",\n      match: (name) => name === \"vsn-destruct\",\n      handle: (element, _name, value) => {\n        this.setLifecycle(element, { destruct: value });\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-on\",\n      match: (name) => name.startsWith(\"vsn-on:\"),\n      handle: (element, name, value) => {\n        const onConfig = this.parseOnAttribute(name, value);\n        if (onConfig) {\n          this.attachOnHandler(element, onConfig);\n        }\n      }\n    });\n  }\n}\n","export const VERSION = \"0.1.0\";\n\nexport { Lexer } from \"./parser/lexer\";\nimport { Parser } from \"./parser/parser\";\nimport { Engine } from \"./runtime/engine\";\nexport { Parser };\nexport { TokenType } from \"./parser/token\";\nexport * from \"./ast/nodes\";\nexport { Engine } from \"./runtime/engine\";\n\nexport function parseCFS(source: string) {\n  const parser = new Parser(source);\n  return parser.parseProgram();\n}\n\nif (typeof window !== \"undefined\") {\n  (window as any)[\"parseCFS\"] = parseCFS;\n}\n\nexport function autoMount(root: HTMLElement | Document = document): Engine | null {\n  if (typeof document === \"undefined\") {\n    return null;\n  }\n  const engine = new Engine();\n  (globalThis as any).VSNEngine = engine;\n  const startTime = typeof performance !== \"undefined\" && performance.now ? performance.now() : Date.now();\n  const mount = () => {\n    const target = root instanceof Document ? root.body : root;\n    if (target) {\n      const plugins = (globalThis as any).VSNPlugins;\n      if (plugins && typeof plugins === \"object\") {\n        for (const plugin of Object.values(plugins)) {\n          if (typeof plugin === \"function\") {\n            plugin(engine);\n          }\n        }\n      }\n      const sources = Array.from(document.querySelectorAll('script[type=\"text/vsn\"]'))\n        .map((script) => script.textContent ?? \"\")\n        .join(\"\\n\");\n      if (sources.trim()) {\n        engine.registerBehaviors(sources);\n      }\n      engine.mount(target);\n      const endTime = typeof performance !== \"undefined\" && performance.now ? performance.now() : Date.now();\n      const elapsedMs = Math.round(endTime - startTime);\n      console.log(`Took ${elapsedMs}ms to start up VSN.js. https://www.vsnjs.com/ v${VERSION}`);\n    }\n  };\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", () => setTimeout(mount, 0), { once: true });\n  } else {\n    setTimeout(mount, 0);\n  }\n  return engine;\n}\n\nif (typeof document !== \"undefined\") {\n  const scriptTag = document.querySelector(\"script[auto-mount]\");\n  if (scriptTag) {\n    autoMount();\n  }\n}\n"],"mappings":"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","names":["TokenType","value","targetPath","target","body","name","shouldWatch","handler"]}