{"version":3,"sources":["../src/parser/token.ts","../src/parser/lexer.ts","../src/ast/nodes.ts","../src/parser/token-stream.ts","../src/parser/parser.ts","../src/index.ts"],"sourcesContent":["export enum TokenType {\n  Whitespace = \"Whitespace\",\n  Identifier = \"Identifier\",\n  Number = \"Number\",\n  String = \"String\",\n  Boolean = \"Boolean\",\n  Null = \"Null\",\n\n  Behavior = \"Behavior\",\n  State = \"State\",\n  On = \"On\",\n\n  LBrace = \"LBrace\",\n  RBrace = \"RBrace\",\n  LParen = \"LParen\",\n  RParen = \"RParen\",\n  LBracket = \"LBracket\",\n  RBracket = \"RBracket\",\n\n  Colon = \"Colon\",\n  Semicolon = \"Semicolon\",\n  Comma = \"Comma\",\n\n  Dot = \"Dot\",\n  Hash = \"Hash\",\n  Greater = \"Greater\",\n  Less = \"Less\",\n  Plus = \"Plus\",\n  Tilde = \"Tilde\",\n  Star = \"Star\",\n\n  Equals = \"Equals\",\n  Bang = \"Bang\",\n\n  At = \"At\",\n  Dollar = \"Dollar\",\n  Question = \"Question\"\n}\n\nexport interface Position {\n  index: number;\n  line: number;\n  column: number;\n}\n\nexport interface Token {\n  type: TokenType;\n  value: string;\n  start: Position;\n  end: Position;\n}\n","import { Token, TokenType } from \"./token\";\n\nconst KEYWORDS: Record<string, TokenType> = {\n  behavior: TokenType.Behavior,\n  state: TokenType.State,\n  on: TokenType.On,\n  true: TokenType.Boolean,\n  false: TokenType.Boolean,\n  null: TokenType.Null\n};\n\nexport class Lexer {\n  private index = 0;\n  private line = 1;\n  private column = 1;\n\n  constructor(private input: string) {}\n\n  tokenize(): Token[] {\n    const tokens: Token[] = [];\n\n    while (!this.eof()) {\n      const ch = this.peek();\n\n      if (this.isWhitespace(ch)) {\n        tokens.push(this.readWhitespace());\n        continue;\n      }\n\n      if (ch === \"/\" && this.peek(1) === \"/\") {\n        this.readLineComment();\n        continue;\n      }\n\n      if (ch === \"/\" && this.peek(1) === \"*\") {\n        this.readBlockComment();\n        continue;\n      }\n\n      if (this.isAlpha(ch) || ch === \"_\") {\n        tokens.push(this.readIdentifier());\n        continue;\n      }\n\n      if (this.isDigit(ch) || (ch === \"-\" && this.isDigit(this.peek(1)))) {\n        tokens.push(this.readNumber());\n        continue;\n      }\n\n      if (ch === \"\\\"\" || ch === \"'\") {\n        tokens.push(this.readString());\n        continue;\n      }\n\n      const punct = this.readPunctuator();\n      if (punct) {\n        tokens.push(punct);\n        continue;\n      }\n\n      throw new Error(`Unexpected character '${ch}' at ${this.line}:${this.column}`);\n    }\n\n    return tokens;\n  }\n\n  private readWhitespace(): Token {\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof() && this.isWhitespace(this.peek())) {\n      value += this.next();\n    }\n    return this.token(TokenType.Whitespace, value, start);\n  }\n\n  private readLineComment(): void {\n    this.next();\n    this.next();\n    while (!this.eof() && this.peek() !== \"\\n\") {\n      this.next();\n    }\n  }\n\n  private readBlockComment(): void {\n    this.next();\n    this.next();\n    while (!this.eof()) {\n      if (this.peek() === \"*\" && this.peek(1) === \"/\") {\n        this.next();\n        this.next();\n        return;\n      }\n      this.next();\n    }\n  }\n\n  private readIdentifier(): Token {\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof() && (this.isAlphaNumeric(this.peek()) || this.peek() === \"_\" || this.peek() === \"-\")) {\n      value += this.next();\n    }\n\n    const keywordType = KEYWORDS[value];\n    if (keywordType) {\n      return this.token(keywordType, value, start);\n    }\n\n    return this.token(TokenType.Identifier, value, start);\n  }\n\n  private readNumber(): Token {\n    const start = this.position();\n    let value = \"\";\n    if (this.peek() === \"-\") {\n      value += this.next();\n    }\n    while (!this.eof() && this.isDigit(this.peek())) {\n      value += this.next();\n    }\n    if (this.peek() === \".\") {\n      value += this.next();\n      while (!this.eof() && this.isDigit(this.peek())) {\n        value += this.next();\n      }\n    }\n    return this.token(TokenType.Number, value, start);\n  }\n\n  private readString(): Token {\n    const quote = this.next();\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof()) {\n      const ch = this.next();\n      if (ch === \"\\\\\") {\n        const escaped = this.next();\n        value += escaped;\n        continue;\n      }\n      if (ch === quote) {\n        return this.token(TokenType.String, value, start);\n      }\n      value += ch;\n    }\n    throw new Error(`Unterminated string at ${start.line}:${start.column}`);\n  }\n\n  private readPunctuator(): Token | null {\n    const start = this.position();\n    const ch = this.peek();\n    const punctMap: Record<string, TokenType> = {\n      \"{\": TokenType.LBrace,\n      \"}\": TokenType.RBrace,\n      \"(\": TokenType.LParen,\n      \")\": TokenType.RParen,\n      \"[\": TokenType.LBracket,\n      \"]\": TokenType.RBracket,\n      \":\": TokenType.Colon,\n      \";\": TokenType.Semicolon,\n      \",\": TokenType.Comma,\n      \".\": TokenType.Dot,\n      \"#\": TokenType.Hash,\n      \">\": TokenType.Greater,\n      \"<\": TokenType.Less,\n      \"+\": TokenType.Plus,\n      \"~\": TokenType.Tilde,\n      \"*\": TokenType.Star,\n      \"=\": TokenType.Equals,\n      \"!\": TokenType.Bang,\n      \"@\": TokenType.At,\n      \"$\": TokenType.Dollar,\n      \"?\": TokenType.Question\n    };\n\n    const type = punctMap[ch];\n    if (!type) {\n      return null;\n    }\n\n    this.next();\n    return this.token(type, ch, start);\n  }\n\n  private token(type: TokenType, value: string, start: { index: number; line: number; column: number }): Token {\n    return {\n      type,\n      value,\n      start,\n      end: this.position()\n    };\n  }\n\n  private position() {\n    return { index: this.index, line: this.line, column: this.column };\n  }\n\n  private peek(offset = 0): string {\n    return this.input[this.index + offset] ?? \"\";\n  }\n\n  private next(): string {\n    const ch = this.input[this.index++] ?? \"\";\n    if (ch === \"\\n\") {\n      this.line += 1;\n      this.column = 1;\n    } else {\n      this.column += 1;\n    }\n    return ch;\n  }\n\n  private eof(): boolean {\n    return this.index >= this.input.length;\n  }\n\n  private isWhitespace(ch: string): boolean {\n    return ch === \" \" || ch === \"\\t\" || ch === \"\\n\" || ch === \"\\r\";\n  }\n\n  private isAlpha(ch: string): boolean {\n    return (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\");\n  }\n\n  private isDigit(ch: string): boolean {\n    return ch >= \"0\" && ch <= \"9\";\n  }\n\n  private isAlphaNumeric(ch: string): boolean {\n    return this.isAlpha(ch) || this.isDigit(ch);\n  }\n}\n","export interface ExecutionContext {\n  // Placeholder for runtime context\n}\n\nexport interface CFSNode {\n  type: string;\n  prepare(context: ExecutionContext): Promise<void>;\n  evaluate(context: ExecutionContext): Promise<any>;\n}\n\nexport abstract class BaseNode implements CFSNode {\n  constructor(public type: string) {}\n\n  async prepare(_context: ExecutionContext): Promise<void> {\n    return;\n  }\n\n  async evaluate(_context: ExecutionContext): Promise<any> {\n    return undefined;\n  }\n}\n\nexport class ProgramNode extends BaseNode {\n  constructor(public behaviors: BehaviorNode[]) {\n    super(\"Program\");\n  }\n}\n\nexport class BlockNode extends BaseNode {\n  constructor(public statements: CFSNode[]) {\n    super(\"Block\");\n  }\n}\n\nexport class SelectorNode extends BaseNode {\n  constructor(public selectorText: string) {\n    super(\"Selector\");\n  }\n}\n\nexport class BehaviorNode extends BaseNode {\n  constructor(public selector: SelectorNode, public body: BlockNode) {\n    super(\"Behavior\");\n  }\n}\n\nexport class StateEntryNode extends BaseNode {\n  constructor(\n    public name: string,\n    public value: ExpressionNode,\n    public important: boolean\n  ) {\n    super(\"StateEntry\");\n  }\n}\n\nexport class StateBlockNode extends BaseNode {\n  constructor(public entries: StateEntryNode[]) {\n    super(\"StateBlock\");\n  }\n}\n\nexport class OnBlockNode extends BaseNode {\n  constructor(\n    public eventName: string,\n    public args: string[],\n    public body: BlockNode\n  ) {\n    super(\"OnBlock\");\n  }\n}\n\nexport class AssignmentNode extends BaseNode {\n  constructor(public target: string, public value: ExpressionNode) {\n    super(\"Assignment\");\n  }\n}\n\nexport type ExpressionNode =\n  | IdentifierExpression\n  | LiteralExpression\n  | UnaryExpression\n  | DirectiveExpression\n  | QueryExpression;\n\nexport class IdentifierExpression extends BaseNode {\n  constructor(public name: string) {\n    super(\"Identifier\");\n  }\n}\n\nexport class LiteralExpression extends BaseNode {\n  constructor(public value: string | number | boolean | null) {\n    super(\"Literal\");\n  }\n\n  async evaluate(): Promise<any> {\n    return this.value;\n  }\n}\n\nexport class UnaryExpression extends BaseNode {\n  constructor(public operator: string, public argument: ExpressionNode) {\n    super(\"UnaryExpression\");\n  }\n}\n\nexport class DirectiveExpression extends BaseNode {\n  constructor(public kind: \"attr\" | \"style\", public name: string) {\n    super(\"Directive\");\n  }\n}\n\nexport class QueryExpression extends BaseNode {\n  constructor(public direction: \"self\" | \"descendant\" | \"ancestor\", public selector: string) {\n    super(\"Query\");\n  }\n}\n","import { Token, TokenType } from \"./token\";\n\nexport class TokenStream {\n  private index = 0;\n\n  constructor(private tokens: Token[]) {}\n\n  peek(offset = 0): Token | null {\n    return this.tokens[this.index + offset] ?? null;\n  }\n\n  next(): Token {\n    const token = this.tokens[this.index++];\n    if (!token) {\n      throw new Error(\"Unexpected end of input\");\n    }\n    return token;\n  }\n\n  eof(): boolean {\n    return this.index >= this.tokens.length;\n  }\n\n  match(type: TokenType): boolean {\n    if (this.peek()?.type === type) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n\n  expect(type: TokenType): Token {\n    const token = this.next();\n    if (token.type !== type) {\n      throw new Error(`Expected ${type} but got ${token.type}`);\n    }\n    return token;\n  }\n\n  skipWhitespace(): void {\n    while (this.peek()?.type === TokenType.Whitespace) {\n      this.next();\n    }\n  }\n}\n","import {\n  AssignmentNode,\n  BehaviorNode,\n  BlockNode,\n  DirectiveExpression,\n  IdentifierExpression,\n  LiteralExpression,\n  OnBlockNode,\n  ProgramNode,\n  QueryExpression,\n  SelectorNode,\n  StateBlockNode,\n  StateEntryNode,\n  UnaryExpression,\n  ExpressionNode\n} from \"../ast/nodes\";\nimport { Lexer } from \"./lexer\";\nimport { TokenStream } from \"./token-stream\";\nimport { TokenType } from \"./token\";\n\nexport class Parser {\n  private stream: TokenStream;\n\n  constructor(input: string) {\n    const lexer = new Lexer(input);\n    this.stream = new TokenStream(lexer.tokenize());\n  }\n\n  parseProgram(): ProgramNode {\n    const behaviors: BehaviorNode[] = [];\n    this.stream.skipWhitespace();\n    while (!this.stream.eof()) {\n      behaviors.push(this.parseBehavior());\n      this.stream.skipWhitespace();\n    }\n    return new ProgramNode(behaviors);\n  }\n\n  private parseBehavior(): BehaviorNode {\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Behavior);\n    const selector = this.parseSelector();\n    const body = this.parseBlock();\n    return new BehaviorNode(selector, body);\n  }\n\n  private parseSelector(): SelectorNode {\n    let selectorText = \"\";\n    let sawNonWhitespace = false;\n\n    while (true) {\n      const token = this.stream.peek();\n      if (!token) {\n        break;\n      }\n\n      if (token.type === TokenType.LBrace) {\n        break;\n      }\n\n      if (token.type === TokenType.Whitespace) {\n        this.stream.next();\n        if (sawNonWhitespace && selectorText[selectorText.length - 1] !== \" \") {\n          selectorText += \" \";\n        }\n        continue;\n      }\n\n      sawNonWhitespace = true;\n      selectorText += this.stream.next().value;\n    }\n\n    if (!selectorText.trim()) {\n      throw new Error(\"Behavior selector is required\");\n    }\n\n    return new SelectorNode(selectorText.trim());\n  }\n\n  private parseBlock(): BlockNode {\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LBrace);\n    const statements = [];\n\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated block\");\n      }\n      if (next.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n\n      statements.push(this.parseStatement());\n    }\n\n    return new BlockNode(statements);\n  }\n\n  private parseStatement() {\n    this.stream.skipWhitespace();\n    const next = this.stream.peek();\n    if (!next) {\n      throw new Error(\"Unexpected end of input\");\n    }\n\n    if (next.type === TokenType.State) {\n      return this.parseStateBlock();\n    }\n\n    if (next.type === TokenType.On) {\n      return this.parseOnBlock();\n    }\n\n    if (next.type === TokenType.Behavior) {\n      return this.parseBehavior();\n    }\n\n    if (next.type === TokenType.Identifier && this.stream.peek(1)?.type === TokenType.Equals) {\n      return this.parseAssignment();\n    }\n\n    throw new Error(`Unexpected token ${next.type}`);\n  }\n\n  private parseStateBlock(): StateBlockNode {\n    this.stream.expect(TokenType.State);\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LBrace);\n\n    const entries: StateEntryNode[] = [];\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated state block\");\n      }\n      if (next.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n\n      const nameToken = this.stream.expect(TokenType.Identifier);\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Colon);\n      this.stream.skipWhitespace();\n      const value = this.parseExpression();\n      this.stream.skipWhitespace();\n\n      let important = false;\n      if (this.stream.peek()?.type === TokenType.Bang) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const importantToken = this.stream.next();\n        if (importantToken.type === TokenType.Identifier && importantToken.value === \"important\") {\n          important = true;\n        } else {\n          throw new Error(\"Expected 'important' after '!'\");\n        }\n      }\n\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Semicolon);\n      entries.push(new StateEntryNode(nameToken.value, value, important));\n    }\n\n    return new StateBlockNode(entries);\n  }\n\n  private parseOnBlock(): OnBlockNode {\n    this.stream.expect(TokenType.On);\n    this.stream.skipWhitespace();\n    const event = this.stream.expect(TokenType.Identifier);\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    const args: string[] = [];\n\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated on() arguments\");\n      }\n      if (next.type === TokenType.RParen) {\n        this.stream.next();\n        break;\n      }\n      if (next.type === TokenType.Identifier) {\n        args.push(this.stream.next().value);\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.Comma) {\n          this.stream.next();\n        }\n        continue;\n      }\n      throw new Error(`Unexpected token in on() args: ${next.type}`);\n    }\n\n    const body = this.parseBlock();\n    return new OnBlockNode(event.value, args, body);\n  }\n\n  private parseAssignment(): AssignmentNode {\n    const target = this.stream.expect(TokenType.Identifier);\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Equals);\n    this.stream.skipWhitespace();\n    const value = this.parseExpression();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Semicolon);\n    return new AssignmentNode(target.value, value);\n  }\n\n  private parseExpression(): ExpressionNode {\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected expression\");\n    }\n\n    if (token.type === TokenType.Bang) {\n      this.stream.next();\n      const argument = this.parseExpression();\n      return new UnaryExpression(\"!\", argument);\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier);\n      return new DirectiveExpression(kind, name.value);\n    }\n\n    if (token.type === TokenType.Question) {\n      return this.parseQueryExpression();\n    }\n\n    if (token.type === TokenType.Identifier) {\n      return new IdentifierExpression(this.stream.next().value);\n    }\n\n    if (token.type === TokenType.Boolean) {\n      return new LiteralExpression(this.stream.next().value === \"true\");\n    }\n\n    if (token.type === TokenType.Null) {\n      this.stream.next();\n      return new LiteralExpression(null);\n    }\n\n    if (token.type === TokenType.Number) {\n      return new LiteralExpression(Number(this.stream.next().value));\n    }\n\n    if (token.type === TokenType.String) {\n      return new LiteralExpression(this.stream.next().value);\n    }\n\n    throw new Error(`Unsupported expression token ${token.type}`);\n  }\n\n  private parseQueryExpression(): QueryExpression {\n    this.stream.expect(TokenType.Question);\n    let direction: \"self\" | \"descendant\" | \"ancestor\" = \"self\";\n\n    if (this.stream.peek()?.type === TokenType.Greater) {\n      this.stream.next();\n      direction = \"descendant\";\n    } else if (this.stream.peek()?.type === TokenType.Less) {\n      this.stream.next();\n      direction = \"ancestor\";\n    }\n\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    const selector = this.readSelectorUntil(TokenType.RParen);\n    return new QueryExpression(direction, selector);\n  }\n\n  private readSelectorUntil(terminator: TokenType): string {\n    let selectorText = \"\";\n    let sawNonWhitespace = false;\n\n    while (true) {\n      const token = this.stream.peek();\n      if (!token) {\n        throw new Error(\"Unterminated selector\");\n      }\n      if (token.type === terminator) {\n        this.stream.next();\n        break;\n      }\n\n      if (token.type === TokenType.Whitespace) {\n        this.stream.next();\n        if (sawNonWhitespace && selectorText[selectorText.length - 1] !== \" \") {\n          selectorText += \" \";\n        }\n        continue;\n      }\n\n      sawNonWhitespace = true;\n      selectorText += this.stream.next().value;\n    }\n\n    return selectorText.trim();\n  }\n}\n","export const VERSION = \"0.1.0\";\n\nexport { Lexer } from \"./parser/lexer\";\nimport { Parser } from \"./parser/parser\";\nexport { Parser };\nexport { TokenType } from \"./parser/token\";\nexport * from \"./ast/nodes\";\n\nexport function parseCFS(source: string) {\n  const parser = new Parser(source);\n  return parser.parseProgram();\n}\n"],"mappings":";AAAO,IAAK,YAAL,kBAAKA,eAAL;AACL,EAAAA,WAAA,gBAAa;AACb,EAAAA,WAAA,gBAAa;AACb,EAAAA,WAAA,YAAS;AACT,EAAAA,WAAA,YAAS;AACT,EAAAA,WAAA,aAAU;AACV,EAAAA,WAAA,UAAO;AAEP,EAAAA,WAAA,cAAW;AACX,EAAAA,WAAA,WAAQ;AACR,EAAAA,WAAA,QAAK;AAEL,EAAAA,WAAA,YAAS;AACT,EAAAA,WAAA,YAAS;AACT,EAAAA,WAAA,YAAS;AACT,EAAAA,WAAA,YAAS;AACT,EAAAA,WAAA,cAAW;AACX,EAAAA,WAAA,cAAW;AAEX,EAAAA,WAAA,WAAQ;AACR,EAAAA,WAAA,eAAY;AACZ,EAAAA,WAAA,WAAQ;AAER,EAAAA,WAAA,SAAM;AACN,EAAAA,WAAA,UAAO;AACP,EAAAA,WAAA,aAAU;AACV,EAAAA,WAAA,UAAO;AACP,EAAAA,WAAA,UAAO;AACP,EAAAA,WAAA,WAAQ;AACR,EAAAA,WAAA,UAAO;AAEP,EAAAA,WAAA,YAAS;AACT,EAAAA,WAAA,UAAO;AAEP,EAAAA,WAAA,QAAK;AACL,EAAAA,WAAA,YAAS;AACT,EAAAA,WAAA,cAAW;AApCD,SAAAA;AAAA,GAAA;;;ACEZ,IAAM,WAAsC;AAAA,EAC1C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAEO,IAAM,QAAN,MAAY;AAAA,EAKjB,YAAoB,OAAe;AAAf;AAAA,EAAgB;AAAA,EAJ5B,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,SAAS;AAAA,EAIjB,WAAoB;AAClB,UAAM,SAAkB,CAAC;AAEzB,WAAO,CAAC,KAAK,IAAI,GAAG;AAClB,YAAM,KAAK,KAAK,KAAK;AAErB,UAAI,KAAK,aAAa,EAAE,GAAG;AACzB,eAAO,KAAK,KAAK,eAAe,CAAC;AACjC;AAAA,MACF;AAEA,UAAI,OAAO,OAAO,KAAK,KAAK,CAAC,MAAM,KAAK;AACtC,aAAK,gBAAgB;AACrB;AAAA,MACF;AAEA,UAAI,OAAO,OAAO,KAAK,KAAK,CAAC,MAAM,KAAK;AACtC,aAAK,iBAAiB;AACtB;AAAA,MACF;AAEA,UAAI,KAAK,QAAQ,EAAE,KAAK,OAAO,KAAK;AAClC,eAAO,KAAK,KAAK,eAAe,CAAC;AACjC;AAAA,MACF;AAEA,UAAI,KAAK,QAAQ,EAAE,KAAM,OAAO,OAAO,KAAK,QAAQ,KAAK,KAAK,CAAC,CAAC,GAAI;AAClE,eAAO,KAAK,KAAK,WAAW,CAAC;AAC7B;AAAA,MACF;AAEA,UAAI,OAAO,OAAQ,OAAO,KAAK;AAC7B,eAAO,KAAK,KAAK,WAAW,CAAC;AAC7B;AAAA,MACF;AAEA,YAAM,QAAQ,KAAK,eAAe;AAClC,UAAI,OAAO;AACT,eAAO,KAAK,KAAK;AACjB;AAAA,MACF;AAEA,YAAM,IAAI,MAAM,yBAAyB,EAAE,QAAQ,KAAK,IAAI,IAAI,KAAK,MAAM,EAAE;AAAA,IAC/E;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,iBAAwB;AAC9B,UAAM,QAAQ,KAAK,SAAS;AAC5B,QAAI,QAAQ;AACZ,WAAO,CAAC,KAAK,IAAI,KAAK,KAAK,aAAa,KAAK,KAAK,CAAC,GAAG;AACpD,eAAS,KAAK,KAAK;AAAA,IACrB;AACA,WAAO,KAAK,qCAA4B,OAAO,KAAK;AAAA,EACtD;AAAA,EAEQ,kBAAwB;AAC9B,SAAK,KAAK;AACV,SAAK,KAAK;AACV,WAAO,CAAC,KAAK,IAAI,KAAK,KAAK,KAAK,MAAM,MAAM;AAC1C,WAAK,KAAK;AAAA,IACZ;AAAA,EACF;AAAA,EAEQ,mBAAyB;AAC/B,SAAK,KAAK;AACV,SAAK,KAAK;AACV,WAAO,CAAC,KAAK,IAAI,GAAG;AAClB,UAAI,KAAK,KAAK,MAAM,OAAO,KAAK,KAAK,CAAC,MAAM,KAAK;AAC/C,aAAK,KAAK;AACV,aAAK,KAAK;AACV;AAAA,MACF;AACA,WAAK,KAAK;AAAA,IACZ;AAAA,EACF;AAAA,EAEQ,iBAAwB;AAC9B,UAAM,QAAQ,KAAK,SAAS;AAC5B,QAAI,QAAQ;AACZ,WAAO,CAAC,KAAK,IAAI,MAAM,KAAK,eAAe,KAAK,KAAK,CAAC,KAAK,KAAK,KAAK,MAAM,OAAO,KAAK,KAAK,MAAM,MAAM;AACtG,eAAS,KAAK,KAAK;AAAA,IACrB;AAEA,UAAM,cAAc,SAAS,KAAK;AAClC,QAAI,aAAa;AACf,aAAO,KAAK,MAAM,aAAa,OAAO,KAAK;AAAA,IAC7C;AAEA,WAAO,KAAK,qCAA4B,OAAO,KAAK;AAAA,EACtD;AAAA,EAEQ,aAAoB;AAC1B,UAAM,QAAQ,KAAK,SAAS;AAC5B,QAAI,QAAQ;AACZ,QAAI,KAAK,KAAK,MAAM,KAAK;AACvB,eAAS,KAAK,KAAK;AAAA,IACrB;AACA,WAAO,CAAC,KAAK,IAAI,KAAK,KAAK,QAAQ,KAAK,KAAK,CAAC,GAAG;AAC/C,eAAS,KAAK,KAAK;AAAA,IACrB;AACA,QAAI,KAAK,KAAK,MAAM,KAAK;AACvB,eAAS,KAAK,KAAK;AACnB,aAAO,CAAC,KAAK,IAAI,KAAK,KAAK,QAAQ,KAAK,KAAK,CAAC,GAAG;AAC/C,iBAAS,KAAK,KAAK;AAAA,MACrB;AAAA,IACF;AACA,WAAO,KAAK,6BAAwB,OAAO,KAAK;AAAA,EAClD;AAAA,EAEQ,aAAoB;AAC1B,UAAM,QAAQ,KAAK,KAAK;AACxB,UAAM,QAAQ,KAAK,SAAS;AAC5B,QAAI,QAAQ;AACZ,WAAO,CAAC,KAAK,IAAI,GAAG;AAClB,YAAM,KAAK,KAAK,KAAK;AACrB,UAAI,OAAO,MAAM;AACf,cAAM,UAAU,KAAK,KAAK;AAC1B,iBAAS;AACT;AAAA,MACF;AACA,UAAI,OAAO,OAAO;AAChB,eAAO,KAAK,6BAAwB,OAAO,KAAK;AAAA,MAClD;AACA,eAAS;AAAA,IACX;AACA,UAAM,IAAI,MAAM,0BAA0B,MAAM,IAAI,IAAI,MAAM,MAAM,EAAE;AAAA,EACxE;AAAA,EAEQ,iBAA+B;AACrC,UAAM,QAAQ,KAAK,SAAS;AAC5B,UAAM,KAAK,KAAK,KAAK;AACrB,UAAM,WAAsC;AAAA,MAC1C;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,UAAM,OAAO,SAAS,EAAE;AACxB,QAAI,CAAC,MAAM;AACT,aAAO;AAAA,IACT;AAEA,SAAK,KAAK;AACV,WAAO,KAAK,MAAM,MAAM,IAAI,KAAK;AAAA,EACnC;AAAA,EAEQ,MAAM,MAAiB,OAAe,OAA+D;AAC3G,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA,KAAK,KAAK,SAAS;AAAA,IACrB;AAAA,EACF;AAAA,EAEQ,WAAW;AACjB,WAAO,EAAE,OAAO,KAAK,OAAO,MAAM,KAAK,MAAM,QAAQ,KAAK,OAAO;AAAA,EACnE;AAAA,EAEQ,KAAK,SAAS,GAAW;AAC/B,WAAO,KAAK,MAAM,KAAK,QAAQ,MAAM,KAAK;AAAA,EAC5C;AAAA,EAEQ,OAAe;AACrB,UAAM,KAAK,KAAK,MAAM,KAAK,OAAO,KAAK;AACvC,QAAI,OAAO,MAAM;AACf,WAAK,QAAQ;AACb,WAAK,SAAS;AAAA,IAChB,OAAO;AACL,WAAK,UAAU;AAAA,IACjB;AACA,WAAO;AAAA,EACT;AAAA,EAEQ,MAAe;AACrB,WAAO,KAAK,SAAS,KAAK,MAAM;AAAA,EAClC;AAAA,EAEQ,aAAa,IAAqB;AACxC,WAAO,OAAO,OAAO,OAAO,OAAQ,OAAO,QAAQ,OAAO;AAAA,EAC5D;AAAA,EAEQ,QAAQ,IAAqB;AACnC,WAAQ,MAAM,OAAO,MAAM,OAAS,MAAM,OAAO,MAAM;AAAA,EACzD;AAAA,EAEQ,QAAQ,IAAqB;AACnC,WAAO,MAAM,OAAO,MAAM;AAAA,EAC5B;AAAA,EAEQ,eAAe,IAAqB;AAC1C,WAAO,KAAK,QAAQ,EAAE,KAAK,KAAK,QAAQ,EAAE;AAAA,EAC5C;AACF;;;AC7NO,IAAe,WAAf,MAA2C;AAAA,EAChD,YAAmB,MAAc;AAAd;AAAA,EAAe;AAAA,EAElC,MAAM,QAAQ,UAA2C;AACvD;AAAA,EACF;AAAA,EAEA,MAAM,SAAS,UAA0C;AACvD,WAAO;AAAA,EACT;AACF;AAEO,IAAM,cAAN,cAA0B,SAAS;AAAA,EACxC,YAAmB,WAA2B;AAC5C,UAAM,SAAS;AADE;AAAA,EAEnB;AACF;AAEO,IAAM,YAAN,cAAwB,SAAS;AAAA,EACtC,YAAmB,YAAuB;AACxC,UAAM,OAAO;AADI;AAAA,EAEnB;AACF;AAEO,IAAM,eAAN,cAA2B,SAAS;AAAA,EACzC,YAAmB,cAAsB;AACvC,UAAM,UAAU;AADC;AAAA,EAEnB;AACF;AAEO,IAAM,eAAN,cAA2B,SAAS;AAAA,EACzC,YAAmB,UAA+B,MAAiB;AACjE,UAAM,UAAU;AADC;AAA+B;AAAA,EAElD;AACF;AAEO,IAAM,iBAAN,cAA6B,SAAS;AAAA,EAC3C,YACS,MACA,OACA,WACP;AACA,UAAM,YAAY;AAJX;AACA;AACA;AAAA,EAGT;AACF;AAEO,IAAM,iBAAN,cAA6B,SAAS;AAAA,EAC3C,YAAmB,SAA2B;AAC5C,UAAM,YAAY;AADD;AAAA,EAEnB;AACF;AAEO,IAAM,cAAN,cAA0B,SAAS;AAAA,EACxC,YACS,WACA,MACA,MACP;AACA,UAAM,SAAS;AAJR;AACA;AACA;AAAA,EAGT;AACF;AAEO,IAAM,iBAAN,cAA6B,SAAS;AAAA,EAC3C,YAAmB,QAAuB,OAAuB;AAC/D,UAAM,YAAY;AADD;AAAuB;AAAA,EAE1C;AACF;AASO,IAAM,uBAAN,cAAmC,SAAS;AAAA,EACjD,YAAmB,MAAc;AAC/B,UAAM,YAAY;AADD;AAAA,EAEnB;AACF;AAEO,IAAM,oBAAN,cAAgC,SAAS;AAAA,EAC9C,YAAmB,OAAyC;AAC1D,UAAM,SAAS;AADE;AAAA,EAEnB;AAAA,EAEA,MAAM,WAAyB;AAC7B,WAAO,KAAK;AAAA,EACd;AACF;AAEO,IAAM,kBAAN,cAA8B,SAAS;AAAA,EAC5C,YAAmB,UAAyB,UAA0B;AACpE,UAAM,iBAAiB;AADN;AAAyB;AAAA,EAE5C;AACF;AAEO,IAAM,sBAAN,cAAkC,SAAS;AAAA,EAChD,YAAmB,MAA+B,MAAc;AAC9D,UAAM,WAAW;AADA;AAA+B;AAAA,EAElD;AACF;AAEO,IAAM,kBAAN,cAA8B,SAAS;AAAA,EAC5C,YAAmB,WAAsD,UAAkB;AACzF,UAAM,OAAO;AADI;AAAsD;AAAA,EAEzE;AACF;;;ACnHO,IAAM,cAAN,MAAkB;AAAA,EAGvB,YAAoB,QAAiB;AAAjB;AAAA,EAAkB;AAAA,EAF9B,QAAQ;AAAA,EAIhB,KAAK,SAAS,GAAiB;AAC7B,WAAO,KAAK,OAAO,KAAK,QAAQ,MAAM,KAAK;AAAA,EAC7C;AAAA,EAEA,OAAc;AACZ,UAAM,QAAQ,KAAK,OAAO,KAAK,OAAO;AACtC,QAAI,CAAC,OAAO;AACV,YAAM,IAAI,MAAM,yBAAyB;AAAA,IAC3C;AACA,WAAO;AAAA,EACT;AAAA,EAEA,MAAe;AACb,WAAO,KAAK,SAAS,KAAK,OAAO;AAAA,EACnC;AAAA,EAEA,MAAM,MAA0B;AAC9B,QAAI,KAAK,KAAK,GAAG,SAAS,MAAM;AAC9B,WAAK,KAAK;AACV,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,MAAwB;AAC7B,UAAM,QAAQ,KAAK,KAAK;AACxB,QAAI,MAAM,SAAS,MAAM;AACvB,YAAM,IAAI,MAAM,YAAY,IAAI,YAAY,MAAM,IAAI,EAAE;AAAA,IAC1D;AACA,WAAO;AAAA,EACT;AAAA,EAEA,iBAAuB;AACrB,WAAO,KAAK,KAAK,GAAG,wCAA+B;AACjD,WAAK,KAAK;AAAA,IACZ;AAAA,EACF;AACF;;;ACxBO,IAAM,SAAN,MAAa;AAAA,EACV;AAAA,EAER,YAAY,OAAe;AACzB,UAAM,QAAQ,IAAI,MAAM,KAAK;AAC7B,SAAK,SAAS,IAAI,YAAY,MAAM,SAAS,CAAC;AAAA,EAChD;AAAA,EAEA,eAA4B;AAC1B,UAAM,YAA4B,CAAC;AACnC,SAAK,OAAO,eAAe;AAC3B,WAAO,CAAC,KAAK,OAAO,IAAI,GAAG;AACzB,gBAAU,KAAK,KAAK,cAAc,CAAC;AACnC,WAAK,OAAO,eAAe;AAAA,IAC7B;AACA,WAAO,IAAI,YAAY,SAAS;AAAA,EAClC;AAAA,EAEQ,gBAA8B;AACpC,SAAK,OAAO,eAAe;AAC3B,SAAK,OAAO,gCAAyB;AACrC,UAAM,WAAW,KAAK,cAAc;AACpC,UAAM,OAAO,KAAK,WAAW;AAC7B,WAAO,IAAI,aAAa,UAAU,IAAI;AAAA,EACxC;AAAA,EAEQ,gBAA8B;AACpC,QAAI,eAAe;AACnB,QAAI,mBAAmB;AAEvB,WAAO,MAAM;AACX,YAAM,QAAQ,KAAK,OAAO,KAAK;AAC/B,UAAI,CAAC,OAAO;AACV;AAAA,MACF;AAEA,UAAI,MAAM,gCAA2B;AACnC;AAAA,MACF;AAEA,UAAI,MAAM,wCAA+B;AACvC,aAAK,OAAO,KAAK;AACjB,YAAI,oBAAoB,aAAa,aAAa,SAAS,CAAC,MAAM,KAAK;AACrE,0BAAgB;AAAA,QAClB;AACA;AAAA,MACF;AAEA,yBAAmB;AACnB,sBAAgB,KAAK,OAAO,KAAK,EAAE;AAAA,IACrC;AAEA,QAAI,CAAC,aAAa,KAAK,GAAG;AACxB,YAAM,IAAI,MAAM,+BAA+B;AAAA,IACjD;AAEA,WAAO,IAAI,aAAa,aAAa,KAAK,CAAC;AAAA,EAC7C;AAAA,EAEQ,aAAwB;AAC9B,SAAK,OAAO,eAAe;AAC3B,SAAK,OAAO,4BAAuB;AACnC,UAAM,aAAa,CAAC;AAEpB,WAAO,MAAM;AACX,WAAK,OAAO,eAAe;AAC3B,YAAM,OAAO,KAAK,OAAO,KAAK;AAC9B,UAAI,CAAC,MAAM;AACT,cAAM,IAAI,MAAM,oBAAoB;AAAA,MACtC;AACA,UAAI,KAAK,gCAA2B;AAClC,aAAK,OAAO,KAAK;AACjB;AAAA,MACF;AAEA,iBAAW,KAAK,KAAK,eAAe,CAAC;AAAA,IACvC;AAEA,WAAO,IAAI,UAAU,UAAU;AAAA,EACjC;AAAA,EAEQ,iBAAiB;AACvB,SAAK,OAAO,eAAe;AAC3B,UAAM,OAAO,KAAK,OAAO,KAAK;AAC9B,QAAI,CAAC,MAAM;AACT,YAAM,IAAI,MAAM,yBAAyB;AAAA,IAC3C;AAEA,QAAI,KAAK,8BAA0B;AACjC,aAAO,KAAK,gBAAgB;AAAA,IAC9B;AAEA,QAAI,KAAK,wBAAuB;AAC9B,aAAO,KAAK,aAAa;AAAA,IAC3B;AAEA,QAAI,KAAK,oCAA6B;AACpC,aAAO,KAAK,cAAc;AAAA,IAC5B;AAEA,QAAI,KAAK,0CAAiC,KAAK,OAAO,KAAK,CAAC,GAAG,gCAA2B;AACxF,aAAO,KAAK,gBAAgB;AAAA,IAC9B;AAEA,UAAM,IAAI,MAAM,oBAAoB,KAAK,IAAI,EAAE;AAAA,EACjD;AAAA,EAEQ,kBAAkC;AACxC,SAAK,OAAO,0BAAsB;AAClC,SAAK,OAAO,eAAe;AAC3B,SAAK,OAAO,4BAAuB;AAEnC,UAAM,UAA4B,CAAC;AACnC,WAAO,MAAM;AACX,WAAK,OAAO,eAAe;AAC3B,YAAM,OAAO,KAAK,OAAO,KAAK;AAC9B,UAAI,CAAC,MAAM;AACT,cAAM,IAAI,MAAM,0BAA0B;AAAA,MAC5C;AACA,UAAI,KAAK,gCAA2B;AAClC,aAAK,OAAO,KAAK;AACjB;AAAA,MACF;AAEA,YAAM,YAAY,KAAK,OAAO,oCAA2B;AACzD,WAAK,OAAO,eAAe;AAC3B,WAAK,OAAO,0BAAsB;AAClC,WAAK,OAAO,eAAe;AAC3B,YAAM,QAAQ,KAAK,gBAAgB;AACnC,WAAK,OAAO,eAAe;AAE3B,UAAI,YAAY;AAChB,UAAI,KAAK,OAAO,KAAK,GAAG,4BAAyB;AAC/C,aAAK,OAAO,KAAK;AACjB,aAAK,OAAO,eAAe;AAC3B,cAAM,iBAAiB,KAAK,OAAO,KAAK;AACxC,YAAI,eAAe,0CAAiC,eAAe,UAAU,aAAa;AACxF,sBAAY;AAAA,QACd,OAAO;AACL,gBAAM,IAAI,MAAM,gCAAgC;AAAA,QAClD;AAAA,MACF;AAEA,WAAK,OAAO,eAAe;AAC3B,WAAK,OAAO,kCAA0B;AACtC,cAAQ,KAAK,IAAI,eAAe,UAAU,OAAO,OAAO,SAAS,CAAC;AAAA,IACpE;AAEA,WAAO,IAAI,eAAe,OAAO;AAAA,EACnC;AAAA,EAEQ,eAA4B;AAClC,SAAK,OAAO,oBAAmB;AAC/B,SAAK,OAAO,eAAe;AAC3B,UAAM,QAAQ,KAAK,OAAO,oCAA2B;AACrD,SAAK,OAAO,eAAe;AAC3B,SAAK,OAAO,4BAAuB;AACnC,UAAM,OAAiB,CAAC;AAExB,WAAO,MAAM;AACX,WAAK,OAAO,eAAe;AAC3B,YAAM,OAAO,KAAK,OAAO,KAAK;AAC9B,UAAI,CAAC,MAAM;AACT,cAAM,IAAI,MAAM,6BAA6B;AAAA,MAC/C;AACA,UAAI,KAAK,gCAA2B;AAClC,aAAK,OAAO,KAAK;AACjB;AAAA,MACF;AACA,UAAI,KAAK,wCAA+B;AACtC,aAAK,KAAK,KAAK,OAAO,KAAK,EAAE,KAAK;AAClC,aAAK,OAAO,eAAe;AAC3B,YAAI,KAAK,OAAO,KAAK,GAAG,8BAA0B;AAChD,eAAK,OAAO,KAAK;AAAA,QACnB;AACA;AAAA,MACF;AACA,YAAM,IAAI,MAAM,kCAAkC,KAAK,IAAI,EAAE;AAAA,IAC/D;AAEA,UAAM,OAAO,KAAK,WAAW;AAC7B,WAAO,IAAI,YAAY,MAAM,OAAO,MAAM,IAAI;AAAA,EAChD;AAAA,EAEQ,kBAAkC;AACxC,UAAM,SAAS,KAAK,OAAO,oCAA2B;AACtD,SAAK,OAAO,eAAe;AAC3B,SAAK,OAAO,4BAAuB;AACnC,SAAK,OAAO,eAAe;AAC3B,UAAM,QAAQ,KAAK,gBAAgB;AACnC,SAAK,OAAO,eAAe;AAC3B,SAAK,OAAO,kCAA0B;AACtC,WAAO,IAAI,eAAe,OAAO,OAAO,KAAK;AAAA,EAC/C;AAAA,EAEQ,kBAAkC;AACxC,UAAM,QAAQ,KAAK,OAAO,KAAK;AAC/B,QAAI,CAAC,OAAO;AACV,YAAM,IAAI,MAAM,qBAAqB;AAAA,IACvC;AAEA,QAAI,MAAM,4BAAyB;AACjC,WAAK,OAAO,KAAK;AACjB,YAAM,WAAW,KAAK,gBAAgB;AACtC,aAAO,IAAI,gBAAgB,KAAK,QAAQ;AAAA,IAC1C;AAEA,QAAI,MAAM,0BAAyB,MAAM,gCAA2B;AAClE,YAAM,OAAO,MAAM,yBAAwB,SAAS;AACpD,WAAK,OAAO,KAAK;AACjB,YAAM,OAAO,KAAK,OAAO,oCAA2B;AACpD,aAAO,IAAI,oBAAoB,MAAM,KAAK,KAAK;AAAA,IACjD;AAEA,QAAI,MAAM,oCAA6B;AACrC,aAAO,KAAK,qBAAqB;AAAA,IACnC;AAEA,QAAI,MAAM,wCAA+B;AACvC,aAAO,IAAI,qBAAqB,KAAK,OAAO,KAAK,EAAE,KAAK;AAAA,IAC1D;AAEA,QAAI,MAAM,kCAA4B;AACpC,aAAO,IAAI,kBAAkB,KAAK,OAAO,KAAK,EAAE,UAAU,MAAM;AAAA,IAClE;AAEA,QAAI,MAAM,4BAAyB;AACjC,WAAK,OAAO,KAAK;AACjB,aAAO,IAAI,kBAAkB,IAAI;AAAA,IACnC;AAEA,QAAI,MAAM,gCAA2B;AACnC,aAAO,IAAI,kBAAkB,OAAO,KAAK,OAAO,KAAK,EAAE,KAAK,CAAC;AAAA,IAC/D;AAEA,QAAI,MAAM,gCAA2B;AACnC,aAAO,IAAI,kBAAkB,KAAK,OAAO,KAAK,EAAE,KAAK;AAAA,IACvD;AAEA,UAAM,IAAI,MAAM,gCAAgC,MAAM,IAAI,EAAE;AAAA,EAC9D;AAAA,EAEQ,uBAAwC;AAC9C,SAAK,OAAO,gCAAyB;AACrC,QAAI,YAAgD;AAEpD,QAAI,KAAK,OAAO,KAAK,GAAG,kCAA4B;AAClD,WAAK,OAAO,KAAK;AACjB,kBAAY;AAAA,IACd,WAAW,KAAK,OAAO,KAAK,GAAG,4BAAyB;AACtD,WAAK,OAAO,KAAK;AACjB,kBAAY;AAAA,IACd;AAEA,SAAK,OAAO,eAAe;AAC3B,SAAK,OAAO,4BAAuB;AACnC,UAAM,WAAW,KAAK,uCAAkC;AACxD,WAAO,IAAI,gBAAgB,WAAW,QAAQ;AAAA,EAChD;AAAA,EAEQ,kBAAkB,YAA+B;AACvD,QAAI,eAAe;AACnB,QAAI,mBAAmB;AAEvB,WAAO,MAAM;AACX,YAAM,QAAQ,KAAK,OAAO,KAAK;AAC/B,UAAI,CAAC,OAAO;AACV,cAAM,IAAI,MAAM,uBAAuB;AAAA,MACzC;AACA,UAAI,MAAM,SAAS,YAAY;AAC7B,aAAK,OAAO,KAAK;AACjB;AAAA,MACF;AAEA,UAAI,MAAM,wCAA+B;AACvC,aAAK,OAAO,KAAK;AACjB,YAAI,oBAAoB,aAAa,aAAa,SAAS,CAAC,MAAM,KAAK;AACrE,0BAAgB;AAAA,QAClB;AACA;AAAA,MACF;AAEA,yBAAmB;AACnB,sBAAgB,KAAK,OAAO,KAAK,EAAE;AAAA,IACrC;AAEA,WAAO,aAAa,KAAK;AAAA,EAC3B;AACF;;;ACpTO,IAAM,UAAU;AAQhB,SAAS,SAAS,QAAgB;AACvC,QAAM,SAAS,IAAI,OAAO,MAAM;AAChC,SAAO,OAAO,aAAa;AAC7B;","names":["TokenType"]}