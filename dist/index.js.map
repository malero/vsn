{"version":3,"sources":["../src/parser/token.ts","../src/parser/lexer.ts","../src/ast/nodes.ts","../src/parser/token-stream.ts","../src/parser/parser.ts","../src/runtime/scope.ts","../src/runtime/bindings.ts","../src/runtime/conditionals.ts","../src/runtime/html.ts","../src/runtime/http.ts","../src/runtime/debounce.ts","../src/runtime/engine.ts","../src/index.ts"],"sourcesContent":["export enum TokenType {\n  Whitespace = \"Whitespace\",\n  Identifier = \"Identifier\",\n  Number = \"Number\",\n  String = \"String\",\n  Boolean = \"Boolean\",\n  Null = \"Null\",\n\n  Behavior = \"Behavior\",\n  Use = \"Use\",\n  State = \"State\",\n  On = \"On\",\n  Construct = \"Construct\",\n  Destruct = \"Destruct\",\n  Return = \"Return\",\n\n  LBrace = \"LBrace\",\n  RBrace = \"RBrace\",\n  LParen = \"LParen\",\n  RParen = \"RParen\",\n  LBracket = \"LBracket\",\n  RBracket = \"RBracket\",\n\n  Colon = \"Colon\",\n  Semicolon = \"Semicolon\",\n  Comma = \"Comma\",\n\n  Dot = \"Dot\",\n  Hash = \"Hash\",\n  Greater = \"Greater\",\n  Less = \"Less\",\n  Plus = \"Plus\",\n  Minus = \"Minus\",\n  Tilde = \"Tilde\",\n  Star = \"Star\",\n\n  Equals = \"Equals\",\n  Arrow = \"Arrow\",\n  DoubleEquals = \"DoubleEquals\",\n  NotEquals = \"NotEquals\",\n  LessEqual = \"LessEqual\",\n  GreaterEqual = \"GreaterEqual\",\n  And = \"And\",\n  Or = \"Or\",\n  Bang = \"Bang\",\n\n  At = \"At\",\n  Dollar = \"Dollar\",\n  Question = \"Question\"\n}\n\nexport interface Position {\n  index: number;\n  line: number;\n  column: number;\n}\n\nexport interface Token {\n  type: TokenType;\n  value: string;\n  start: Position;\n  end: Position;\n}\n","import { Token, TokenType } from \"./token\";\n\nconst KEYWORDS: Record<string, TokenType> = {\n  behavior: TokenType.Behavior,\n  use: TokenType.Use,\n  state: TokenType.State,\n  on: TokenType.On,\n  construct: TokenType.Construct,\n  destruct: TokenType.Destruct,\n  return: TokenType.Return,\n  true: TokenType.Boolean,\n  false: TokenType.Boolean,\n  null: TokenType.Null\n};\n\nexport class Lexer {\n  private index = 0;\n  private line = 1;\n  private column = 1;\n\n  constructor(private input: string) {}\n\n  tokenize(): Token[] {\n    const tokens: Token[] = [];\n\n    while (!this.eof()) {\n      const ch = this.peek();\n\n      if (this.isWhitespace(ch)) {\n        tokens.push(this.readWhitespace());\n        continue;\n      }\n\n      if (ch === \"/\" && this.peek(1) === \"/\") {\n        this.readLineComment();\n        continue;\n      }\n\n      if (ch === \"/\" && this.peek(1) === \"*\") {\n        this.readBlockComment();\n        continue;\n      }\n\n      if (this.isAlpha(ch) || ch === \"_\") {\n        tokens.push(this.readIdentifier());\n        continue;\n      }\n\n      if (this.isDigit(ch) || (ch === \"-\" && this.isDigit(this.peek(1)))) {\n        tokens.push(this.readNumber());\n        continue;\n      }\n\n      if (ch === \"\\\"\" || ch === \"'\") {\n        tokens.push(this.readString());\n        continue;\n      }\n\n      const punct = this.readPunctuator();\n      if (punct) {\n        tokens.push(punct);\n        continue;\n      }\n\n      throw new Error(`Unexpected character '${ch}' at ${this.line}:${this.column}`);\n    }\n\n    return tokens;\n  }\n\n  private readWhitespace(): Token {\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof() && this.isWhitespace(this.peek())) {\n      value += this.next();\n    }\n    return this.token(TokenType.Whitespace, value, start);\n  }\n\n  private readLineComment(): void {\n    this.next();\n    this.next();\n    while (!this.eof() && this.peek() !== \"\\n\") {\n      this.next();\n    }\n  }\n\n  private readBlockComment(): void {\n    this.next();\n    this.next();\n    while (!this.eof()) {\n      if (this.peek() === \"*\" && this.peek(1) === \"/\") {\n        this.next();\n        this.next();\n        return;\n      }\n      this.next();\n    }\n  }\n\n  private readIdentifier(): Token {\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof() && (this.isAlphaNumeric(this.peek()) || this.peek() === \"_\" || this.peek() === \"-\")) {\n      value += this.next();\n    }\n\n    const keywordType = KEYWORDS[value];\n    if (keywordType) {\n      return this.token(keywordType, value, start);\n    }\n\n    return this.token(TokenType.Identifier, value, start);\n  }\n\n  private readNumber(): Token {\n    const start = this.position();\n    let value = \"\";\n    if (this.peek() === \"-\") {\n      value += this.next();\n    }\n    while (!this.eof() && this.isDigit(this.peek())) {\n      value += this.next();\n    }\n    if (this.peek() === \".\") {\n      value += this.next();\n      while (!this.eof() && this.isDigit(this.peek())) {\n        value += this.next();\n      }\n    }\n    return this.token(TokenType.Number, value, start);\n  }\n\n  private readString(): Token {\n    const quote = this.next();\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof()) {\n      const ch = this.next();\n      if (ch === \"\\\\\") {\n        const escaped = this.next();\n        value += escaped;\n        continue;\n      }\n      if (ch === quote) {\n        return this.token(TokenType.String, value, start);\n      }\n      value += ch;\n    }\n    throw new Error(`Unterminated string at ${start.line}:${start.column}`);\n  }\n\n  private readPunctuator(): Token | null {\n    const start = this.position();\n    const ch = this.peek();\n    const next = this.peek(1);\n\n    if (ch === \"=\" && next === \"=\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.DoubleEquals, \"==\", start);\n    }\n    if (ch === \"=\" && next === \">\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.Arrow, \"=>\", start);\n    }\n    if (ch === \"!\" && next === \"=\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.NotEquals, \"!=\", start);\n    }\n    if (ch === \"<\" && next === \"=\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.LessEqual, \"<=\", start);\n    }\n    if (ch === \">\" && next === \"=\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.GreaterEqual, \">=\", start);\n    }\n    if (ch === \"&\" && next === \"&\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.And, \"&&\", start);\n    }\n    if (ch === \"|\" && next === \"|\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.Or, \"||\", start);\n    }\n    const punctMap: Record<string, TokenType> = {\n      \"{\": TokenType.LBrace,\n      \"}\": TokenType.RBrace,\n      \"(\": TokenType.LParen,\n      \")\": TokenType.RParen,\n      \"[\": TokenType.LBracket,\n      \"]\": TokenType.RBracket,\n      \":\": TokenType.Colon,\n      \";\": TokenType.Semicolon,\n      \",\": TokenType.Comma,\n      \".\": TokenType.Dot,\n      \"#\": TokenType.Hash,\n      \">\": TokenType.Greater,\n      \"<\": TokenType.Less,\n      \"+\": TokenType.Plus,\n      \"-\": TokenType.Minus,\n      \"~\": TokenType.Tilde,\n      \"*\": TokenType.Star,\n      \"=\": TokenType.Equals,\n      \"!\": TokenType.Bang,\n      \"@\": TokenType.At,\n      \"$\": TokenType.Dollar,\n      \"?\": TokenType.Question\n    };\n\n    const type = punctMap[ch];\n    if (!type) {\n      return null;\n    }\n\n    this.next();\n    return this.token(type, ch, start);\n  }\n\n  private token(type: TokenType, value: string, start: { index: number; line: number; column: number }): Token {\n    return {\n      type,\n      value,\n      start,\n      end: this.position()\n    };\n  }\n\n  private position() {\n    return { index: this.index, line: this.line, column: this.column };\n  }\n\n  private peek(offset = 0): string {\n    return this.input[this.index + offset] ?? \"\";\n  }\n\n  private next(): string {\n    const ch = this.input[this.index++] ?? \"\";\n    if (ch === \"\\n\") {\n      this.line += 1;\n      this.column = 1;\n    } else {\n      this.column += 1;\n    }\n    return ch;\n  }\n\n  private eof(): boolean {\n    return this.index >= this.input.length;\n  }\n\n  private isWhitespace(ch: string): boolean {\n    return ch === \" \" || ch === \"\\t\" || ch === \"\\n\" || ch === \"\\r\";\n  }\n\n  private isAlpha(ch: string): boolean {\n    return (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\");\n  }\n\n  private isDigit(ch: string): boolean {\n    return ch >= \"0\" && ch <= \"9\";\n  }\n\n  private isAlphaNumeric(ch: string): boolean {\n    return this.isAlpha(ch) || this.isDigit(ch);\n  }\n}\n","export interface ExecutionContext {\n  scope?: {\n    getPath(key: string): any;\n    setPath?(key: string, value: any): void;\n  };\n  globals?: Record<string, any>;\n  element?: Element;\n  returnValue?: any;\n  returning?: boolean;\n}\n\nexport interface CFSNode {\n  type: string;\n  prepare(context: ExecutionContext): Promise<void>;\n  evaluate(context: ExecutionContext): Promise<any>;\n}\n\nexport abstract class BaseNode implements CFSNode {\n  constructor(public type: string) {}\n\n  async prepare(_context: ExecutionContext): Promise<void> {\n    return;\n  }\n\n  async evaluate(_context: ExecutionContext): Promise<any> {\n    return undefined;\n  }\n}\n\nexport class ProgramNode extends BaseNode {\n  constructor(public behaviors: BehaviorNode[], public uses: UseNode[] = []) {\n    super(\"Program\");\n  }\n}\n\nexport class UseNode extends BaseNode {\n  constructor(public name: string, public alias: string) {\n    super(\"Use\");\n  }\n}\n\nexport class BlockNode extends BaseNode {\n  constructor(public statements: CFSNode[]) {\n    super(\"Block\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    for (const statement of this.statements) {\n      if (context.returning) {\n        break;\n      }\n      if (statement && typeof statement.evaluate === \"function\") {\n        await statement.evaluate(context);\n      }\n    }\n  }\n}\n\nexport class SelectorNode extends BaseNode {\n  constructor(public selectorText: string) {\n    super(\"Selector\");\n  }\n}\n\nexport class BehaviorNode extends BaseNode {\n  constructor(public selector: SelectorNode, public body: BlockNode) {\n    super(\"Behavior\");\n  }\n}\n\nexport class StateEntryNode extends BaseNode {\n  constructor(\n    public name: string,\n    public value: ExpressionNode,\n    public important: boolean\n  ) {\n    super(\"StateEntry\");\n  }\n}\n\nexport class StateBlockNode extends BaseNode {\n  constructor(public entries: StateEntryNode[]) {\n    super(\"StateBlock\");\n  }\n}\n\nexport class OnBlockNode extends BaseNode {\n  constructor(\n    public eventName: string,\n    public args: string[],\n    public body: BlockNode,\n    public modifiers: string[] = []\n  ) {\n    super(\"OnBlock\");\n  }\n}\n\nexport class AssignmentNode extends BaseNode {\n  constructor(public target: AssignmentTarget, public value: ExpressionNode) {\n    super(\"Assignment\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    if (!context.scope || !context.scope.setPath) {\n      return undefined;\n    }\n    let targetPath: string | undefined;\n    if (this.target instanceof IdentifierExpression) {\n      targetPath = this.target.name;\n    }\n    if (!targetPath) {\n      return undefined;\n    }\n    const value = await this.value.evaluate(context);\n    context.scope.setPath(targetPath, value);\n    return value;\n  }\n}\n\nexport class ReturnNode extends BaseNode {\n  constructor(public value?: ExpressionNode) {\n    super(\"Return\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    if (context.returning) {\n      return context.returnValue;\n    }\n    context.returnValue = this.value ? await this.value.evaluate(context) : undefined;\n    context.returning = true;\n    return context.returnValue;\n  }\n}\n\nexport class FunctionDeclarationNode extends BaseNode {\n  constructor(\n    public name: string,\n    public params: string[],\n    public body: BlockNode,\n    public isAsync = false\n  ) {\n    super(\"FunctionDeclaration\");\n  }\n}\n\nexport class FunctionExpression extends BaseNode {\n  constructor(\n    public params: string[],\n    public body: BlockNode,\n    public isAsync = false\n  ) {\n    super(\"FunctionExpression\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    const scope = context.scope;\n    const globals = context.globals;\n    const element = context.element;\n    return async (...args: any[]) => {\n      const inner: ExecutionContext = {\n        ...(scope ? { scope } : {}),\n        ...(globals ? { globals } : {}),\n        ...(element ? { element } : {}),\n        returnValue: undefined,\n        returning: false\n      };\n      if (scope) {\n        const previousValues = new Map<string, any>();\n        for (let i = 0; i < this.params.length; i += 1) {\n          const name = this.params[i];\n          if (!name) {\n            continue;\n          }\n          previousValues.set(name, scope.getPath(name));\n          if (scope.setPath) {\n            scope.setPath(name, args[i]);\n          }\n        }\n        await this.body.evaluate(inner);\n        for (const name of this.params) {\n          if (!name || !scope.setPath) {\n            continue;\n          }\n          scope.setPath(name, previousValues.get(name));\n        }\n      } else {\n        await this.body.evaluate(inner);\n      }\n      return inner.returnValue;\n    };\n  }\n}\n\nexport interface DeclarationFlags {\n  important?: boolean;\n  trusted?: boolean;\n  debounce?: boolean;\n  [key: string]: boolean | undefined;\n}\n\nexport interface DeclarationFlagArgs {\n  debounce?: number;\n  [key: string]: any;\n}\n\nexport class DeclarationNode extends BaseNode {\n  constructor(\n    public target: DeclarationTarget,\n    public operator: \":\" | \":=\" | \":<\" | \":>\",\n    public value: ExpressionNode,\n    public flags: DeclarationFlags,\n    public flagArgs: DeclarationFlagArgs\n  ) {\n    super(\"Declaration\");\n  }\n}\n\nexport type ExpressionNode =\n  | IdentifierExpression\n  | LiteralExpression\n  | UnaryExpression\n  | BinaryExpression\n  | CallExpression\n  | ArrayExpression\n  | IndexExpression\n  | FunctionExpression\n  | AwaitExpression\n  | TernaryExpression\n  | DirectiveExpression\n  | QueryExpression;\n\nexport type DeclarationTarget = IdentifierExpression | DirectiveExpression;\nexport type AssignmentTarget = IdentifierExpression | DirectiveExpression;\n\nexport class IdentifierExpression extends BaseNode {\n  constructor(public name: string) {\n    super(\"Identifier\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    if (!context.scope) {\n      return undefined;\n    }\n    return context.scope.getPath(this.name);\n  }\n}\n\nexport class LiteralExpression extends BaseNode {\n  constructor(public value: string | number | boolean | null) {\n    super(\"Literal\");\n  }\n\n  async evaluate(): Promise<any> {\n    return this.value;\n  }\n}\n\nexport class UnaryExpression extends BaseNode {\n  constructor(public operator: string, public argument: ExpressionNode) {\n    super(\"UnaryExpression\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    const value = await this.argument.evaluate(context);\n    if (this.operator === \"!\") {\n      return !value;\n    }\n    if (this.operator === \"-\") {\n      return -(value as any);\n    }\n    return value;\n  }\n}\n\nexport class BinaryExpression extends BaseNode {\n  constructor(\n    public operator: string,\n    public left: ExpressionNode,\n    public right: ExpressionNode\n  ) {\n    super(\"BinaryExpression\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    if (this.operator === \"&&\") {\n      const leftValue = await this.left.evaluate(context);\n      return leftValue && (await this.right.evaluate(context));\n    }\n    if (this.operator === \"||\") {\n      const leftValue = await this.left.evaluate(context);\n      return leftValue || (await this.right.evaluate(context));\n    }\n    const left = await this.left.evaluate(context);\n    const right = await this.right.evaluate(context);\n    if (this.operator === \"+\") {\n      return (left as any) + (right as any);\n    }\n    if (this.operator === \"-\") {\n      return (left as any) - (right as any);\n    }\n    if (this.operator === \"==\") {\n      return left == right;\n    }\n    if (this.operator === \"!=\") {\n      return left != right;\n    }\n    if (this.operator === \"<\") {\n      return (left as any) < (right as any);\n    }\n    if (this.operator === \">\") {\n      return (left as any) > (right as any);\n    }\n    if (this.operator === \"<=\") {\n      return (left as any) <= (right as any);\n    }\n    if (this.operator === \">=\") {\n      return (left as any) >= (right as any);\n    }\n    return undefined;\n  }\n}\n\nexport class TernaryExpression extends BaseNode {\n  constructor(\n    public test: ExpressionNode,\n    public consequent: ExpressionNode,\n    public alternate: ExpressionNode\n  ) {\n    super(\"TernaryExpression\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    const condition = await this.test.evaluate(context);\n    if (condition) {\n      return this.consequent.evaluate(context);\n    }\n    return this.alternate.evaluate(context);\n  }\n}\n\nexport class CallExpression extends BaseNode {\n  constructor(public callee: ExpressionNode, public args: ExpressionNode[]) {\n    super(\"CallExpression\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    const resolved = this.resolveCallee(context);\n    const fn = resolved?.fn ?? (await this.callee.evaluate(context));\n    if (typeof fn !== \"function\") {\n      return undefined;\n    }\n    const values = [];\n    for (const arg of this.args) {\n      values.push(await arg.evaluate(context));\n    }\n    return fn.apply(resolved?.thisArg, values);\n  }\n\n  private resolveCallee(\n    context: ExecutionContext\n  ): { fn: any; thisArg?: any } | undefined {\n    if (!(this.callee instanceof IdentifierExpression)) {\n      return undefined;\n    }\n    const name = this.callee.name;\n    const globals = context.globals ?? {};\n    const parts = name.split(\".\");\n    const root = parts[0];\n    if (!root || !(root in globals)) {\n      if (parts.length > 1 && context.scope) {\n        const parentPath = parts.slice(0, -1).join(\".\");\n        const methodName = parts[parts.length - 1];\n        if (!methodName) {\n          return undefined;\n        }\n        const parentValue = context.scope.getPath(parentPath);\n        if (parentValue == null) {\n          return undefined;\n        }\n        return { fn: parentValue?.[methodName], thisArg: parentValue };\n      }\n      return undefined;\n    }\n    let value = globals[root];\n    let parent: any = undefined;\n    for (let i = 1; i < parts.length; i += 1) {\n      parent = value;\n      const part = parts[i];\n      if (!part) {\n        return undefined;\n      }\n      value = value?.[part];\n    }\n    return { fn: value, thisArg: parent };\n  }\n}\n\nexport class ArrayExpression extends BaseNode {\n  constructor(public elements: ExpressionNode[]) {\n    super(\"ArrayExpression\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    const values: any[] = [];\n    for (const element of this.elements) {\n      values.push(await element.evaluate(context));\n    }\n    return values;\n  }\n}\n\nexport class IndexExpression extends BaseNode {\n  constructor(public target: ExpressionNode, public index: ExpressionNode) {\n    super(\"IndexExpression\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    const target = await this.target.evaluate(context);\n    if (target == null) {\n      return undefined;\n    }\n    const index = await this.index.evaluate(context);\n    if (index == null) {\n      return undefined;\n    }\n    return (target as any)[index as any];\n  }\n}\n\nexport class DirectiveExpression extends BaseNode {\n  constructor(public kind: \"attr\" | \"style\", public name: string) {\n    super(\"Directive\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    const element = context.element;\n    if (!element) {\n      return `${this.kind}:${this.name}`;\n    }\n    if (this.kind === \"attr\") {\n      if (this.name === \"value\") {\n        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n          return element.value;\n        }\n        if (element instanceof HTMLSelectElement) {\n          return element.value;\n        }\n      }\n      if (this.name === \"checked\" && element instanceof HTMLInputElement) {\n        return element.checked;\n      }\n      if (this.name === \"html\" && element instanceof HTMLElement) {\n        return element.innerHTML;\n      }\n      return element.getAttribute(this.name) ?? undefined;\n    }\n    if (this.kind === \"style\" && element instanceof HTMLElement) {\n      return element.style.getPropertyValue(this.name) ?? undefined;\n    }\n    return undefined;\n  }\n}\n\nexport class AwaitExpression extends BaseNode {\n  constructor(public argument: ExpressionNode) {\n    super(\"AwaitExpression\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    const value = await this.argument.evaluate(context);\n    return await value;\n  }\n}\n\nexport class QueryExpression extends BaseNode {\n  constructor(public direction: \"self\" | \"descendant\" | \"ancestor\", public selector: string) {\n    super(\"Query\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    const selector = this.selector.trim();\n    if (!selector) {\n      return [];\n    }\n    if (this.direction === \"ancestor\") {\n      const results: Element[] = [];\n      let cursor = context.element?.parentElement;\n      while (cursor) {\n        if (cursor.matches(selector)) {\n          results.push(cursor);\n        }\n        cursor = cursor.parentElement;\n      }\n      return results;\n    }\n    const root = this.direction === \"descendant\"\n      ? context.element ?? (typeof document !== \"undefined\" ? document : undefined)\n      : (typeof document !== \"undefined\" ? document : undefined);\n    if (!root || !(\"querySelectorAll\" in root)) {\n      return [];\n    }\n    return Array.from((root as ParentNode).querySelectorAll(selector));\n  }\n}\n","import { Token, TokenType } from \"./token\";\n\nexport class TokenStream {\n  private index = 0;\n\n  constructor(private tokens: Token[]) {}\n\n  peek(offset = 0): Token | null {\n    return this.tokens[this.index + offset] ?? null;\n  }\n\n  next(): Token {\n    const token = this.tokens[this.index++];\n    if (!token) {\n      throw new Error(\"Unexpected end of input\");\n    }\n    return token;\n  }\n\n  eof(): boolean {\n    return this.index >= this.tokens.length;\n  }\n\n  match(type: TokenType): boolean {\n    if (this.peek()?.type === type) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n\n  expect(type: TokenType): Token {\n    const token = this.next();\n    if (token.type !== type) {\n      throw new Error(`Expected ${type} but got ${token.type}`);\n    }\n    return token;\n  }\n\n  skipWhitespace(): void {\n    while (this.peek()?.type === TokenType.Whitespace) {\n      this.next();\n    }\n  }\n\n  peekNonWhitespace(offset = 0): Token | null {\n    let count = 0;\n    for (let i = this.index; i < this.tokens.length; i++) {\n      const token = this.tokens[i];\n      if (token.type === TokenType.Whitespace) {\n        continue;\n      }\n      if (count === offset) {\n        return token;\n      }\n      count += 1;\n    }\n    return null;\n  }\n}\n","import {\n  AssignmentNode,\n  ArrayExpression,\n  BehaviorNode,\n  BinaryExpression,\n  BlockNode,\n  AssignmentTarget,\n  CallExpression,\n  DeclarationNode,\n  DeclarationTarget,\n  DeclarationFlags,\n  DeclarationFlagArgs,\n  DirectiveExpression,\n  FunctionDeclarationNode,\n  FunctionExpression,\n  IdentifierExpression,\n  LiteralExpression,\n  OnBlockNode,\n  ProgramNode,\n  QueryExpression,\n  ReturnNode,\n  SelectorNode,\n  StateBlockNode,\n  StateEntryNode,\n  TernaryExpression,\n  UnaryExpression,\n  UseNode,\n  IndexExpression,\n  ExpressionNode,\n  AwaitExpression\n} from \"../ast/nodes\";\nimport { Lexer } from \"./lexer\";\nimport { TokenStream } from \"./token-stream\";\nimport { Token, TokenType } from \"./token\";\n\nexport class Parser {\n  private stream: TokenStream;\n  private source: string;\n  private customFlags: Set<string>;\n  private allowImplicitSemicolon = false;\n  private awaitStack: boolean[] = [];\n\n  constructor(input: string, options?: { customFlags?: Set<string> }) {\n    this.source = input;\n    this.customFlags = options?.customFlags ?? new Set<string>();\n    const lexer = new Lexer(input);\n    this.stream = new TokenStream(lexer.tokenize());\n  }\n\n  static parseInline(code: string): BlockNode {\n    const parser = new Parser(`{${code}}`);\n    return parser.parseInlineBlock();\n  }\n\n  parseProgram(): ProgramNode {\n    return this.wrapErrors(() => {\n      const behaviors: BehaviorNode[] = [];\n      const uses: UseNode[] = [];\n      this.stream.skipWhitespace();\n      while (!this.stream.eof()) {\n        const next = this.stream.peek();\n        if (!next) {\n          break;\n        }\n        if (next.type === TokenType.Use) {\n          uses.push(this.parseUseStatement());\n        } else {\n          behaviors.push(this.parseBehavior());\n        }\n        this.stream.skipWhitespace();\n      }\n      return new ProgramNode(behaviors, uses);\n    });\n  }\n\n  parseInlineBlock(): BlockNode {\n    return this.wrapErrors(() => {\n      this.stream.skipWhitespace();\n      this.allowImplicitSemicolon = true;\n      return this.parseBlock({ allowDeclarations: false });\n    });\n  }\n\n  private parseBehavior(): BehaviorNode {\n    return this.wrapErrors(() => {\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Behavior);\n      const selector = this.parseSelector();\n      const body = this.parseBlock({ allowDeclarations: true });\n      return new BehaviorNode(selector, body);\n    });\n  }\n\n  private parseSelector(): SelectorNode {\n    let selectorText = \"\";\n    let sawNonWhitespace = false;\n\n    while (true) {\n      const token = this.stream.peek();\n      if (!token) {\n        break;\n      }\n\n      if (token.type === TokenType.LBrace) {\n        break;\n      }\n\n      if (token.type === TokenType.Whitespace) {\n        this.stream.next();\n        if (sawNonWhitespace && selectorText[selectorText.length - 1] !== \" \") {\n          selectorText += \" \";\n        }\n        continue;\n      }\n\n      sawNonWhitespace = true;\n      selectorText += this.stream.next().value;\n    }\n\n    if (!selectorText.trim()) {\n      throw new Error(\"Behavior selector is required\");\n    }\n\n    return new SelectorNode(selectorText.trim());\n  }\n\n  private parseUseStatement(): UseNode {\n    return this.wrapErrors(() => {\n      this.stream.expect(TokenType.Use);\n      this.stream.skipWhitespace();\n      const name = this.parseIdentifierPath();\n      this.stream.skipWhitespace();\n      let alias = name;\n      const next = this.stream.peek();\n      if (next?.type === TokenType.Identifier && next.value === \"as\") {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        alias = this.stream.expect(TokenType.Identifier).value;\n      }\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Semicolon);\n      return new UseNode(name, alias);\n    });\n  }\n\n  private wrapErrors<T>(fn: () => T): T {\n    try {\n      return fn();\n    } catch (error) {\n      if (error instanceof Error && !/\\(line\\s+\\d+, column\\s+\\d+\\)/i.test(error.message)) {\n        throw new Error(this.formatError(error.message));\n      }\n      throw error;\n    }\n  }\n\n  private formatError(message: string): string {\n    const token = this.stream.peek() ?? this.stream.peekNonWhitespace(0);\n    if (!token) {\n      return `Parse error: ${message}`;\n    }\n    const line = token.start.line;\n    const column = token.start.column;\n    const snippet = this.getLineSnippet(line, column);\n    return `Parse error (line ${line}, column ${column}): ${message}\\n${snippet}`;\n  }\n\n  private getLineSnippet(line: number, column: number): string {\n    const lines = this.source.split(/\\r?\\n/);\n    const content = lines[line - 1] ?? \"\";\n    const caret = `${\" \".repeat(Math.max(column - 1, 0))}^`;\n    return `${content}\\n${caret}`;\n  }\n\n  private parseBlock(options?: { allowDeclarations?: boolean }): BlockNode {\n    const allowDeclarations = options?.allowDeclarations ?? false;\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LBrace);\n    const statements = [];\n    let declarationsOpen = allowDeclarations;\n    let sawConstruct = false;\n    let sawFunctionOrOn = false;\n\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated block\");\n      }\n      if (next.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n\n      const isFunctionDeclaration = allowDeclarations && this.isFunctionDeclarationStart();\n      if (isFunctionDeclaration) {\n        if (!sawConstruct) {\n          sawFunctionOrOn = true;\n        }\n        statements.push(this.parseFunctionDeclaration());\n        continue;\n      }\n      const isFunctionExpressionAssignment = allowDeclarations && this.isFunctionExpressionAssignmentStart();\n      if (isFunctionExpressionAssignment) {\n        if (!declarationsOpen) {\n          throw new Error(\"Declarations must appear before blocks\");\n        }\n        statements.push(this.parseAssignment());\n        continue;\n      }\n      const isDeclaration = this.isDeclarationStart();\n      if (isDeclaration) {\n        if (!allowDeclarations) {\n          throw new Error(\"Declarations are only allowed at the behavior root\");\n        }\n        if (!declarationsOpen) {\n          throw new Error(\"Declarations must appear before blocks\");\n        }\n        statements.push(this.parseDeclaration());\n      } else {\n        if (declarationsOpen) {\n          declarationsOpen = false;\n        }\n        if (allowDeclarations && next.type === TokenType.On && !sawConstruct) {\n          sawFunctionOrOn = true;\n        }\n        if (allowDeclarations && next.type === TokenType.Construct) {\n          if (sawFunctionOrOn) {\n            throw new Error(\"Construct blocks must appear before functions and on blocks\");\n          }\n          sawConstruct = true;\n        }\n        statements.push(this.parseStatement());\n      }\n    }\n\n    return new BlockNode(statements);\n  }\n\n  private parseStatement(options?: { allowBlocks?: boolean; allowReturn?: boolean }) {\n    this.stream.skipWhitespace();\n    const next = this.stream.peek();\n    if (!next) {\n      throw new Error(\"Unexpected end of input\");\n    }\n\n    const allowBlocks = options?.allowBlocks ?? true;\n    const allowReturn = options?.allowReturn ?? false;\n\n    if (next.type === TokenType.Return) {\n      if (!allowReturn) {\n        throw new Error(\"Return is only allowed inside functions\");\n      }\n      return this.parseReturnStatement();\n    }\n\n    if (allowBlocks && next.type === TokenType.On) {\n      return this.parseOnBlock();\n    }\n\n    if (allowBlocks && next.type === TokenType.Construct) {\n      return this.parseConstructBlock();\n    }\n\n    if (allowBlocks && next.type === TokenType.Destruct) {\n      return this.parseDestructBlock();\n    }\n\n    if (allowBlocks && next.type === TokenType.Behavior) {\n      return this.parseBehavior();\n    }\n\n    if (this.isAwaitAllowed() && next.type === TokenType.Identifier && next.value === \"await\") {\n      return this.parseExpressionStatement();\n    }\n\n    if (this.isCallStart()) {\n      return this.parseExpressionStatement();\n    }\n\n    if (this.isAssignmentStart()) {\n      return this.parseAssignment();\n    }\n\n    throw new Error(`Unexpected token ${next.type}`);\n  }\n\n  private parseStateBlock(): StateBlockNode {\n    this.stream.expect(TokenType.State);\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LBrace);\n\n    const entries: StateEntryNode[] = [];\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated state block\");\n      }\n      if (next.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n\n      const nameToken = this.stream.expect(TokenType.Identifier);\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Colon);\n      this.stream.skipWhitespace();\n      const value = this.parseExpression();\n      this.stream.skipWhitespace();\n\n      let important = false;\n      if (this.stream.peek()?.type === TokenType.Bang) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const importantToken = this.stream.next();\n        if (importantToken.type === TokenType.Identifier && importantToken.value === \"important\") {\n          important = true;\n        } else {\n          throw new Error(\"Expected 'important' after '!'\");\n        }\n      }\n\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Semicolon);\n      entries.push(new StateEntryNode(nameToken.value, value, important));\n    }\n\n    return new StateBlockNode(entries);\n  }\n\n  private parseOnBlock(): OnBlockNode {\n    this.stream.expect(TokenType.On);\n    this.stream.skipWhitespace();\n    const event = this.parseIdentifierPath();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    const args: string[] = [];\n\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated on() arguments\");\n      }\n      if (next.type === TokenType.RParen) {\n        this.stream.next();\n        break;\n      }\n      if (next.type === TokenType.Identifier) {\n        args.push(this.stream.next().value);\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.Comma) {\n          this.stream.next();\n        }\n        continue;\n      }\n      throw new Error(`Unexpected token in on() args: ${next.type}`);\n    }\n\n    const modifiers = this.parseOnModifiers();\n    const body = this.parseBlock({ allowDeclarations: false });\n    return new OnBlockNode(event, args, body, modifiers);\n  }\n\n  private parseOnModifiers(): string[] {\n    const modifiers: string[] = [];\n    while (true) {\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type !== TokenType.Bang) {\n        break;\n      }\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier).value;\n      modifiers.push(name);\n    }\n    return modifiers;\n  }\n\n  private parseAssignment(): AssignmentNode {\n    const target = this.parseAssignmentTarget();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Equals);\n    this.stream.skipWhitespace();\n    const value = this.parseExpression();\n    this.consumeStatementTerminator();\n    return new AssignmentNode(target, value);\n  }\n\n  private parseExpression(): ExpressionNode {\n    return this.parseTernaryExpression();\n  }\n\n  private parseTernaryExpression(): ExpressionNode {\n    let test = this.parseLogicalOrExpression();\n    this.stream.skipWhitespace();\n    if (this.stream.peek()?.type !== TokenType.Question) {\n      return test;\n    }\n    this.stream.next();\n    this.stream.skipWhitespace();\n    const consequent = this.parseExpression();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Colon);\n    this.stream.skipWhitespace();\n    const alternate = this.parseExpression();\n    return new TernaryExpression(test, consequent, alternate);\n  }\n\n  private parseLogicalOrExpression(): ExpressionNode {\n    let left = this.parseLogicalAndExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next || next.type !== TokenType.Or) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseLogicalAndExpression();\n      this.stream.skipWhitespace();\n      left = new BinaryExpression(\"||\", left, right);\n    }\n    return left;\n  }\n\n  private parseLogicalAndExpression(): ExpressionNode {\n    let left = this.parseEqualityExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next || next.type !== TokenType.And) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseEqualityExpression();\n      this.stream.skipWhitespace();\n      left = new BinaryExpression(\"&&\", left, right);\n    }\n    return left;\n  }\n\n  private parseEqualityExpression(): ExpressionNode {\n    let left = this.parseComparisonExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next || (next.type !== TokenType.DoubleEquals && next.type !== TokenType.NotEquals)) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      const op = this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseComparisonExpression();\n      this.stream.skipWhitespace();\n      left = new BinaryExpression(op.type === TokenType.DoubleEquals ? \"==\" : \"!=\", left, right);\n    }\n    return left;\n  }\n\n  private parseComparisonExpression(): ExpressionNode {\n    let left = this.parseAdditiveExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next) {\n        break;\n      }\n      if (next.type !== TokenType.Less &&\n          next.type !== TokenType.Greater &&\n          next.type !== TokenType.LessEqual &&\n          next.type !== TokenType.GreaterEqual) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      const op = this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseAdditiveExpression();\n      this.stream.skipWhitespace();\n      let operator = \"<\";\n      if (op.type === TokenType.Greater) {\n        operator = \">\";\n      } else if (op.type === TokenType.LessEqual) {\n        operator = \"<=\";\n      } else if (op.type === TokenType.GreaterEqual) {\n        operator = \">=\";\n      }\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n\n  private parseAdditiveExpression(): ExpressionNode {\n    let left = this.parseUnaryExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next || (next.type !== TokenType.Plus && next.type !== TokenType.Minus)) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      const op = this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseUnaryExpression();\n      this.stream.skipWhitespace();\n      left = new BinaryExpression(op.type === TokenType.Plus ? \"+\" : \"-\", left, right);\n    }\n    return left;\n  }\n\n  private parseUnaryExpression(): ExpressionNode {\n    this.stream.skipWhitespace();\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected expression\");\n    }\n    if (token.type === TokenType.Bang) {\n      this.stream.next();\n      const argument = this.parseUnaryExpression();\n      return new UnaryExpression(\"!\", argument);\n    }\n    if (token.type === TokenType.Minus) {\n      this.stream.next();\n      const argument = this.parseUnaryExpression();\n      return new UnaryExpression(\"-\", argument);\n    }\n    if (this.isAwaitAllowed() && token.type === TokenType.Identifier && token.value === \"await\") {\n      this.stream.next();\n      const argument = this.parseUnaryExpression();\n      return new AwaitExpression(argument);\n    }\n    return this.parseCallExpression();\n  }\n\n  private parseCallExpression(): ExpressionNode {\n    let expr = this.parsePrimaryExpression();\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        break;\n      }\n      if (next.type === TokenType.LParen) {\n        this.stream.next();\n        const args: ExpressionNode[] = [];\n        while (true) {\n          this.stream.skipWhitespace();\n          const argToken = this.stream.peek();\n          if (!argToken) {\n            throw new Error(\"Unterminated call expression\");\n          }\n          if (argToken.type === TokenType.RParen) {\n            this.stream.next();\n            break;\n          }\n          args.push(this.parseExpression());\n          this.stream.skipWhitespace();\n          if (this.stream.peek()?.type === TokenType.Comma) {\n            this.stream.next();\n            continue;\n          }\n          if (this.stream.peek()?.type === TokenType.RParen) {\n            this.stream.next();\n            break;\n          }\n          throw new Error(\"Expected ',' or ')' in call arguments\");\n        }\n        expr = new CallExpression(expr, args);\n        continue;\n      }\n      if (next.type === TokenType.LBracket) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const index = this.parseExpression();\n        this.stream.skipWhitespace();\n        this.stream.expect(TokenType.RBracket);\n        expr = new IndexExpression(expr, index);\n        continue;\n      }\n      break;\n    }\n    return expr;\n  }\n\n  private parsePrimaryExpression(): ExpressionNode {\n    this.stream.skipWhitespace();\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected expression\");\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier);\n      return new DirectiveExpression(kind, name.value);\n    }\n\n    if (token.type === TokenType.Question) {\n      return this.parseQueryExpression();\n    }\n\n    if (token.type === TokenType.LBracket) {\n      return this.parseArrayExpression();\n    }\n\n    if (token.type === TokenType.LParen) {\n      if (this.isArrowFunctionStart()) {\n        return this.parseArrowFunctionExpression();\n      }\n      this.stream.next();\n      const value = this.parseExpression();\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.RParen);\n      return value;\n    }\n\n    if (token.type === TokenType.Identifier) {\n      if (this.isAsyncToken(token) && this.isAsyncArrowFunctionStart()) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        return this.parseArrowFunctionExpression(true);\n      }\n      const name = this.parseIdentifierPath();\n      return new IdentifierExpression(name);\n    }\n\n    if (token.type === TokenType.Boolean) {\n      return new LiteralExpression(this.stream.next().value === \"true\");\n    }\n\n    if (token.type === TokenType.Null) {\n      this.stream.next();\n      return new LiteralExpression(null);\n    }\n\n    if (token.type === TokenType.Number) {\n      return new LiteralExpression(Number(this.stream.next().value));\n    }\n\n    if (token.type === TokenType.String) {\n      return new LiteralExpression(this.stream.next().value);\n    }\n\n    throw new Error(`Unsupported expression token ${token.type}`);\n  }\n\n  private parseArrayExpression(): ExpressionNode {\n    this.stream.expect(TokenType.LBracket);\n    const elements: ExpressionNode[] = [];\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated array literal\");\n      }\n      if (next.type === TokenType.RBracket) {\n        this.stream.next();\n        break;\n      }\n      elements.push(this.parseExpression());\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.Comma) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.RBracket) {\n          this.stream.next();\n          break;\n        }\n        continue;\n      }\n      if (this.stream.peek()?.type === TokenType.RBracket) {\n        this.stream.next();\n        break;\n      }\n      throw new Error(\"Expected ',' or ']' in array literal\");\n    }\n    return new ArrayExpression(elements);\n  }\n\n  private consumeStatementTerminator(): void {\n    this.stream.skipWhitespace();\n    const next = this.stream.peek();\n    if (next?.type === TokenType.Semicolon) {\n      this.stream.next();\n      return;\n    }\n    if (this.allowImplicitSemicolon && next?.type === TokenType.RBrace) {\n      return;\n    }\n    this.stream.expect(TokenType.Semicolon);\n  }\n\n  private parseFunctionBlockWithAwait(allowAwait: boolean): BlockNode {\n    this.stream.expect(TokenType.LBrace);\n    const statements = [];\n    this.awaitStack.push(allowAwait);\n    try {\n      while (true) {\n        this.stream.skipWhitespace();\n        const next = this.stream.peek();\n        if (!next) {\n          throw new Error(\"Unterminated function block\");\n        }\n        if (next.type === TokenType.RBrace) {\n          this.stream.next();\n          break;\n        }\n        statements.push(this.parseStatement({ allowBlocks: false, allowReturn: true }));\n      }\n    } finally {\n      this.awaitStack.pop();\n    }\n    return new BlockNode(statements);\n  }\n\n  private isAsyncToken(token?: Token | null): boolean {\n    return token?.type === TokenType.Identifier && token.value === \"async\";\n  }\n\n  private isAwaitAllowed(): boolean {\n    if (this.awaitStack.length === 0) {\n      return false;\n    }\n    return this.awaitStack[this.awaitStack.length - 1] === true;\n  }\n\n  private parseArrowExpressionBody(allowAwait: boolean): BlockNode {\n    this.awaitStack.push(allowAwait);\n    try {\n      const expression = this.parseExpression();\n      return new BlockNode([new ReturnNode(expression)]);\n    } finally {\n      this.awaitStack.pop();\n    }\n  }\n\n  private parseAssignmentTarget(): AssignmentTarget {\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected assignment target\");\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier);\n      return new DirectiveExpression(kind, name.value);\n    }\n\n    if (token.type === TokenType.Identifier) {\n      return new IdentifierExpression(this.parseIdentifierPath());\n    }\n\n    throw new Error(`Invalid assignment target ${token.type}`);\n  }\n\n  private parseDeclaration(): DeclarationNode {\n    const target = this.parseDeclarationTarget();\n    this.stream.skipWhitespace();\n    const operator = this.parseDeclarationOperator();\n    this.stream.skipWhitespace();\n    const value = this.parseExpression();\n    const { flags, flagArgs } = this.parseFlags();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Semicolon);\n    return new DeclarationNode(target, operator, value, flags, flagArgs);\n  }\n\n  private parseDeclarationTarget(): DeclarationTarget {\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected declaration target\");\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier);\n      return new DirectiveExpression(kind, name.value);\n    }\n\n    if (token.type === TokenType.Identifier) {\n      return new IdentifierExpression(this.stream.next().value);\n    }\n\n    throw new Error(`Invalid declaration target ${token.type}`);\n  }\n\n  private parseDeclarationOperator(): \":\" | \":=\" | \":<\" | \":>\" {\n    this.stream.expect(TokenType.Colon);\n    const next = this.stream.peek();\n    if (!next) {\n      return \":\";\n    }\n    if (next.type === TokenType.Equals) {\n      this.stream.next();\n      return \":=\";\n    }\n    if (next.type === TokenType.Less) {\n      this.stream.next();\n      return \":<\";\n    }\n    if (next.type === TokenType.Greater) {\n      this.stream.next();\n      return \":>\";\n    }\n    return \":\";\n  }\n\n  private parseFlags(): { flags: DeclarationFlags; flagArgs: DeclarationFlagArgs } {\n    const flags: DeclarationFlags = {};\n    const flagArgs: DeclarationFlagArgs = {};\n\n    while (true) {\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type !== TokenType.Bang) {\n        break;\n      }\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier).value;\n\n      if (name === \"important\") {\n        flags.important = true;\n      } else if (name === \"trusted\") {\n        flags.trusted = true;\n      } else if (name === \"debounce\") {\n        flags.debounce = true;\n        if (this.stream.peek()?.type === TokenType.LParen) {\n          this.stream.next();\n          this.stream.skipWhitespace();\n          const numberToken = this.stream.expect(TokenType.Number);\n          flagArgs.debounce = Number(numberToken.value);\n          this.stream.skipWhitespace();\n          this.stream.expect(TokenType.RParen);\n        } else {\n          flagArgs.debounce = 200;\n        }\n      } else if (this.customFlags.has(name)) {\n        (flags as Record<string, boolean>)[name] = true;\n        const customArg = this.parseCustomFlagArg();\n        if (customArg !== undefined) {\n          (flagArgs as Record<string, any>)[name] = customArg;\n        }\n      } else {\n        throw new Error(`Unknown flag ${name}`);\n      }\n    }\n\n    return { flags, flagArgs };\n  }\n\n  private parseCustomFlagArg(): any {\n    if (this.stream.peek()?.type !== TokenType.LParen) {\n      return undefined;\n    }\n    this.stream.next();\n    this.stream.skipWhitespace();\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Unterminated flag arguments\");\n    }\n    let value: any;\n    if (token.type === TokenType.Number) {\n      value = Number(this.stream.next().value);\n    } else if (token.type === TokenType.String) {\n      value = this.stream.next().value;\n    } else if (token.type === TokenType.Boolean) {\n      value = this.stream.next().value === \"true\";\n    } else if (token.type === TokenType.Identifier) {\n      value = this.stream.next().value;\n    } else {\n      throw new Error(`Unsupported flag argument ${token.type}`);\n    }\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.RParen);\n    return value;\n  }\n\n  private isDeclarationStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first) {\n      return false;\n    }\n\n    if (first.type === TokenType.Identifier) {\n      const second = this.stream.peekNonWhitespace(1);\n      return second?.type === TokenType.Colon;\n    }\n\n    if (first.type === TokenType.At || first.type === TokenType.Dollar) {\n      const second = this.stream.peekNonWhitespace(1);\n      const third = this.stream.peekNonWhitespace(2);\n      return second?.type === TokenType.Identifier && third?.type === TokenType.Colon;\n    }\n\n    return false;\n  }\n\n  private isAssignmentStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first) {\n      return false;\n    }\n\n    if (first.type === TokenType.Identifier) {\n      let index = 1;\n      while (\n        this.stream.peekNonWhitespace(index)?.type === TokenType.Dot &&\n        this.stream.peekNonWhitespace(index + 1)?.type === TokenType.Identifier\n      ) {\n        index += 2;\n      }\n      return this.stream.peekNonWhitespace(index)?.type === TokenType.Equals;\n    }\n\n    if (first.type === TokenType.At || first.type === TokenType.Dollar) {\n      const second = this.stream.peekNonWhitespace(1);\n      const third = this.stream.peekNonWhitespace(2);\n      return second?.type === TokenType.Identifier && third?.type === TokenType.Equals;\n    }\n\n    return false;\n  }\n\n  private isCallStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first || first.type !== TokenType.Identifier) {\n      return false;\n    }\n    let index = 1;\n    while (\n      this.stream.peekNonWhitespace(index)?.type === TokenType.Dot &&\n      this.stream.peekNonWhitespace(index + 1)?.type === TokenType.Identifier\n    ) {\n      index += 2;\n    }\n    return this.stream.peekNonWhitespace(index)?.type === TokenType.LParen;\n  }\n\n  private isFunctionDeclarationStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first) {\n      return false;\n    }\n    let index = 0;\n    if (this.isAsyncToken(first)) {\n      const next = this.stream.peekNonWhitespace(1);\n      if (!next || next.type !== TokenType.Identifier) {\n        return false;\n      }\n      index = 1;\n    } else if (first.type !== TokenType.Identifier) {\n      return false;\n    }\n    index += 1;\n    if (this.stream.peekNonWhitespace(index)?.type !== TokenType.LParen) {\n      return false;\n    }\n    index += 1;\n    let depth = 1;\n    while (true) {\n      const token = this.stream.peekNonWhitespace(index);\n      if (!token) {\n        return false;\n      }\n      if (token.type === TokenType.LParen) {\n        depth += 1;\n      } else if (token.type === TokenType.RParen) {\n        depth -= 1;\n        if (depth === 0) {\n          index += 1;\n          break;\n        }\n      }\n      index += 1;\n    }\n    return this.stream.peekNonWhitespace(index)?.type === TokenType.LBrace;\n  }\n\n  private isArrowFunctionStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first || first.type !== TokenType.LParen) {\n      return false;\n    }\n    let index = 1;\n    let depth = 1;\n    while (true) {\n      const token = this.stream.peekNonWhitespace(index);\n      if (!token) {\n        return false;\n      }\n      if (token.type === TokenType.LParen) {\n        depth += 1;\n      } else if (token.type === TokenType.RParen) {\n        depth -= 1;\n        if (depth === 0) {\n          index += 1;\n          break;\n        }\n      }\n      index += 1;\n    }\n    return this.stream.peekNonWhitespace(index)?.type === TokenType.Arrow;\n  }\n\n  private isAsyncArrowFunctionStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!this.isAsyncToken(first)) {\n      return false;\n    }\n    if (this.stream.peekNonWhitespace(1)?.type !== TokenType.LParen) {\n      return false;\n    }\n    let index = 2;\n    let depth = 1;\n    while (true) {\n      const token = this.stream.peekNonWhitespace(index);\n      if (!token) {\n        return false;\n      }\n      if (token.type === TokenType.LParen) {\n        depth += 1;\n      } else if (token.type === TokenType.RParen) {\n        depth -= 1;\n        if (depth === 0) {\n          index += 1;\n          break;\n        }\n      }\n      index += 1;\n    }\n    return this.stream.peekNonWhitespace(index)?.type === TokenType.Arrow;\n  }\n\n  private isFunctionExpressionAssignmentStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first || first.type !== TokenType.Identifier) {\n      return false;\n    }\n    if (this.stream.peekNonWhitespace(1)?.type !== TokenType.Equals) {\n      return false;\n    }\n    let index = 2;\n    if (this.isAsyncToken(this.stream.peekNonWhitespace(index))) {\n      index += 1;\n    }\n    if (this.stream.peekNonWhitespace(index)?.type !== TokenType.LParen) {\n      return false;\n    }\n    index += 1;\n    let depth = 1;\n    while (true) {\n      const token = this.stream.peekNonWhitespace(index);\n      if (!token) {\n        return false;\n      }\n      if (token.type === TokenType.LParen) {\n        depth += 1;\n      } else if (token.type === TokenType.RParen) {\n        depth -= 1;\n        if (depth === 0) {\n          index += 1;\n          break;\n        }\n      }\n      index += 1;\n    }\n    return this.stream.peekNonWhitespace(index)?.type === TokenType.Arrow;\n  }\n\n  private parseExpressionStatement(): ExpressionNode {\n    const expr = this.parseExpression();\n    this.consumeStatementTerminator();\n    return expr;\n  }\n\n  private parseConstructBlock(): BlockNode {\n    this.stream.expect(TokenType.Construct);\n    const body = this.parseBlock({ allowDeclarations: false });\n    body.type = \"Construct\";\n    return body;\n  }\n\n  private parseDestructBlock(): BlockNode {\n    this.stream.expect(TokenType.Destruct);\n    const body = this.parseBlock({ allowDeclarations: false });\n    body.type = \"Destruct\";\n    return body;\n  }\n\n  private parseQueryExpression(): QueryExpression {\n    this.stream.expect(TokenType.Question);\n    let direction: \"self\" | \"descendant\" | \"ancestor\" = \"self\";\n\n    if (this.stream.peek()?.type === TokenType.Greater) {\n      this.stream.next();\n      direction = \"descendant\";\n    } else if (this.stream.peek()?.type === TokenType.Less) {\n      this.stream.next();\n      direction = \"ancestor\";\n    }\n\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    const selector = this.readSelectorUntil(TokenType.RParen);\n    return new QueryExpression(direction, selector);\n  }\n\n  private parseFunctionDeclaration(): FunctionDeclarationNode {\n    let isAsync = false;\n    const first = this.stream.peekNonWhitespace(0);\n    if (this.isAsyncToken(first)) {\n      this.stream.next();\n      this.stream.skipWhitespace();\n      isAsync = true;\n    }\n    const name = this.stream.expect(TokenType.Identifier).value;\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    const params: string[] = [];\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated function parameters\");\n      }\n      if (next.type === TokenType.RParen) {\n        this.stream.next();\n        break;\n      }\n      const param = this.stream.expect(TokenType.Identifier).value;\n      params.push(param);\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.Comma) {\n        this.stream.next();\n        continue;\n      }\n      if (this.stream.peek()?.type === TokenType.RParen) {\n        this.stream.next();\n        break;\n      }\n      throw new Error(\"Expected ',' or ')' in function parameters\");\n    }\n    this.stream.skipWhitespace();\n    const body = this.parseFunctionBlockWithAwait(isAsync);\n    return new FunctionDeclarationNode(name, params, body, isAsync);\n  }\n\n  private parseFunctionBlock(): BlockNode {\n    return this.parseFunctionBlockWithAwait(false);\n  }\n\n  private parseReturnStatement(): ReturnNode {\n    this.stream.expect(TokenType.Return);\n    this.stream.skipWhitespace();\n    if (this.stream.peek()?.type === TokenType.Semicolon) {\n      this.stream.next();\n      return new ReturnNode();\n    }\n    const value = this.parseExpression();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Semicolon);\n    return new ReturnNode(value);\n  }\n\n  private parseArrowFunctionExpression(isAsync = false): FunctionExpression {\n    this.stream.expect(TokenType.LParen);\n    const params: string[] = [];\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated function parameters\");\n      }\n      if (next.type === TokenType.RParen) {\n        this.stream.next();\n        break;\n      }\n      const param = this.stream.expect(TokenType.Identifier).value;\n      params.push(param);\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.Comma) {\n        this.stream.next();\n        continue;\n      }\n      if (this.stream.peek()?.type === TokenType.RParen) {\n        this.stream.next();\n        break;\n      }\n      throw new Error(\"Expected ',' or ')' in function parameters\");\n    }\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Arrow);\n    this.stream.skipWhitespace();\n    if (this.stream.peek()?.type === TokenType.LBrace) {\n      const body = this.parseFunctionBlockWithAwait(isAsync);\n      return new FunctionExpression(params, body, isAsync);\n    }\n    const body = this.parseArrowExpressionBody(isAsync);\n    return new FunctionExpression(params, body, isAsync);\n  }\n\n  private readSelectorUntil(terminator: TokenType): string {\n    let selectorText = \"\";\n    let sawNonWhitespace = false;\n\n    while (true) {\n      const token = this.stream.peek();\n      if (!token) {\n        throw new Error(\"Unterminated selector\");\n      }\n      if (token.type === terminator) {\n        this.stream.next();\n        break;\n      }\n\n      if (token.type === TokenType.Whitespace) {\n        this.stream.next();\n        if (sawNonWhitespace && selectorText[selectorText.length - 1] !== \" \") {\n          selectorText += \" \";\n        }\n        continue;\n      }\n\n      sawNonWhitespace = true;\n      selectorText += this.stream.next().value;\n    }\n\n    return selectorText.trim();\n  }\n\n  private parseIdentifierPath(): string {\n    let value = this.stream.expect(TokenType.Identifier).value;\n    while (this.stream.peek()?.type === TokenType.Dot) {\n      this.stream.next();\n      const part = this.stream.expect(TokenType.Identifier).value;\n      value = `${value}.${part}`;\n    }\n    return value;\n  }\n}\n","export class Scope {\n  private data = new Map<string, any>();\n  private root: Scope;\n  private listeners = new Map<string, Set<() => void>>();\n  private anyListeners = new Set<() => void>();\n\n  constructor(public readonly parent?: Scope) {\n    this.root = parent ? parent.root : this;\n  }\n\n  get(key: string): any {\n    return this.getPath(key);\n  }\n\n  set(key: string, value: any): void {\n    this.setPath(key, value);\n  }\n\n  hasKey(path: string): boolean {\n    const parts = path.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return false;\n    }\n    return this.data.has(root);\n  }\n\n  getPath(path: string): any {\n    const explicit = path.startsWith(\"parent.\") || path.startsWith(\"root.\") || path.startsWith(\"self.\");\n    const { targetScope, targetPath } = this.resolveScope(path);\n    if (!targetScope || !targetPath) {\n      return undefined;\n    }\n\n    const localValue = this.getLocalPathValue(targetScope, targetPath);\n    if (explicit || localValue !== undefined) {\n      return localValue;\n    }\n    let cursor = targetScope.parent;\n    while (cursor) {\n      const value = this.getLocalPathValue(cursor, targetPath);\n      if (value !== undefined) {\n        return value;\n      }\n      cursor = cursor.parent;\n    }\n    return undefined;\n  }\n\n  setPath(path: string, value: any): void {\n    const explicit = path.startsWith(\"parent.\") || path.startsWith(\"root.\") || path.startsWith(\"self.\");\n    const { targetScope, targetPath } = this.resolveScope(path);\n    if (!targetScope || !targetPath) {\n      return;\n    }\n\n    const scopeForSet = explicit ? targetScope : this.findNearestScopeWithKey(targetScope, targetPath) ?? targetScope;\n    const parts = targetPath.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return;\n    }\n    if (parts.length === 1) {\n      scopeForSet.data.set(root, value);\n      scopeForSet.emitChange(targetPath);\n      return;\n    }\n    let obj = scopeForSet.data.get(root);\n    if (obj == null || typeof obj !== \"object\") {\n      obj = {};\n      scopeForSet.data.set(root, obj);\n    }\n    let cursor = obj;\n    for (let i = 1; i < parts.length - 1; i += 1) {\n      const key = parts[i];\n      if (!key) {\n        return;\n      }\n      if (cursor[key] == null || typeof cursor[key] !== \"object\") {\n        cursor[key] = {};\n      }\n      cursor = cursor[key];\n    }\n    const lastKey = parts[parts.length - 1];\n    if (!lastKey) {\n      return;\n    }\n    cursor[lastKey] = value;\n    scopeForSet.emitChange(targetPath);\n  }\n\n  on(path: string, handler: () => void): void {\n    const key = path.trim();\n    if (!key) {\n      return;\n    }\n    const set = this.listeners.get(key) ?? new Set<() => void>();\n    set.add(handler);\n    this.listeners.set(key, set);\n  }\n\n  off(path: string, handler: () => void): void {\n    const key = path.trim();\n    const set = this.listeners.get(key);\n    if (!set) {\n      return;\n    }\n    set.delete(handler);\n    if (set.size === 0) {\n      this.listeners.delete(key);\n    }\n  }\n\n  onAny(handler: () => void): void {\n    this.anyListeners.add(handler);\n  }\n\n  offAny(handler: () => void): void {\n    this.anyListeners.delete(handler);\n  }\n\n  private emitChange(path: string): void {\n    const key = path.trim();\n    if (!key) {\n      return;\n    }\n    this.listeners.get(key)?.forEach((fn) => fn());\n    const rootKey = key.split(\".\")[0];\n    if (rootKey && rootKey !== key) {\n      this.listeners.get(rootKey)?.forEach((fn) => fn());\n    }\n    this.anyListeners.forEach((fn) => fn());\n  }\n\n  private resolveScope(path: string): { targetScope: Scope | undefined; targetPath: string | undefined } {\n    let targetScope: Scope | undefined = this;\n    let targetPath = path;\n    while (targetPath.startsWith(\"parent.\")) {\n      targetScope = targetScope?.parent;\n      targetPath = targetPath.slice(\"parent.\".length);\n    }\n    if (targetPath.startsWith(\"root.\")) {\n      targetScope = targetScope?.root;\n      targetPath = targetPath.slice(\"root.\".length);\n    }\n    while (targetPath.startsWith(\"self.\")) {\n      targetScope = targetScope ?? this;\n      targetPath = targetPath.slice(\"self.\".length);\n    }\n    return { targetScope, targetPath };\n  }\n\n  private getLocalPathValue(scope: Scope, path: string): any {\n    const parts = path.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return undefined;\n    }\n    let value = scope.data.get(root);\n    for (let i = 1; i < parts.length; i += 1) {\n      if (value == null) {\n        return undefined;\n      }\n      const key = parts[i];\n      if (!key) {\n        return undefined;\n      }\n      value = value[key];\n    }\n    return value;\n  }\n\n  private findNearestScopeWithKey(start: Scope, path: string): Scope | undefined {\n    const root = path.split(\".\")[0];\n    if (!root) {\n      return undefined;\n    }\n    let cursor: Scope | undefined = start;\n    while (cursor) {\n      if (cursor.data.has(root)) {\n        return cursor;\n      }\n      cursor = cursor.parent;\n    }\n    return undefined;\n  }\n}\n","import { Scope } from \"./scope\";\n\nexport type BindDirection = \"both\" | \"from\" | \"to\";\n\nfunction getElementValue(element: Element): string {\n  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n    return element.value;\n  }\n  return element.textContent ?? \"\";\n}\n\nfunction setElementValue(element: Element, value: string): void {\n  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n    element.value = value;\n    element.setAttribute(\"value\", value);\n    return;\n  }\n  if (element instanceof HTMLElement && element.querySelector(\"*\")) {\n    return;\n  }\n  element.textContent = value;\n}\n\nexport function applyBindToScope(element: Element, expression: string, scope: Scope): void {\n  const key = expression.trim();\n  if (!key) {\n    return;\n  }\n\n  const value = getElementValue(element).trim();\n  if (value !== \"\") {\n    scope.set(key, value);\n  }\n}\n\nexport function applyBindToElement(element: Element, expression: string, scope: Scope): void {\n  const key = expression.trim();\n  if (!key) {\n    return;\n  }\n  const value = scope.get(key);\n  if (value == null) {\n    return;\n  }\n  setElementValue(element, String(value));\n}\n","import { Scope } from \"./scope\";\n\nfunction readCondition(expression: string, scope: Scope): boolean {\n  const key = expression.trim();\n  if (!key) {\n    return false;\n  }\n  return !!scope.get(key);\n}\n\nexport function applyIf(element: HTMLElement, expression: string, scope: Scope): void {\n  element.style.display = readCondition(expression, scope) ? \"\" : \"none\";\n}\n\nexport function applyShow(element: HTMLElement, expression: string, scope: Scope): void {\n  element.style.display = readCondition(expression, scope) ? \"\" : \"none\";\n}\n","import { Scope } from \"./scope\";\n\nfunction sanitizeHtml(value: string): string {\n  return value.replace(/<script\\b[^>]*>[\\s\\S]*?<\\/script>/gi, \"\");\n}\n\nexport function applyHtml(\n  element: HTMLElement,\n  expression: string,\n  scope: Scope,\n  trusted: boolean\n): void {\n  const key = expression.trim();\n  if (!key) {\n    return;\n  }\n  const value = scope.get(key);\n  const html = value == null ? \"\" : String(value);\n  element.innerHTML = trusted ? html : sanitizeHtml(html);\n}\n","import { applyHtml } from \"./html\";\nimport { Scope } from \"./scope\";\n\nexport interface GetConfig {\n  url: string;\n  targetSelector?: string;\n  swap?: \"inner\" | \"outer\";\n  trusted: boolean;\n}\n\nexport async function applyGet(\n  element: Element,\n  config: GetConfig,\n  scope: Scope,\n  onHtmlApplied?: (target: Element) => void\n): Promise<void> {\n  if (!globalThis.fetch) {\n    throw new Error(\"fetch is not available\");\n  }\n\n  const response = await globalThis.fetch(config.url);\n  if (!response || !response.ok) {\n    return;\n  }\n\n  const html = await response.text();\n  const target = resolveTarget(element, config.targetSelector);\n  if (!target) {\n    element.dispatchEvent(new CustomEvent(\"vsn:targetError\", { detail: { selector: config.targetSelector } }));\n    return;\n  }\n\n  if (config.swap === \"outer\") {\n    const wrapper = document.createElement(\"div\");\n    applyHtml(wrapper, \"__html\", { get: () => html } as Scope, config.trusted);\n    const replacement = wrapper.firstElementChild;\n    if (replacement && target.parentNode) {\n      target.parentNode.replaceChild(replacement, target);\n      onHtmlApplied?.(replacement);\n    }\n    return;\n  }\n\n  applyHtml(target as HTMLElement, \"__html\", { get: () => html } as Scope, config.trusted);\n  onHtmlApplied?.(target);\n}\n\nfunction resolveTarget(element: Element, selector?: string): Element | null {\n  if (!selector) {\n    return element;\n  }\n  return element.ownerDocument.querySelector(selector);\n}\n","type Debounced = (...args: any[]) => void;\n\nexport function debounce<T extends (...args: any[]) => void>(fn: T, waitMs: number): Debounced {\n  let timer: ReturnType<typeof setTimeout> | undefined;\n  return (...args: any[]) => {\n    if (timer) {\n      clearTimeout(timer);\n    }\n    timer = setTimeout(() => {\n      timer = undefined;\n      fn(...args);\n    }, waitMs);\n  };\n}\n","import { Scope } from \"./scope\";\nimport { applyBindToElement, applyBindToScope, BindDirection } from \"./bindings\";\nimport { applyIf, applyShow } from \"./conditionals\";\nimport { applyHtml } from \"./html\";\nimport { applyGet, GetConfig } from \"./http\";\nimport { debounce } from \"./debounce\";\nimport { Parser } from \"../parser/parser\";\nimport {\n  AssignmentNode,\n  BehaviorNode,\n  BlockNode,\n  DeclarationNode,\n  DirectiveExpression,\n  ExecutionContext,\n  ExpressionNode,\n  FunctionDeclarationNode,\n  FunctionExpression,\n  IdentifierExpression,\n  OnBlockNode\n} from \"../ast/nodes\";\n\ninterface OnConfig {\n  event: string;\n  code: string;\n  debounceMs?: number;\n  modifiers?: string[];\n  keyModifiers?: string[];\n}\n\ninterface BindConfig {\n  expr: string;\n  direction: BindDirection;\n}\n\ninterface LifecycleConfig {\n  construct?: string;\n  destruct?: string;\n}\n\ninterface RegisteredBehavior {\n  id: number;\n  selector: string;\n  specificity: number;\n  order: number;\n  construct?: BlockNode;\n  destruct?: BlockNode;\n  onBlocks: { event: string; body: BlockNode; modifiers: string[] }[];\n  declarations: DeclarationNode[];\n  functions: FunctionBinding[];\n}\n\ntype FunctionBinding = {\n  name: string;\n  params: string[];\n  body: BlockNode;\n};\n\ntype AttributeHandler = {\n  id: string;\n  match: (name: string) => boolean;\n  handle: (element: Element, name: string, value: string, scope: Scope) => boolean | void;\n};\n\ntype EachBinding = {\n  listExpr: string;\n  itemName: string;\n  indexName?: string;\n  rendered: Element[];\n};\n\ntype CachedBehavior = {\n  construct?: BlockNode;\n  destruct?: BlockNode;\n  onBlocks: { event: string; body: BlockNode; modifiers: string[] }[];\n  declarations: DeclarationNode[];\n  functions: FunctionBinding[];\n};\n\ntype BehaviorListener = {\n  event: string;\n  handler: (event?: Event) => void;\n  options?: AddEventListenerOptions | undefined;\n};\n\ntype FlagApplyContext = {\n  name: string;\n  args: any;\n  element: Element;\n  scope: Scope;\n  declaration: DeclarationNode;\n};\n\ntype FlagHandler = {\n  onApply?: (context: FlagApplyContext) => void;\n};\n\nexport class Engine {\n  private scopes = new WeakMap<Element, Scope>();\n  private bindBindings = new WeakMap<Element, BindConfig>();\n  private ifBindings = new WeakMap<Element, string>();\n  private showBindings = new WeakMap<Element, string>();\n  private htmlBindings = new WeakMap<Element, { expr: string; trusted: boolean }>();\n  private getBindings = new WeakMap<Element, GetConfig>();\n  private eachBindings = new WeakMap<Element, EachBinding>();\n  private lifecycleBindings = new WeakMap<Element, LifecycleConfig>();\n  private behaviorRegistry: RegisteredBehavior[] = [];\n  private behaviorBindings = new WeakMap<Element, Set<number>>();\n  private behaviorListeners = new WeakMap<Element, Map<number, BehaviorListener[]>>();\n  private behaviorId = 0;\n  private codeCache = new Map<string, BlockNode>();\n  private behaviorCache = new Map<string, CachedBehavior>();\n  private observer?: MutationObserver;\n  private attributeHandlers: AttributeHandler[] = [];\n  private globals: Record<string, any> = {};\n  private importantFlags = new WeakMap<Element, Set<string>>();\n  private inlineDeclarations = new WeakMap<Element, Set<string>>();\n  private flagHandlers = new Map<string, FlagHandler>();\n  private pendingAdded = new Set<Element>();\n  private pendingRemoved = new Set<Element>();\n  private pendingUpdated = new Set<Element>();\n  private observerFlush?: () => void;\n\n  constructor() {\n    this.registerGlobal(\"console\", console);\n    this.registerGlobal(\"list\", {\n      async map(items: any[], fn: (item: any, index: number) => any) {\n        if (!Array.isArray(items) || typeof fn !== \"function\") {\n          return [];\n        }\n        const results = [];\n        for (let i = 0; i < items.length; i += 1) {\n          results.push(await fn(items[i], i));\n        }\n        return results;\n      },\n      async filter(items: any[], fn: (item: any, index: number) => any) {\n        if (!Array.isArray(items) || typeof fn !== \"function\") {\n          return [];\n        }\n        const results = [];\n        for (let i = 0; i < items.length; i += 1) {\n          if (await fn(items[i], i)) {\n            results.push(items[i]);\n          }\n        }\n        return results;\n      },\n      async reduce(items: any[], fn: (acc: any, item: any, index: number) => any, initial?: any) {\n        if (!Array.isArray(items) || typeof fn !== \"function\") {\n          return initial;\n        }\n        const hasInitial = arguments.length > 2;\n        let acc = hasInitial ? initial : items[0];\n        let start = hasInitial ? 0 : 1;\n        for (let i = start; i < items.length; i += 1) {\n          acc = await fn(acc, items[i], i);\n        }\n        return acc;\n      }\n    });\n    this.registerDefaultAttributeHandlers();\n  }\n\n  async mount(root: HTMLElement): Promise<void> {\n    const elements: Element[] = [root, ...Array.from(root.querySelectorAll(\"*\"))];\n    for (const element of elements) {\n      if (!this.hasVsnAttributes(element)) {\n        continue;\n      }\n      const parentScope = this.findParentScope(element);\n      this.getScope(element, parentScope);\n      this.attachAttributes(element);\n      this.runConstruct(element);\n    }\n    await this.applyBehaviors(root);\n    this.attachObserver(root);\n  }\n\n  unmount(element: Element): void {\n    this.runDestruct(element);\n  }\n\n  registerBehaviors(source: string): void {\n    const program = new Parser(source, { customFlags: new Set(this.flagHandlers.keys()) }).parseProgram();\n    for (const use of program.uses) {\n      const value = this.resolveGlobalPath(use.name);\n      if (value === undefined) {\n        console.warn(`vsn: global '${use.name}' not found`);\n        continue;\n      }\n      this.registerGlobal(use.alias, value);\n    }\n    for (const behavior of program.behaviors) {\n      this.collectBehavior(behavior);\n    }\n  }\n\n  registerGlobal(name: string, value: any): void {\n    this.globals[name] = value;\n  }\n\n  registerGlobals(values: Record<string, any>): void {\n    Object.assign(this.globals, values);\n  }\n\n  registerFlag(name: string, handler: FlagHandler = {}): void {\n    const reserved = new Set([\"important\", \"trusted\", \"debounce\"]);\n    if (reserved.has(name)) {\n      throw new Error(`Flag '${name}' is reserved`);\n    }\n    this.flagHandlers.set(name, handler);\n  }\n\n  getRegistryStats(): { behaviorCount: number; behaviorCacheSize: number } {\n    return {\n      behaviorCount: this.behaviorRegistry.length,\n      behaviorCacheSize: this.behaviorCache.size\n    };\n  }\n\n  registerAttributeHandler(handler: AttributeHandler): void {\n    this.attributeHandlers.push(handler);\n  }\n\n  private resolveGlobalPath(name: string): any {\n    const parts = name.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return undefined;\n    }\n    let value: any = (globalThis as any)[root];\n    for (let i = 1; i < parts.length; i += 1) {\n      const part = parts[i];\n      if (!part) {\n        return undefined;\n      }\n      value = value?.[part];\n    }\n    return value;\n  }\n\n  getScope(element: Element, parentScope?: Scope): Scope {\n    const existing = this.scopes.get(element);\n    if (existing) {\n      return existing;\n    }\n    const scope = new Scope(parentScope ?? this.findParentScope(element));\n    this.scopes.set(element, scope);\n    return scope;\n  }\n\n  evaluate(element: Element): void {\n    const scope = this.getScope(element);\n    const bindConfig = this.bindBindings.get(element);\n    if (bindConfig && (bindConfig.direction === \"from\" || bindConfig.direction === \"both\")) {\n      applyBindToElement(element, bindConfig.expr, scope);\n    }\n    const ifExpr = this.ifBindings.get(element);\n    if (ifExpr && element instanceof HTMLElement) {\n      applyIf(element, ifExpr, scope);\n    }\n    const showExpr = this.showBindings.get(element);\n    if (showExpr && element instanceof HTMLElement) {\n      applyShow(element, showExpr, scope);\n    }\n    const htmlBinding = this.htmlBindings.get(element);\n    if (htmlBinding && element instanceof HTMLElement) {\n      applyHtml(element, htmlBinding.expr, scope, htmlBinding.trusted);\n      if (htmlBinding.trusted) {\n        this.handleTrustedHtml(element);\n      }\n    }\n  }\n\n  private attachObserver(root: HTMLElement): void {\n    if (this.observer) {\n      return;\n    }\n    this.observerFlush = debounce(() => this.flushObserverQueue(), 10);\n    this.observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type === \"attributes\" && mutation.target instanceof Element) {\n          this.pendingUpdated.add(mutation.target);\n        }\n        for (const node of Array.from(mutation.addedNodes)) {\n          if (node && node.nodeType === 1) {\n            this.pendingAdded.add(node as Element);\n          }\n        }\n        for (const node of Array.from(mutation.removedNodes)) {\n          if (node && node.nodeType === 1) {\n            this.pendingRemoved.add(node as Element);\n          }\n        }\n      }\n      this.observerFlush?.();\n    });\n    this.observer.observe(root, { childList: true, subtree: true, attributes: true, attributeFilter: [\"class\"] });\n  }\n\n  private flushObserverQueue(): void {\n    const removed = Array.from(this.pendingRemoved);\n    this.pendingRemoved.clear();\n    for (const node of removed) {\n      this.handleRemovedNode(node);\n    }\n    const updated = Array.from(this.pendingUpdated);\n    this.pendingUpdated.clear();\n    for (const node of updated) {\n      this.handleUpdatedNode(node);\n    }\n    const added = Array.from(this.pendingAdded);\n    this.pendingAdded.clear();\n    for (const node of added) {\n      this.handleAddedNode(node);\n    }\n  }\n\n  private handleRemovedNode(node: Element): void {\n    if (this.lifecycleBindings.has(node)) {\n      this.runDestruct(node);\n    }\n    if (this.behaviorBindings.has(node)) {\n      this.runBehaviorDestruct(node);\n    }\n    for (const child of Array.from(node.querySelectorAll(\"*\"))) {\n      if (this.lifecycleBindings.has(child)) {\n        this.runDestruct(child);\n      }\n      if (this.behaviorBindings.has(child)) {\n        this.runBehaviorDestruct(child);\n      }\n    }\n  }\n\n  private handleAddedNode(node: Element): void {\n    const elements = [node, ...Array.from(node.querySelectorAll(\"*\"))];\n    for (const element of elements) {\n      if (!this.hasVsnAttributes(element)) {\n        continue;\n      }\n      const parentScope = this.findParentScope(element);\n      this.getScope(element, parentScope);\n      this.attachAttributes(element);\n      this.runConstruct(element);\n    }\n    void this.applyBehaviors(node);\n  }\n\n  private handleUpdatedNode(node: Element): void {\n    const elements = [node, ...Array.from(node.querySelectorAll(\"*\"))];\n    for (const element of elements) {\n      void this.reapplyBehaviorsForElement(element);\n    }\n  }\n\n  private async applyBehaviors(root: Element): Promise<void> {\n    if (this.behaviorRegistry.length === 0) {\n      return;\n    }\n    const elements: Element[] = [root, ...Array.from(root.querySelectorAll(\"*\"))];\n    for (const element of elements) {\n      await this.reapplyBehaviorsForElement(element);\n    }\n  }\n\n  private async reapplyBehaviorsForElement(element: Element): Promise<void> {\n    if (this.behaviorRegistry.length === 0) {\n      return;\n    }\n    const bound = this.behaviorBindings.get(element) ?? new Set<number>();\n    const scope = this.getScope(element);\n    const matched = this.behaviorRegistry\n      .filter((behavior) => element.matches(behavior.selector))\n      .sort((a, b) => {\n        if (a.specificity !== b.specificity) {\n          return a.specificity - b.specificity;\n        }\n        return a.order - b.order;\n      });\n\n    for (const behavior of matched) {\n      if (!bound.has(behavior.id)) {\n        await this.applyBehaviorForElement(behavior, element, scope, bound);\n      }\n    }\n\n    const matchedIds = new Set(matched.map((behavior) => behavior.id));\n    for (const behavior of this.behaviorRegistry) {\n      if (bound.has(behavior.id) && !matchedIds.has(behavior.id)) {\n        this.unbindBehaviorForElement(behavior, element, scope, bound);\n      }\n    }\n    this.behaviorBindings.set(element, bound);\n  }\n\n  private async applyBehaviorForElement(\n    behavior: RegisteredBehavior,\n    element: Element,\n    scope: Scope,\n    bound: Set<number>\n  ): Promise<void> {\n    bound.add(behavior.id);\n    this.applyBehaviorFunctions(element, scope, behavior.functions);\n    await this.applyBehaviorDeclarations(element, scope, behavior.declarations);\n    if (behavior.construct) {\n      await this.executeBlock(behavior.construct, scope, element);\n    }\n    for (const onBlock of behavior.onBlocks) {\n      this.attachBehaviorOnHandler(element, onBlock.event, onBlock.body, onBlock.modifiers, behavior.id);\n    }\n  }\n\n  private unbindBehaviorForElement(\n    behavior: RegisteredBehavior,\n    element: Element,\n    scope: Scope,\n    bound: Set<number>\n  ): void {\n    bound.delete(behavior.id);\n    if (behavior.destruct) {\n      void this.executeBlock(behavior.destruct, scope, element);\n    }\n    const listenerMap = this.behaviorListeners.get(element);\n    const listeners = listenerMap?.get(behavior.id);\n    if (listeners) {\n      for (const listener of listeners) {\n        element.removeEventListener(listener.event, listener.handler, listener.options);\n      }\n      listenerMap?.delete(behavior.id);\n    }\n  }\n\n  private runBehaviorDestruct(element: Element): void {\n    const bound = this.behaviorBindings.get(element);\n    if (!bound) {\n      return;\n    }\n    const scope = this.getScope(element);\n    for (const behavior of this.behaviorRegistry) {\n      if (!bound.has(behavior.id) || !behavior.destruct) {\n        continue;\n      }\n      void this.executeBlock(behavior.destruct, scope, element);\n    }\n  }\n\n  private attachAttributes(element: Element): void {\n    const scope = this.getScope(element);\n    for (const name of element.getAttributeNames()) {\n      if (!name.startsWith(\"vsn-\")) {\n        continue;\n      }\n      const value = element.getAttribute(name) ?? \"\";\n      for (const handler of this.attributeHandlers) {\n        if (!handler.match(name)) {\n          continue;\n        }\n        const handled = handler.handle(element, name, value, scope);\n        if (handled !== false) {\n          break;\n        }\n      }\n    }\n  }\n\n  private setLifecycle(element: Element, patch: LifecycleConfig): void {\n    const current = this.lifecycleBindings.get(element) ?? {};\n    this.lifecycleBindings.set(element, { ...current, ...patch });\n  }\n\n  private runConstruct(element: Element): void {\n    const config = this.lifecycleBindings.get(element);\n    if (!config?.construct) {\n      return;\n    }\n    const scope = this.getScope(element);\n    this.execute(config.construct, scope, element);\n  }\n\n  private runDestruct(element: Element): void {\n    const config = this.lifecycleBindings.get(element);\n    if (!config?.destruct) {\n      return;\n    }\n    const scope = this.getScope(element);\n    this.execute(config.destruct, scope, element);\n  }\n\n  private parseEachExpression(value: string): { listExpr: string; itemName: string; indexName?: string } | null {\n    const [listPart, rest] = value.split(/\\s+as\\s+/);\n    if (!listPart || !rest) {\n      return null;\n    }\n    const listExpr = listPart.trim();\n    const names = rest.split(\",\").map((entry) => entry.trim()).filter(Boolean);\n    if (!listExpr || names.length === 0) {\n      return null;\n    }\n    const itemName = names[0] ?? \"\";\n    const indexName = names[1];\n    return { listExpr, itemName, ...(indexName ? { indexName } : {}) };\n  }\n\n  private renderEach(element: Element): void {\n    const binding = this.eachBindings.get(element);\n    if (!binding) {\n      return;\n    }\n    if (!(element instanceof HTMLTemplateElement)) {\n      return;\n    }\n    const parent = element.parentElement;\n    if (!parent) {\n      return;\n    }\n\n    for (const node of binding.rendered) {\n      this.handleRemovedNode(node);\n      if (node.parentNode) {\n        node.parentNode.removeChild(node);\n      }\n    }\n    binding.rendered = [];\n\n    const scope = this.getScope(element);\n    const list = scope.get(binding.listExpr);\n    if (!Array.isArray(list)) {\n      return;\n    }\n\n    const rendered: Element[] = [];\n    list.forEach((item, index) => {\n      const fragment = element.content.cloneNode(true) as DocumentFragment;\n      const roots = Array.from(fragment.children) as Element[];\n      const itemScope = new Scope(scope);\n      itemScope.setPath(binding.itemName, item);\n      if (binding.indexName) {\n        itemScope.setPath(binding.indexName, index);\n      }\n      for (const root of roots) {\n        this.getScope(root, itemScope);\n      }\n      parent.insertBefore(fragment, element);\n      for (const root of roots) {\n        rendered.push(root);\n        this.handleAddedNode(root);\n        this.evaluate(root);\n        for (const child of Array.from(root.querySelectorAll(\"*\"))) {\n          this.evaluate(child);\n        }\n      }\n    });\n    binding.rendered = rendered;\n  }\n\n  private attachBindInputHandler(element: Element, expr: string): void {\n    if (!(element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement)) {\n      return;\n    }\n    const handler = () => {\n      const scope = this.getScope(element);\n      applyBindToScope(element, expr, scope);\n    };\n    element.addEventListener(\"input\", handler);\n    element.addEventListener(\"change\", handler);\n  }\n\n  private parseBindDirection(name: string): BindDirection {\n    if (name.includes(\":from\")) {\n      return \"from\";\n    }\n    if (name.includes(\":to\")) {\n      return \"to\";\n    }\n    return \"both\";\n  }\n\n  private hasVsnAttributes(element: Element): boolean {\n    return element.getAttributeNames().some((name) => name.startsWith(\"vsn-\"));\n  }\n\n  private markInlineDeclaration(element: Element, key: string): void {\n    const set = this.inlineDeclarations.get(element) ?? new Set<string>();\n    set.add(key);\n    this.inlineDeclarations.set(element, set);\n  }\n\n  private isInlineDeclaration(element: Element, key: string): boolean {\n    const set = this.inlineDeclarations.get(element);\n    return set ? set.has(key) : false;\n  }\n\n  private findParentScope(element: Element): Scope | undefined {\n    let parent = element.parentElement;\n    while (parent) {\n      const scope = this.scopes.get(parent);\n      if (scope) {\n        return scope;\n      }\n      parent = parent.parentElement;\n    }\n    return undefined;\n  }\n\n  private watch(scope: Scope, expr: string, handler: () => void): void {\n    const key = expr.trim();\n    if (!key) {\n      return;\n    }\n    const root = key.split(\".\")[0];\n    if (!root) {\n      return;\n    }\n    let target: Scope | undefined = scope;\n    while (target && !target.hasKey(root)) {\n      target = target.parent;\n    }\n    if (target) {\n      target.on(key, handler);\n      return;\n    }\n    let cursor: Scope | undefined = scope;\n    while (cursor) {\n      cursor.on(key, handler);\n      cursor = cursor.parent;\n    }\n  }\n\n  private watchWithDebounce(scope: Scope, expr: string, handler: () => void, debounceMs?: number): void {\n    if (debounceMs) {\n      this.watch(scope, expr, debounce(handler, debounceMs));\n    } else {\n      this.watch(scope, expr, handler);\n    }\n  }\n\n  private watchAllScopes(scope: Scope, handler: () => void, debounceMs?: number): void {\n    const effectiveHandler = debounceMs ? debounce(handler, debounceMs) : handler;\n    let cursor: Scope | undefined = scope;\n    while (cursor) {\n      cursor.onAny(effectiveHandler);\n      cursor = cursor.parent;\n    }\n  }\n\n  private parseOnAttribute(name: string, value: string): OnConfig | null {\n    if (!name.startsWith(\"vsn-on:\")) {\n      return null;\n    }\n\n    const eventWithFlags = name.slice(\"vsn-on:\".length);\n    const [event, ...flags] = eventWithFlags.split(\"!\");\n    if (!event) {\n      return null;\n    }\n    const descriptor = this.parseEventDescriptor(event);\n    if (!descriptor.event) {\n      return null;\n    }\n\n    let debounceMs: number | undefined;\n    const modifiers: string[] = [];\n    for (const flag of flags) {\n      if (flag.startsWith(\"debounce\")) {\n        const match = flag.match(/debounce\\((\\d+)\\)/);\n        debounceMs = match ? Number(match[1]) : 200;\n        continue;\n      }\n      modifiers.push(flag);\n    }\n\n    const config: OnConfig = {\n      event: descriptor.event,\n      code: value,\n      ...(debounceMs !== undefined ? { debounceMs } : {}),\n      ...(modifiers.length > 0 ? { modifiers } : {}),\n      ...(descriptor.keyModifiers.length > 0 ? { keyModifiers: descriptor.keyModifiers } : {})\n    };\n    return config;\n  }\n\n  private parseEventDescriptor(raw: string): { event: string; keyModifiers: string[] } {\n    const parts = raw.split(\".\").map((part) => part.trim()).filter(Boolean);\n    const event = parts.shift() ?? \"\";\n    return { event, keyModifiers: parts };\n  }\n\n  private matchesKeyModifiers(event: Event | undefined, keyModifiers?: string[]): boolean {\n    if (!keyModifiers || keyModifiers.length === 0) {\n      return true;\n    }\n    if (!(event instanceof KeyboardEvent)) {\n      return false;\n    }\n    const modifierChecks: Record<string, boolean> = {\n      shift: event.shiftKey,\n      ctrl: event.ctrlKey,\n      control: event.ctrlKey,\n      alt: event.altKey,\n      meta: event.metaKey\n    };\n    const keyAliases: Record<string, string> = {\n      esc: \"escape\",\n      escape: \"escape\",\n      enter: \"enter\",\n      tab: \"tab\",\n      space: \"space\",\n      spacebar: \"space\",\n      up: \"arrowup\",\n      down: \"arrowdown\",\n      left: \"arrowleft\",\n      right: \"arrowright\",\n      arrowup: \"arrowup\",\n      arrowdown: \"arrowdown\",\n      arrowleft: \"arrowleft\",\n      arrowright: \"arrowright\",\n      delete: \"delete\",\n      backspace: \"backspace\"\n    };\n    let key = event.key?.toLowerCase() ?? \"\";\n    if (key === \" \") {\n      key = \"space\";\n    }\n\n    for (const rawModifier of keyModifiers) {\n      const modifier = rawModifier.toLowerCase();\n      if (modifier in modifierChecks) {\n        if (!modifierChecks[modifier]) {\n          return false;\n        }\n        continue;\n      }\n      const expectedKey = keyAliases[modifier] ?? modifier;\n      if (key !== expectedKey) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private attachOnHandler(element: Element, config: OnConfig): void {\n    const handler = async (event?: Event) => {\n      if (!this.matchesKeyModifiers(event, config.keyModifiers)) {\n        return;\n      }\n      this.applyEventModifiers(event, config.modifiers);\n      const scope = this.getScope(element);\n      await this.execute(config.code, scope, element);\n      this.evaluate(element);\n    };\n    const effectiveHandler = config.debounceMs ? debounce(handler, config.debounceMs) : handler;\n    element.addEventListener(config.event, effectiveHandler, this.getListenerOptions(config.modifiers));\n  }\n\n  private attachBehaviorOnHandler(\n    element: Element,\n    event: string,\n    body: BlockNode,\n    modifiers: string[] | undefined,\n    behaviorId: number\n  ): void {\n    const descriptor = this.parseEventDescriptor(event);\n    const handler = async (evt?: Event) => {\n      if (!this.matchesKeyModifiers(evt, descriptor.keyModifiers)) {\n        return;\n      }\n      this.applyEventModifiers(evt, modifiers);\n      const scope = this.getScope(element);\n      await this.executeBlock(body, scope, element);\n      this.evaluate(element);\n    };\n    const options = this.getListenerOptions(modifiers);\n    element.addEventListener(descriptor.event, handler, options);\n    const listenerMap = this.behaviorListeners.get(element) ?? new Map<number, BehaviorListener[]>();\n    const listeners = listenerMap.get(behaviorId) ?? [];\n    listeners.push({ event: descriptor.event, handler, options });\n    listenerMap.set(behaviorId, listeners);\n    this.behaviorListeners.set(element, listenerMap);\n  }\n\n  private attachGetHandler(element: Element, autoLoad = false): void {\n    const handler = async () => {\n      const config = this.getBindings.get(element);\n      if (!config) {\n        return;\n      }\n      try {\n        await applyGet(element, config, this.getScope(element), (target) => {\n          if (config.trusted) {\n            this.handleTrustedHtml(target);\n          }\n        });\n      } catch (error) {\n        console.warn(\"vsn:getError\", error);\n        element.dispatchEvent(new CustomEvent(\"vsn:getError\", { detail: { error }, bubbles: true }));\n      }\n    };\n\n    element.addEventListener(\"click\", (event) => {\n      if (event.target !== element) {\n        return;\n      }\n      void handler();\n    });\n    if (autoLoad) {\n      Promise.resolve().then(handler);\n    }\n  }\n\n  private applyEventModifiers(event: Event | undefined, modifiers?: string[]): void {\n    if (!event || !modifiers || modifiers.length === 0) {\n      return;\n    }\n    for (const modifier of modifiers) {\n      if (modifier === \"prevent\") {\n        event.preventDefault();\n      } else if (modifier === \"stop\") {\n        event.stopPropagation();\n      }\n    }\n  }\n\n  private getListenerOptions(modifiers?: string[]): AddEventListenerOptions | undefined {\n    if (!modifiers || modifiers.length === 0) {\n      return undefined;\n    }\n    const options: AddEventListenerOptions = {};\n    if (modifiers.includes(\"once\")) {\n      options.once = true;\n    }\n    if (modifiers.includes(\"passive\")) {\n      options.passive = true;\n    }\n    if (modifiers.includes(\"capture\")) {\n      options.capture = true;\n    }\n    return Object.keys(options).length > 0 ? options : undefined;\n  }\n\n  private async execute(code: string, scope: Scope, element?: Element): Promise<void> {\n    let block = this.codeCache.get(code);\n    if (!block) {\n      block = Parser.parseInline(code);\n      this.codeCache.set(code, block);\n    }\n    const context: ExecutionContext = {\n      scope,\n      globals: this.globals,\n      ...(element ? { element } : {})\n    };\n    await block.evaluate(context);\n  }\n\n  private async executeBlock(block: BlockNode, scope: Scope, element?: Element): Promise<void> {\n    const context: ExecutionContext = {\n      scope,\n      globals: this.globals,\n      ...(element ? { element } : {})\n    };\n    await block.evaluate(context);\n  }\n\n  private collectBehavior(behavior: BehaviorNode, parentSelector?: string): void {\n    const selector = parentSelector\n      ? `${parentSelector} ${behavior.selector.selectorText}`\n      : behavior.selector.selectorText;\n    const cached = this.getCachedBehavior(behavior);\n    this.behaviorRegistry.push({\n      id: this.behaviorId += 1,\n      selector,\n      specificity: this.computeSpecificity(selector),\n      order: this.behaviorRegistry.length,\n      ...cached\n    });\n    for (const statement of behavior.body.statements) {\n      if (statement instanceof BehaviorNode) {\n        this.collectBehavior(statement, selector);\n      }\n    }\n  }\n\n  private computeSpecificity(selector: string): number {\n    const idMatches = selector.match(/#[\\w-]+/g)?.length ?? 0;\n    const classMatches = selector.match(/\\.[\\w-]+/g)?.length ?? 0;\n    const attrMatches = selector.match(/\\[[^\\]]+\\]/g)?.length ?? 0;\n    const pseudoMatches = selector.match(/:[\\w-]+/g)?.length ?? 0;\n    const elementMatches = selector.match(/(^|[\\s>+~])([a-zA-Z][\\w-]*)/g)?.length ?? 0;\n    return idMatches * 100 + (classMatches + attrMatches + pseudoMatches) * 10 + elementMatches;\n  }\n\n\n  private getImportantKey(declaration: DeclarationNode): string | undefined {\n    if (declaration.target instanceof IdentifierExpression) {\n      return `state:${declaration.target.name}`;\n    }\n    if (declaration.target instanceof DirectiveExpression) {\n      return `${declaration.target.kind}:${declaration.target.name}`;\n    }\n    return undefined;\n  }\n\n  private isImportant(element: Element, key: string): boolean {\n    const set = this.importantFlags.get(element);\n    return set ? set.has(key) : false;\n  }\n\n  private markImportant(element: Element, key: string): void {\n    const set = this.importantFlags.get(element) ?? new Set<string>();\n    set.add(key);\n    this.importantFlags.set(element, set);\n  }\n\n  private extractLifecycle(body: BlockNode): { construct?: BlockNode; destruct?: BlockNode } {\n    let construct: BlockNode | undefined;\n    let destruct: BlockNode | undefined;\n    for (const statement of body.statements) {\n      if (!(statement instanceof BlockNode)) {\n        continue;\n      }\n      if (statement.type === \"Construct\") {\n        construct = statement;\n      } else if (statement.type === \"Destruct\") {\n        destruct = statement;\n      }\n    }\n    return {\n      ...(construct ? { construct } : {}),\n      ...(destruct ? { destruct } : {})\n    };\n  }\n\n  private extractOnBlocks(body: BlockNode): { event: string; body: BlockNode; modifiers: string[] }[] {\n    const blocks: { event: string; body: BlockNode; modifiers: string[] }[] = [];\n    for (const statement of body.statements) {\n      if (statement instanceof OnBlockNode) {\n        blocks.push({ event: statement.eventName, body: statement.body, modifiers: statement.modifiers });\n      }\n    }\n    return blocks;\n  }\n\n  private extractDeclarations(body: BlockNode): DeclarationNode[] {\n    const declarations: DeclarationNode[] = [];\n    for (const statement of body.statements) {\n      if (statement instanceof DeclarationNode) {\n        declarations.push(statement);\n      }\n    }\n    return declarations;\n  }\n\n  private extractFunctionDeclarations(body: BlockNode): FunctionBinding[] {\n    const functions: FunctionBinding[] = [];\n    for (const statement of body.statements) {\n      if (statement instanceof FunctionDeclarationNode) {\n        functions.push({ name: statement.name, params: statement.params, body: statement.body });\n        continue;\n      }\n      if (statement instanceof AssignmentNode) {\n        if (statement.target instanceof IdentifierExpression && statement.value instanceof FunctionExpression) {\n          functions.push({\n            name: statement.target.name,\n            params: statement.value.params,\n            body: statement.value.body\n          });\n        }\n      }\n    }\n    return functions;\n  }\n\n  private getCachedBehavior(behavior: BehaviorNode): CachedBehavior {\n    const hash = this.hashBehavior(behavior);\n    const cached = this.behaviorCache.get(hash);\n    if (cached) {\n      return cached;\n    }\n    const lifecycle = this.extractLifecycle(behavior.body);\n    const fresh: CachedBehavior = {\n      onBlocks: this.extractOnBlocks(behavior.body),\n      declarations: this.extractDeclarations(behavior.body),\n      functions: this.extractFunctionDeclarations(behavior.body),\n      ...lifecycle\n    };\n    this.behaviorCache.set(hash, fresh);\n    return fresh;\n  }\n\n  private hashBehavior(behavior: BehaviorNode): string {\n    const normalized = this.normalizeNode(behavior);\n    const json = JSON.stringify(normalized);\n    return this.hashString(json);\n  }\n\n  private normalizeNode(node: any): any {\n    if (!node || typeof node !== \"object\") {\n      return node;\n    }\n    const type = node.type ?? \"Unknown\";\n    if (type === \"Behavior\") {\n      return {\n        type,\n        selector: node.selector?.selectorText ?? \"\",\n        body: this.normalizeNode(node.body)\n      };\n    }\n    if (type === \"Selector\") {\n      return { type, selectorText: node.selectorText ?? \"\" };\n    }\n    if (type === \"Block\" || type === \"Construct\" || type === \"Destruct\") {\n      return {\n        type,\n        statements: Array.isArray(node.statements)\n          ? node.statements.map((statement: any) => this.normalizeNode(statement))\n          : []\n      };\n    }\n    if (type === \"OnBlock\") {\n      return {\n        type,\n        eventName: node.eventName ?? \"\",\n        args: Array.isArray(node.args) ? node.args : [],\n        body: this.normalizeNode(node.body)\n      };\n    }\n    if (type === \"Declaration\") {\n      return {\n        type,\n        target: this.normalizeNode(node.target),\n        operator: node.operator ?? \"\",\n        value: this.normalizeNode(node.value),\n        flags: node.flags ?? {},\n        flagArgs: node.flagArgs ?? {}\n      };\n    }\n    if (type === \"Assignment\") {\n      return {\n        type,\n        target: this.normalizeNode(node.target),\n        value: this.normalizeNode(node.value)\n      };\n    }\n    if (type === \"StateBlock\") {\n      return {\n        type,\n        entries: Array.isArray(node.entries)\n          ? node.entries.map((entry: any) => this.normalizeNode(entry))\n          : []\n      };\n    }\n    if (type === \"StateEntry\") {\n      return {\n        type,\n        name: node.name ?? \"\",\n        value: this.normalizeNode(node.value),\n        important: Boolean(node.important)\n      };\n    }\n    if (type === \"FunctionDeclaration\") {\n      return {\n        type,\n        name: node.name ?? \"\",\n        params: Array.isArray(node.params) ? node.params : [],\n        body: this.normalizeNode(node.body),\n        isAsync: Boolean(node.isAsync)\n      };\n    }\n    if (type === \"FunctionExpression\") {\n      return {\n        type,\n        params: Array.isArray(node.params) ? node.params : [],\n        body: this.normalizeNode(node.body),\n        isAsync: Boolean(node.isAsync)\n      };\n    }\n    if (type === \"Return\") {\n      return {\n        type,\n        value: this.normalizeNode(node.value ?? null)\n      };\n    }\n    if (type === \"Identifier\") {\n      return { type, name: node.name ?? \"\" };\n    }\n    if (type === \"Literal\") {\n      return { type, value: node.value };\n    }\n    if (type === \"UnaryExpression\") {\n      return {\n        type,\n        operator: node.operator ?? \"\",\n        argument: this.normalizeNode(node.argument)\n      };\n    }\n    if (type === \"BinaryExpression\") {\n      return {\n        type,\n        operator: node.operator ?? \"\",\n        left: this.normalizeNode(node.left),\n        right: this.normalizeNode(node.right)\n      };\n    }\n    if (type === \"TernaryExpression\") {\n      return {\n        type,\n        test: this.normalizeNode(node.test),\n        consequent: this.normalizeNode(node.consequent),\n        alternate: this.normalizeNode(node.alternate)\n      };\n    }\n    if (type === \"CallExpression\") {\n      return {\n        type,\n        callee: this.normalizeNode(node.callee),\n        args: Array.isArray(node.args) ? node.args.map((arg: any) => this.normalizeNode(arg)) : []\n      };\n    }\n    if (type === \"AwaitExpression\") {\n      return {\n        type,\n        argument: this.normalizeNode(node.argument)\n      };\n    }\n    if (type === \"Directive\") {\n      return { type, kind: node.kind ?? \"\", name: node.name ?? \"\" };\n    }\n    if (type === \"Query\") {\n      return { type, direction: node.direction ?? \"\", selector: node.selector ?? \"\" };\n    }\n    if (type === \"ArrayExpression\") {\n      return {\n        type,\n        elements: Array.isArray(node.elements)\n          ? node.elements.map((element: any) => this.normalizeNode(element))\n          : []\n      };\n    }\n    if (type === \"IndexExpression\") {\n      return {\n        type,\n        target: this.normalizeNode(node.target),\n        index: this.normalizeNode(node.index)\n      };\n    }\n    return { type };\n  }\n\n  private hashString(value: string): string {\n    let hash = 5381;\n    for (let i = 0; i < value.length; i += 1) {\n      hash = ((hash << 5) + hash) + value.charCodeAt(i);\n      hash |= 0;\n    }\n    return (hash >>> 0).toString(16);\n  }\n\n  private applyBehaviorFunctions(\n    element: Element,\n    scope: Scope,\n    functions: FunctionBinding[]\n  ): void {\n    for (const declaration of functions) {\n      this.applyBehaviorFunction(element, scope, declaration);\n    }\n  }\n\n  private applyBehaviorFunction(\n    element: Element,\n    scope: Scope,\n    declaration: FunctionBinding\n  ): void {\n    const existing = scope.getPath(declaration.name);\n    if (existing !== undefined && typeof existing !== \"function\") {\n      throw new Error(`Cannot override non-function '${declaration.name}' with a function`);\n    }\n    const fn = async (...args: any[]) => {\n      const context: ExecutionContext = {\n        scope,\n        globals: this.globals,\n        element,\n        returnValue: undefined,\n        returning: false\n      };\n      const previousValues = new Map<string, any>();\n      for (let i = 0; i < declaration.params.length; i += 1) {\n        const name = declaration.params[i];\n        if (!name) {\n          continue;\n        }\n        previousValues.set(name, scope.getPath(name));\n        scope.setPath(name, args[i]);\n      }\n      await declaration.body.evaluate(context);\n      for (const name of declaration.params) {\n        if (!name) {\n          continue;\n        }\n        scope.setPath(name, previousValues.get(name));\n      }\n      return context.returnValue;\n    };\n    scope.setPath(declaration.name, fn);\n  }\n\n  private async applyBehaviorDeclarations(\n    element: Element,\n    scope: Scope,\n    declarations: DeclarationNode[]\n  ): Promise<void> {\n    for (const declaration of declarations) {\n      await this.applyBehaviorDeclaration(element, scope, declaration);\n    }\n  }\n\n  private async applyBehaviorDeclaration(\n    element: Element,\n    scope: Scope,\n    declaration: DeclarationNode\n  ): Promise<void> {\n    const context: ExecutionContext = { scope, element };\n    const operator = declaration.operator;\n    const debounceMs = declaration.flags.debounce\n      ? declaration.flagArgs.debounce ?? 200\n      : undefined;\n    const importantKey = this.getImportantKey(declaration);\n    if (!declaration.flags.important && importantKey && this.isImportant(element, importantKey)) {\n      return;\n    }\n    if (importantKey && this.isInlineDeclaration(element, importantKey)) {\n      return;\n    }\n    this.applyCustomFlags(element, scope, declaration);\n\n    if (declaration.target instanceof IdentifierExpression) {\n      const value = await declaration.value.evaluate(context);\n      scope.setPath(declaration.target.name, value);\n      if (declaration.flags.important && importantKey) {\n        this.markImportant(element, importantKey);\n      }\n      return;\n    }\n\n    if (!(declaration.target instanceof DirectiveExpression)) {\n      return;\n    }\n\n    const target = declaration.target;\n    const exprIdentifier =\n      declaration.value instanceof IdentifierExpression ? declaration.value.name : undefined;\n\n    if (operator === \":>\") {\n      if (exprIdentifier) {\n        this.applyDirectiveToScope(element, target, exprIdentifier, scope, debounceMs);\n      }\n      if (declaration.flags.important && importantKey) {\n        this.markImportant(element, importantKey);\n      }\n      return;\n    }\n\n    if (operator === \":=\" && exprIdentifier) {\n      this.applyDirectiveToScope(element, target, exprIdentifier, scope, debounceMs);\n    }\n\n    if (!exprIdentifier) {\n      const value = await declaration.value.evaluate(context);\n      this.setDirectiveValue(element, target, value, declaration.flags.trusted);\n      const shouldWatch = operator === \":<\" || operator === \":=\";\n      if (shouldWatch) {\n        this.applyDirectiveFromExpression(\n          element,\n          target,\n          declaration.value,\n          scope,\n          declaration.flags.trusted,\n          debounceMs\n        );\n      }\n      if (declaration.flags.important && importantKey) {\n        this.markImportant(element, importantKey);\n      }\n      return;\n    }\n\n    const shouldWatch = operator === \":<\" || operator === \":=\";\n    this.applyDirectiveFromScope(\n      element,\n      target,\n      exprIdentifier,\n      scope,\n      declaration.flags.trusted,\n      debounceMs,\n      shouldWatch\n    );\n    if (declaration.flags.important && importantKey) {\n      this.markImportant(element, importantKey);\n    }\n  }\n\n  private applyCustomFlags(element: Element, scope: Scope, declaration: DeclarationNode): void {\n    if (this.flagHandlers.size === 0) {\n      return;\n    }\n    for (const [name, handler] of this.flagHandlers) {\n      if (!declaration.flags[name]) {\n        continue;\n      }\n      handler.onApply?.({\n        name,\n        args: declaration.flagArgs[name],\n        element,\n        scope,\n        declaration\n      });\n    }\n  }\n\n  private applyDirectiveFromScope(\n    element: Element,\n    target: DirectiveExpression,\n    expr: string,\n    scope: Scope,\n    trusted: boolean | undefined,\n    debounceMs?: number,\n    watch = true\n  ): void {\n    if (target.kind === \"attr\" && target.name === \"html\" && element instanceof HTMLElement) {\n      const handler = () => applyHtml(element, expr, scope, Boolean(trusted));\n      handler();\n      if (trusted) {\n        this.handleTrustedHtml(element);\n      }\n      if (watch) {\n        this.watchWithDebounce(scope, expr, handler, debounceMs);\n      }\n      return;\n    }\n    const handler = () => {\n      const value = scope.get(expr);\n      if (value == null) {\n        return;\n      }\n      this.setDirectiveValue(element, target, value, trusted);\n    };\n    handler();\n    if (watch) {\n      this.watchWithDebounce(scope, expr, handler, debounceMs);\n    }\n  }\n\n  private applyDirectiveFromExpression(\n    element: Element,\n    target: DirectiveExpression,\n    expr: ExpressionNode,\n    scope: Scope,\n    trusted: boolean | undefined,\n    debounceMs?: number\n  ): void {\n    const handler = async () => {\n      const context: ExecutionContext = { scope, element };\n      const value = await expr.evaluate(context);\n      this.setDirectiveValue(element, target, value, trusted);\n    };\n    void handler();\n    this.watchAllScopes(scope, () => {\n      void handler();\n    }, debounceMs);\n  }\n\n  private applyDirectiveToScope(\n    element: Element,\n    target: DirectiveExpression,\n    expr: string,\n    scope: Scope,\n    debounceMs?: number\n  ): void {\n    if (target.kind === \"attr\" && target.name === \"value\") {\n      this.applyValueBindingToScope(element, expr, debounceMs);\n      return;\n    }\n    if (target.kind === \"attr\" && target.name === \"checked\") {\n      this.applyCheckedBindingToScope(element, expr, debounceMs);\n      return;\n    }\n    const value = this.getDirectiveValue(element, target);\n    if (value != null) {\n      scope.set(expr, value);\n    }\n  }\n\n  private applyCheckedBindingToScope(element: Element, expr: string, debounceMs?: number): void {\n    if (!(element instanceof HTMLInputElement)) {\n      return;\n    }\n    const handler = () => {\n      const scope = this.getScope(element);\n      if (!scope) {\n        return;\n      }\n      scope.set(expr, element.checked);\n    };\n    const effectiveHandler = debounceMs ? debounce(handler, debounceMs) : handler;\n    effectiveHandler();\n    element.addEventListener(\"change\", effectiveHandler);\n    element.addEventListener(\"input\", effectiveHandler);\n  }\n\n  private applyValueBindingToScope(element: Element, expr: string, debounceMs?: number): void {\n    if (!(element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement)) {\n      return;\n    }\n    const handler = () => {\n      const scope = this.getScope(element);\n      applyBindToScope(element, expr, scope);\n    };\n    const effectiveHandler = debounceMs ? debounce(handler, debounceMs) : handler;\n    effectiveHandler();\n    element.addEventListener(\"input\", effectiveHandler);\n    element.addEventListener(\"change\", effectiveHandler);\n  }\n\n  private setDirectiveValue(\n    element: Element,\n    target: DirectiveExpression,\n    value: unknown,\n    trusted: boolean | undefined\n  ): void {\n    if (target.kind === \"attr\" && target.name === \"html\" && element instanceof HTMLElement) {\n      const html = value == null ? \"\" : String(value);\n      element.innerHTML = trusted ? html : html.replace(/<script\\b[^>]*>[\\s\\S]*?<\\/script>/gi, \"\");\n      if (trusted) {\n        this.handleTrustedHtml(element);\n      }\n      return;\n    }\n    if (target.kind === \"attr\") {\n      if (target.name === \"value\") {\n        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n          element.value = value == null ? \"\" : String(value);\n          element.setAttribute(\"value\", element.value);\n          return;\n        }\n        if (element instanceof HTMLSelectElement) {\n          element.value = value == null ? \"\" : String(value);\n          return;\n        }\n      }\n      if (target.name === \"checked\" && element instanceof HTMLInputElement) {\n        const checked = value === true || value === \"true\" || value === 1 || value === \"1\";\n        element.checked = checked;\n        if (checked) {\n          element.setAttribute(\"checked\", \"\");\n        } else {\n          element.removeAttribute(\"checked\");\n        }\n        return;\n      }\n      element.setAttribute(target.name, value == null ? \"\" : String(value));\n      return;\n    }\n    if (target.kind === \"style\" && element instanceof HTMLElement) {\n      element.style.setProperty(target.name, value == null ? \"\" : String(value));\n    }\n  }\n\n  private getDirectiveValue(element: Element, target: DirectiveExpression): unknown {\n    if (target.kind === \"attr\") {\n      if (target.name === \"value\") {\n        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n          return element.value;\n        }\n        if (element instanceof HTMLSelectElement) {\n          return element.value;\n        }\n      }\n      if (target.name === \"checked\" && element instanceof HTMLInputElement) {\n        return element.checked;\n      }\n      return element.getAttribute(target.name) ?? undefined;\n    }\n    if (target.kind === \"style\" && element instanceof HTMLElement) {\n      return element.style.getPropertyValue(target.name) ?? undefined;\n    }\n    return undefined;\n  }\n\n  private handleTrustedHtml(root: Element): void {\n    const scripts = Array.from(root.querySelectorAll('script[type=\"text/vsn\"]'));\n    if (scripts.length === 0) {\n      return;\n    }\n    const source = scripts.map((script) => script.textContent ?? \"\").join(\"\\n\");\n    if (!source.trim()) {\n      return;\n    }\n    this.registerBehaviors(source);\n    void this.applyBehaviors(root);\n  }\n\n  private registerDefaultAttributeHandlers(): void {\n    this.registerAttributeHandler({\n      id: \"vsn-bind\",\n      match: (name) => name.startsWith(\"vsn-bind\"),\n      handle: (element, name, value, scope) => {\n        const direction = this.parseBindDirection(name);\n        this.bindBindings.set(element, { expr: value, direction });\n        if (direction === \"to\" || direction === \"both\") {\n          this.markInlineDeclaration(element, `state:${value}`);\n        }\n        if (direction === \"to\" || direction === \"both\") {\n          applyBindToScope(element, value, scope);\n          this.attachBindInputHandler(element, value);\n        }\n        if (direction === \"from\" || direction === \"both\") {\n          this.watch(scope, value, () => applyBindToElement(element, value, scope));\n        }\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-if\",\n      match: (name) => name === \"vsn-if\",\n      handle: (element, _name, value, scope) => {\n        this.ifBindings.set(element, value);\n        if (element instanceof HTMLElement) {\n          applyIf(element, value, scope);\n        }\n        this.watch(scope, value, () => this.evaluate(element));\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-show\",\n      match: (name) => name === \"vsn-show\",\n      handle: (element, _name, value, scope) => {\n        this.showBindings.set(element, value);\n        if (element instanceof HTMLElement) {\n          applyShow(element, value, scope);\n        }\n        this.watch(scope, value, () => this.evaluate(element));\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-html\",\n      match: (name) => name.startsWith(\"vsn-html\"),\n      handle: (element, name, value, scope) => {\n        const trusted = name.includes(\"!trusted\");\n        this.htmlBindings.set(element, { expr: value, trusted });\n        this.markInlineDeclaration(element, \"attr:html\");\n        if (element instanceof HTMLElement) {\n          applyHtml(element, value, scope, trusted);\n          if (trusted) {\n            this.handleTrustedHtml(element);\n          }\n        }\n        this.watch(scope, value, () => this.evaluate(element));\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-each\",\n      match: (name) => name === \"vsn-each\",\n      handle: (element, _name, value, scope) => {\n        const config = this.parseEachExpression(value);\n        if (!config) {\n          return;\n        }\n        this.eachBindings.set(element, { ...config, rendered: [] });\n        this.renderEach(element);\n        this.watch(scope, config.listExpr, () => this.renderEach(element));\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-get\",\n      match: (name) => name.startsWith(\"vsn-get\"),\n      handle: (element, name) => {\n        const trusted = name.includes(\"!trusted\");\n        const autoLoad = name.includes(\"!load\");\n        const url = element.getAttribute(name) ?? \"\";\n        const target = element.getAttribute(\"vsn-target\") ?? undefined;\n        const swap = (element.getAttribute(\"vsn-swap\") as \"inner\" | \"outer\" | null) ?? \"inner\";\n        const config: GetConfig = {\n          url,\n          swap,\n          trusted,\n          ...(target ? { targetSelector: target } : {})\n        };\n        this.getBindings.set(element, config);\n        this.attachGetHandler(element, autoLoad);\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-construct\",\n      match: (name) => name === \"vsn-construct\",\n      handle: (element, _name, value) => {\n        this.setLifecycle(element, { construct: value });\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-destruct\",\n      match: (name) => name === \"vsn-destruct\",\n      handle: (element, _name, value) => {\n        this.setLifecycle(element, { destruct: value });\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-on\",\n      match: (name) => name.startsWith(\"vsn-on:\"),\n      handle: (element, name, value) => {\n        const onConfig = this.parseOnAttribute(name, value);\n        if (onConfig) {\n          this.attachOnHandler(element, onConfig);\n        }\n      }\n    });\n  }\n}\n","export const VERSION = \"0.1.0\";\n\nexport { Lexer } from \"./parser/lexer\";\nimport { Parser } from \"./parser/parser\";\nimport { Engine } from \"./runtime/engine\";\nexport { Parser };\nexport { TokenType } from \"./parser/token\";\nexport * from \"./ast/nodes\";\nexport { Engine } from \"./runtime/engine\";\n\nexport function parseCFS(source: string) {\n  const parser = new Parser(source);\n  return parser.parseProgram();\n}\n\nexport function autoMount(root: HTMLElement | Document = document): Engine | null {\n  if (typeof document === \"undefined\") {\n    return null;\n  }\n  const engine = new Engine();\n  const startTime = typeof performance !== \"undefined\" && performance.now ? performance.now() : Date.now();\n  const mount = () => {\n    const target = root instanceof Document ? root.body : root;\n    if (target) {\n      const sources = Array.from(document.querySelectorAll('script[type=\"text/vsn\"]'))\n        .map((script) => script.textContent ?? \"\")\n        .join(\"\\n\");\n      if (sources.trim()) {\n        engine.registerBehaviors(sources);\n      }\n      engine.mount(target);\n      const endTime = typeof performance !== \"undefined\" && performance.now ? performance.now() : Date.now();\n      const elapsedMs = Math.round(endTime - startTime);\n      console.log(`Took ${elapsedMs}ms to start up VSN.js. https://www.vsnjs.com/ v${VERSION}`);\n    }\n  };\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", mount, { once: true });\n  } else {\n    mount();\n  }\n  return engine;\n}\n\nif (typeof document !== \"undefined\") {\n  const scriptTag = document.querySelector(\"script[auto-mount]\");\n  if (scriptTag) {\n    autoMount();\n  }\n}\n"],"mappings":"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","names":["TokenType","body","shouldWatch","handler"]}