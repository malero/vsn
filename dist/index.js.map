{"version":3,"sources":["../src/parser/token.ts","../src/parser/lexer.ts","../src/ast/nodes.ts","../src/parser/token-stream.ts","../src/parser/parser.ts","../src/runtime/scope.ts","../src/runtime/bindings.ts","../src/runtime/conditionals.ts","../src/runtime/html.ts","../src/runtime/http.ts","../src/runtime/debounce.ts","../src/runtime/engine.ts","../src/index.ts"],"sourcesContent":["export enum TokenType {\n  Whitespace = \"Whitespace\",\n  Identifier = \"Identifier\",\n  Number = \"Number\",\n  String = \"String\",\n  Boolean = \"Boolean\",\n  Null = \"Null\",\n\n  Behavior = \"Behavior\",\n  State = \"State\",\n  On = \"On\",\n  Construct = \"Construct\",\n  Destruct = \"Destruct\",\n\n  LBrace = \"LBrace\",\n  RBrace = \"RBrace\",\n  LParen = \"LParen\",\n  RParen = \"RParen\",\n  LBracket = \"LBracket\",\n  RBracket = \"RBracket\",\n\n  Colon = \"Colon\",\n  Semicolon = \"Semicolon\",\n  Comma = \"Comma\",\n\n  Dot = \"Dot\",\n  Hash = \"Hash\",\n  Greater = \"Greater\",\n  Less = \"Less\",\n  Plus = \"Plus\",\n  Minus = \"Minus\",\n  Tilde = \"Tilde\",\n  Star = \"Star\",\n\n  Equals = \"Equals\",\n  Bang = \"Bang\",\n\n  At = \"At\",\n  Dollar = \"Dollar\",\n  Question = \"Question\"\n}\n\nexport interface Position {\n  index: number;\n  line: number;\n  column: number;\n}\n\nexport interface Token {\n  type: TokenType;\n  value: string;\n  start: Position;\n  end: Position;\n}\n","import { Token, TokenType } from \"./token\";\n\nconst KEYWORDS: Record<string, TokenType> = {\n  behavior: TokenType.Behavior,\n  state: TokenType.State,\n  on: TokenType.On,\n  construct: TokenType.Construct,\n  destruct: TokenType.Destruct,\n  true: TokenType.Boolean,\n  false: TokenType.Boolean,\n  null: TokenType.Null\n};\n\nexport class Lexer {\n  private index = 0;\n  private line = 1;\n  private column = 1;\n\n  constructor(private input: string) {}\n\n  tokenize(): Token[] {\n    const tokens: Token[] = [];\n\n    while (!this.eof()) {\n      const ch = this.peek();\n\n      if (this.isWhitespace(ch)) {\n        tokens.push(this.readWhitespace());\n        continue;\n      }\n\n      if (ch === \"/\" && this.peek(1) === \"/\") {\n        this.readLineComment();\n        continue;\n      }\n\n      if (ch === \"/\" && this.peek(1) === \"*\") {\n        this.readBlockComment();\n        continue;\n      }\n\n      if (this.isAlpha(ch) || ch === \"_\") {\n        tokens.push(this.readIdentifier());\n        continue;\n      }\n\n      if (this.isDigit(ch) || (ch === \"-\" && this.isDigit(this.peek(1)))) {\n        tokens.push(this.readNumber());\n        continue;\n      }\n\n      if (ch === \"\\\"\" || ch === \"'\") {\n        tokens.push(this.readString());\n        continue;\n      }\n\n      const punct = this.readPunctuator();\n      if (punct) {\n        tokens.push(punct);\n        continue;\n      }\n\n      throw new Error(`Unexpected character '${ch}' at ${this.line}:${this.column}`);\n    }\n\n    return tokens;\n  }\n\n  private readWhitespace(): Token {\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof() && this.isWhitespace(this.peek())) {\n      value += this.next();\n    }\n    return this.token(TokenType.Whitespace, value, start);\n  }\n\n  private readLineComment(): void {\n    this.next();\n    this.next();\n    while (!this.eof() && this.peek() !== \"\\n\") {\n      this.next();\n    }\n  }\n\n  private readBlockComment(): void {\n    this.next();\n    this.next();\n    while (!this.eof()) {\n      if (this.peek() === \"*\" && this.peek(1) === \"/\") {\n        this.next();\n        this.next();\n        return;\n      }\n      this.next();\n    }\n  }\n\n  private readIdentifier(): Token {\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof() && (this.isAlphaNumeric(this.peek()) || this.peek() === \"_\" || this.peek() === \"-\")) {\n      value += this.next();\n    }\n\n    const keywordType = KEYWORDS[value];\n    if (keywordType) {\n      return this.token(keywordType, value, start);\n    }\n\n    return this.token(TokenType.Identifier, value, start);\n  }\n\n  private readNumber(): Token {\n    const start = this.position();\n    let value = \"\";\n    if (this.peek() === \"-\") {\n      value += this.next();\n    }\n    while (!this.eof() && this.isDigit(this.peek())) {\n      value += this.next();\n    }\n    if (this.peek() === \".\") {\n      value += this.next();\n      while (!this.eof() && this.isDigit(this.peek())) {\n        value += this.next();\n      }\n    }\n    return this.token(TokenType.Number, value, start);\n  }\n\n  private readString(): Token {\n    const quote = this.next();\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof()) {\n      const ch = this.next();\n      if (ch === \"\\\\\") {\n        const escaped = this.next();\n        value += escaped;\n        continue;\n      }\n      if (ch === quote) {\n        return this.token(TokenType.String, value, start);\n      }\n      value += ch;\n    }\n    throw new Error(`Unterminated string at ${start.line}:${start.column}`);\n  }\n\n  private readPunctuator(): Token | null {\n    const start = this.position();\n    const ch = this.peek();\n    const punctMap: Record<string, TokenType> = {\n      \"{\": TokenType.LBrace,\n      \"}\": TokenType.RBrace,\n      \"(\": TokenType.LParen,\n      \")\": TokenType.RParen,\n      \"[\": TokenType.LBracket,\n      \"]\": TokenType.RBracket,\n      \":\": TokenType.Colon,\n      \";\": TokenType.Semicolon,\n      \",\": TokenType.Comma,\n      \".\": TokenType.Dot,\n      \"#\": TokenType.Hash,\n      \">\": TokenType.Greater,\n      \"<\": TokenType.Less,\n      \"+\": TokenType.Plus,\n      \"-\": TokenType.Minus,\n      \"~\": TokenType.Tilde,\n      \"*\": TokenType.Star,\n      \"=\": TokenType.Equals,\n      \"!\": TokenType.Bang,\n      \"@\": TokenType.At,\n      \"$\": TokenType.Dollar,\n      \"?\": TokenType.Question\n    };\n\n    const type = punctMap[ch];\n    if (!type) {\n      return null;\n    }\n\n    this.next();\n    return this.token(type, ch, start);\n  }\n\n  private token(type: TokenType, value: string, start: { index: number; line: number; column: number }): Token {\n    return {\n      type,\n      value,\n      start,\n      end: this.position()\n    };\n  }\n\n  private position() {\n    return { index: this.index, line: this.line, column: this.column };\n  }\n\n  private peek(offset = 0): string {\n    return this.input[this.index + offset] ?? \"\";\n  }\n\n  private next(): string {\n    const ch = this.input[this.index++] ?? \"\";\n    if (ch === \"\\n\") {\n      this.line += 1;\n      this.column = 1;\n    } else {\n      this.column += 1;\n    }\n    return ch;\n  }\n\n  private eof(): boolean {\n    return this.index >= this.input.length;\n  }\n\n  private isWhitespace(ch: string): boolean {\n    return ch === \" \" || ch === \"\\t\" || ch === \"\\n\" || ch === \"\\r\";\n  }\n\n  private isAlpha(ch: string): boolean {\n    return (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\");\n  }\n\n  private isDigit(ch: string): boolean {\n    return ch >= \"0\" && ch <= \"9\";\n  }\n\n  private isAlphaNumeric(ch: string): boolean {\n    return this.isAlpha(ch) || this.isDigit(ch);\n  }\n}\n","export interface ExecutionContext {\n  scope?: {\n    getPath(key: string): any;\n    setPath?(key: string, value: any): void;\n  };\n}\n\nexport interface CFSNode {\n  type: string;\n  prepare(context: ExecutionContext): Promise<void>;\n  evaluate(context: ExecutionContext): Promise<any>;\n}\n\nexport abstract class BaseNode implements CFSNode {\n  constructor(public type: string) {}\n\n  async prepare(_context: ExecutionContext): Promise<void> {\n    return;\n  }\n\n  async evaluate(_context: ExecutionContext): Promise<any> {\n    return undefined;\n  }\n}\n\nexport class ProgramNode extends BaseNode {\n  constructor(public behaviors: BehaviorNode[]) {\n    super(\"Program\");\n  }\n}\n\nexport class BlockNode extends BaseNode {\n  constructor(public statements: CFSNode[]) {\n    super(\"Block\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    for (const statement of this.statements) {\n      if (statement && typeof statement.evaluate === \"function\") {\n        await statement.evaluate(context);\n      }\n    }\n  }\n}\n\nexport class SelectorNode extends BaseNode {\n  constructor(public selectorText: string) {\n    super(\"Selector\");\n  }\n}\n\nexport class BehaviorNode extends BaseNode {\n  constructor(public selector: SelectorNode, public body: BlockNode) {\n    super(\"Behavior\");\n  }\n}\n\nexport class StateEntryNode extends BaseNode {\n  constructor(\n    public name: string,\n    public value: ExpressionNode,\n    public important: boolean\n  ) {\n    super(\"StateEntry\");\n  }\n}\n\nexport class StateBlockNode extends BaseNode {\n  constructor(public entries: StateEntryNode[]) {\n    super(\"StateBlock\");\n  }\n}\n\nexport class OnBlockNode extends BaseNode {\n  constructor(\n    public eventName: string,\n    public args: string[],\n    public body: BlockNode\n  ) {\n    super(\"OnBlock\");\n  }\n}\n\nexport class AssignmentNode extends BaseNode {\n  constructor(public target: AssignmentTarget, public value: ExpressionNode) {\n    super(\"Assignment\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    if (!context.scope || !context.scope.setPath) {\n      return undefined;\n    }\n    let targetPath: string | undefined;\n    if (this.target instanceof IdentifierExpression) {\n      targetPath = this.target.name;\n    }\n    if (!targetPath) {\n      return undefined;\n    }\n    const value = await this.value.evaluate(context);\n    context.scope.setPath(targetPath, value);\n    return value;\n  }\n}\n\nexport interface DeclarationFlags {\n  important?: boolean;\n  trusted?: boolean;\n  debounce?: boolean;\n}\n\nexport interface DeclarationFlagArgs {\n  debounce?: number;\n}\n\nexport class DeclarationNode extends BaseNode {\n  constructor(\n    public target: DeclarationTarget,\n    public operator: \":\" | \":=\" | \":<\" | \":>\",\n    public value: ExpressionNode,\n    public flags: DeclarationFlags,\n    public flagArgs: DeclarationFlagArgs\n  ) {\n    super(\"Declaration\");\n  }\n}\n\nexport type ExpressionNode =\n  | IdentifierExpression\n  | LiteralExpression\n  | UnaryExpression\n  | BinaryExpression\n  | DirectiveExpression\n  | QueryExpression;\n\nexport type DeclarationTarget = IdentifierExpression | DirectiveExpression;\nexport type AssignmentTarget = IdentifierExpression | DirectiveExpression;\n\nexport class IdentifierExpression extends BaseNode {\n  constructor(public name: string) {\n    super(\"Identifier\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    if (!context.scope) {\n      return undefined;\n    }\n    return context.scope.getPath(this.name);\n  }\n}\n\nexport class LiteralExpression extends BaseNode {\n  constructor(public value: string | number | boolean | null) {\n    super(\"Literal\");\n  }\n\n  async evaluate(): Promise<any> {\n    return this.value;\n  }\n}\n\nexport class UnaryExpression extends BaseNode {\n  constructor(public operator: string, public argument: ExpressionNode) {\n    super(\"UnaryExpression\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    const value = await this.argument.evaluate(context);\n    if (this.operator === \"!\") {\n      return !value;\n    }\n    if (this.operator === \"-\") {\n      return -(value as any);\n    }\n    return value;\n  }\n}\n\nexport class BinaryExpression extends BaseNode {\n  constructor(\n    public operator: string,\n    public left: ExpressionNode,\n    public right: ExpressionNode\n  ) {\n    super(\"BinaryExpression\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    const left = await this.left.evaluate(context);\n    const right = await this.right.evaluate(context);\n    if (this.operator === \"+\") {\n      return (left as any) + (right as any);\n    }\n    if (this.operator === \"-\") {\n      return (left as any) - (right as any);\n    }\n    return undefined;\n  }\n}\n\nexport class DirectiveExpression extends BaseNode {\n  constructor(public kind: \"attr\" | \"style\", public name: string) {\n    super(\"Directive\");\n  }\n\n  async evaluate(): Promise<any> {\n    return `${this.kind}:${this.name}`;\n  }\n}\n\nexport class QueryExpression extends BaseNode {\n  constructor(public direction: \"self\" | \"descendant\" | \"ancestor\", public selector: string) {\n    super(\"Query\");\n  }\n}\n","import { Token, TokenType } from \"./token\";\n\nexport class TokenStream {\n  private index = 0;\n\n  constructor(private tokens: Token[]) {}\n\n  peek(offset = 0): Token | null {\n    return this.tokens[this.index + offset] ?? null;\n  }\n\n  next(): Token {\n    const token = this.tokens[this.index++];\n    if (!token) {\n      throw new Error(\"Unexpected end of input\");\n    }\n    return token;\n  }\n\n  eof(): boolean {\n    return this.index >= this.tokens.length;\n  }\n\n  match(type: TokenType): boolean {\n    if (this.peek()?.type === type) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n\n  expect(type: TokenType): Token {\n    const token = this.next();\n    if (token.type !== type) {\n      throw new Error(`Expected ${type} but got ${token.type}`);\n    }\n    return token;\n  }\n\n  skipWhitespace(): void {\n    while (this.peek()?.type === TokenType.Whitespace) {\n      this.next();\n    }\n  }\n\n  peekNonWhitespace(offset = 0): Token | null {\n    let count = 0;\n    for (let i = this.index; i < this.tokens.length; i++) {\n      const token = this.tokens[i];\n      if (token.type === TokenType.Whitespace) {\n        continue;\n      }\n      if (count === offset) {\n        return token;\n      }\n      count += 1;\n    }\n    return null;\n  }\n}\n","import {\n  AssignmentNode,\n  BehaviorNode,\n  BinaryExpression,\n  BlockNode,\n  AssignmentTarget,\n  DeclarationNode,\n  DeclarationTarget,\n  DeclarationFlags,\n  DeclarationFlagArgs,\n  DirectiveExpression,\n  IdentifierExpression,\n  LiteralExpression,\n  OnBlockNode,\n  ProgramNode,\n  QueryExpression,\n  SelectorNode,\n  StateBlockNode,\n  StateEntryNode,\n  UnaryExpression,\n  ExpressionNode\n} from \"../ast/nodes\";\nimport { Lexer } from \"./lexer\";\nimport { TokenStream } from \"./token-stream\";\nimport { TokenType } from \"./token\";\n\nexport class Parser {\n  private stream: TokenStream;\n\n  constructor(input: string) {\n    const lexer = new Lexer(input);\n    this.stream = new TokenStream(lexer.tokenize());\n  }\n\n  static parseInline(code: string): BlockNode {\n    const parser = new Parser(`{${code}}`);\n    return parser.parseInlineBlock();\n  }\n\n  parseProgram(): ProgramNode {\n    const behaviors: BehaviorNode[] = [];\n    this.stream.skipWhitespace();\n    while (!this.stream.eof()) {\n      behaviors.push(this.parseBehavior());\n      this.stream.skipWhitespace();\n    }\n    return new ProgramNode(behaviors);\n  }\n\n  parseInlineBlock(): BlockNode {\n    this.stream.skipWhitespace();\n    return this.parseBlock({ allowDeclarations: false });\n  }\n\n  private parseBehavior(): BehaviorNode {\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Behavior);\n    const selector = this.parseSelector();\n    const body = this.parseBlock({ allowDeclarations: true });\n    return new BehaviorNode(selector, body);\n  }\n\n  private parseSelector(): SelectorNode {\n    let selectorText = \"\";\n    let sawNonWhitespace = false;\n\n    while (true) {\n      const token = this.stream.peek();\n      if (!token) {\n        break;\n      }\n\n      if (token.type === TokenType.LBrace) {\n        break;\n      }\n\n      if (token.type === TokenType.Whitespace) {\n        this.stream.next();\n        if (sawNonWhitespace && selectorText[selectorText.length - 1] !== \" \") {\n          selectorText += \" \";\n        }\n        continue;\n      }\n\n      sawNonWhitespace = true;\n      selectorText += this.stream.next().value;\n    }\n\n    if (!selectorText.trim()) {\n      throw new Error(\"Behavior selector is required\");\n    }\n\n    return new SelectorNode(selectorText.trim());\n  }\n\n  private parseBlock(options?: { allowDeclarations?: boolean }): BlockNode {\n    const allowDeclarations = options?.allowDeclarations ?? false;\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LBrace);\n    const statements = [];\n    let declarationsOpen = allowDeclarations;\n\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated block\");\n      }\n      if (next.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n\n      const isDeclaration = this.isDeclarationStart();\n      if (isDeclaration) {\n        if (!allowDeclarations) {\n          throw new Error(\"Declarations are only allowed at the behavior root\");\n        }\n        if (!declarationsOpen) {\n          throw new Error(\"Declarations must appear before blocks\");\n        }\n        statements.push(this.parseDeclaration());\n      } else {\n        if (declarationsOpen) {\n          declarationsOpen = false;\n        }\n        statements.push(this.parseStatement());\n      }\n    }\n\n    return new BlockNode(statements);\n  }\n\n  private parseStatement() {\n    this.stream.skipWhitespace();\n    const next = this.stream.peek();\n    if (!next) {\n      throw new Error(\"Unexpected end of input\");\n    }\n\n    if (next.type === TokenType.On) {\n      return this.parseOnBlock();\n    }\n\n    if (next.type === TokenType.Construct) {\n      return this.parseConstructBlock();\n    }\n\n    if (next.type === TokenType.Destruct) {\n      return this.parseDestructBlock();\n    }\n\n    if (next.type === TokenType.Behavior) {\n      return this.parseBehavior();\n    }\n\n    if (this.isAssignmentStart()) {\n      return this.parseAssignment();\n    }\n\n    throw new Error(`Unexpected token ${next.type}`);\n  }\n\n  private parseStateBlock(): StateBlockNode {\n    this.stream.expect(TokenType.State);\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LBrace);\n\n    const entries: StateEntryNode[] = [];\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated state block\");\n      }\n      if (next.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n\n      const nameToken = this.stream.expect(TokenType.Identifier);\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Colon);\n      this.stream.skipWhitespace();\n      const value = this.parseExpression();\n      this.stream.skipWhitespace();\n\n      let important = false;\n      if (this.stream.peek()?.type === TokenType.Bang) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const importantToken = this.stream.next();\n        if (importantToken.type === TokenType.Identifier && importantToken.value === \"important\") {\n          important = true;\n        } else {\n          throw new Error(\"Expected 'important' after '!'\");\n        }\n      }\n\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Semicolon);\n      entries.push(new StateEntryNode(nameToken.value, value, important));\n    }\n\n    return new StateBlockNode(entries);\n  }\n\n  private parseOnBlock(): OnBlockNode {\n    this.stream.expect(TokenType.On);\n    this.stream.skipWhitespace();\n    const event = this.stream.expect(TokenType.Identifier);\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    const args: string[] = [];\n\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated on() arguments\");\n      }\n      if (next.type === TokenType.RParen) {\n        this.stream.next();\n        break;\n      }\n      if (next.type === TokenType.Identifier) {\n        args.push(this.stream.next().value);\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.Comma) {\n          this.stream.next();\n        }\n        continue;\n      }\n      throw new Error(`Unexpected token in on() args: ${next.type}`);\n    }\n\n    const body = this.parseBlock({ allowDeclarations: false });\n    return new OnBlockNode(event.value, args, body);\n  }\n\n  private parseAssignment(): AssignmentNode {\n    const target = this.parseAssignmentTarget();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Equals);\n    this.stream.skipWhitespace();\n    const value = this.parseExpression();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Semicolon);\n    return new AssignmentNode(target, value);\n  }\n\n  private parseExpression(): ExpressionNode {\n    return this.parseAdditiveExpression();\n  }\n\n  private parseAdditiveExpression(): ExpressionNode {\n    let left = this.parseUnaryExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next || (next.type !== TokenType.Plus && next.type !== TokenType.Minus)) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      const op = this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseUnaryExpression();\n      this.stream.skipWhitespace();\n      left = new BinaryExpression(op.type === TokenType.Plus ? \"+\" : \"-\", left, right);\n    }\n    return left;\n  }\n\n  private parseUnaryExpression(): ExpressionNode {\n    this.stream.skipWhitespace();\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected expression\");\n    }\n    if (token.type === TokenType.Bang) {\n      this.stream.next();\n      const argument = this.parseUnaryExpression();\n      return new UnaryExpression(\"!\", argument);\n    }\n    if (token.type === TokenType.Minus) {\n      this.stream.next();\n      const argument = this.parseUnaryExpression();\n      return new UnaryExpression(\"-\", argument);\n    }\n    return this.parsePrimaryExpression();\n  }\n\n  private parsePrimaryExpression(): ExpressionNode {\n    this.stream.skipWhitespace();\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected expression\");\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier);\n      return new DirectiveExpression(kind, name.value);\n    }\n\n    if (token.type === TokenType.Question) {\n      return this.parseQueryExpression();\n    }\n\n    if (token.type === TokenType.LParen) {\n      this.stream.next();\n      const value = this.parseExpression();\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.RParen);\n      return value;\n    }\n\n    if (token.type === TokenType.Identifier) {\n      const name = this.parseIdentifierPath();\n      return new IdentifierExpression(name);\n    }\n\n    if (token.type === TokenType.Boolean) {\n      return new LiteralExpression(this.stream.next().value === \"true\");\n    }\n\n    if (token.type === TokenType.Null) {\n      this.stream.next();\n      return new LiteralExpression(null);\n    }\n\n    if (token.type === TokenType.Number) {\n      return new LiteralExpression(Number(this.stream.next().value));\n    }\n\n    if (token.type === TokenType.String) {\n      return new LiteralExpression(this.stream.next().value);\n    }\n\n    throw new Error(`Unsupported expression token ${token.type}`);\n  }\n\n  private parseAssignmentTarget(): AssignmentTarget {\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected assignment target\");\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier);\n      return new DirectiveExpression(kind, name.value);\n    }\n\n    if (token.type === TokenType.Identifier) {\n      return new IdentifierExpression(this.parseIdentifierPath());\n    }\n\n    throw new Error(`Invalid assignment target ${token.type}`);\n  }\n\n  private parseDeclaration(): DeclarationNode {\n    const target = this.parseDeclarationTarget();\n    this.stream.skipWhitespace();\n    const operator = this.parseDeclarationOperator();\n    this.stream.skipWhitespace();\n    const value = this.parseExpression();\n    const { flags, flagArgs } = this.parseFlags();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Semicolon);\n    return new DeclarationNode(target, operator, value, flags, flagArgs);\n  }\n\n  private parseDeclarationTarget(): DeclarationTarget {\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected declaration target\");\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier);\n      return new DirectiveExpression(kind, name.value);\n    }\n\n    if (token.type === TokenType.Identifier) {\n      return new IdentifierExpression(this.stream.next().value);\n    }\n\n    throw new Error(`Invalid declaration target ${token.type}`);\n  }\n\n  private parseDeclarationOperator(): \":\" | \":=\" | \":<\" | \":>\" {\n    this.stream.expect(TokenType.Colon);\n    const next = this.stream.peek();\n    if (!next) {\n      return \":\";\n    }\n    if (next.type === TokenType.Equals) {\n      this.stream.next();\n      return \":=\";\n    }\n    if (next.type === TokenType.Less) {\n      this.stream.next();\n      return \":<\";\n    }\n    if (next.type === TokenType.Greater) {\n      this.stream.next();\n      return \":>\";\n    }\n    return \":\";\n  }\n\n  private parseFlags(): { flags: DeclarationFlags; flagArgs: DeclarationFlagArgs } {\n    const flags: DeclarationFlags = {};\n    const flagArgs: DeclarationFlagArgs = {};\n\n    while (true) {\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type !== TokenType.Bang) {\n        break;\n      }\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier).value;\n\n      if (name === \"important\") {\n        flags.important = true;\n      } else if (name === \"trusted\") {\n        flags.trusted = true;\n      } else if (name === \"debounce\") {\n        flags.debounce = true;\n        if (this.stream.peek()?.type === TokenType.LParen) {\n          this.stream.next();\n          this.stream.skipWhitespace();\n          const numberToken = this.stream.expect(TokenType.Number);\n          flagArgs.debounce = Number(numberToken.value);\n          this.stream.skipWhitespace();\n          this.stream.expect(TokenType.RParen);\n        } else {\n          flagArgs.debounce = 200;\n        }\n      } else {\n        throw new Error(`Unknown flag ${name}`);\n      }\n    }\n\n    return { flags, flagArgs };\n  }\n\n  private isDeclarationStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first) {\n      return false;\n    }\n\n    if (first.type === TokenType.Identifier) {\n      const second = this.stream.peekNonWhitespace(1);\n      return second?.type === TokenType.Colon;\n    }\n\n    if (first.type === TokenType.At || first.type === TokenType.Dollar) {\n      const second = this.stream.peekNonWhitespace(1);\n      const third = this.stream.peekNonWhitespace(2);\n      return second?.type === TokenType.Identifier && third?.type === TokenType.Colon;\n    }\n\n    return false;\n  }\n\n  private isAssignmentStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first) {\n      return false;\n    }\n\n    if (first.type === TokenType.Identifier) {\n      const second = this.stream.peekNonWhitespace(1);\n      return second?.type === TokenType.Equals || second?.type === TokenType.Dot;\n    }\n\n    if (first.type === TokenType.At || first.type === TokenType.Dollar) {\n      const second = this.stream.peekNonWhitespace(1);\n      const third = this.stream.peekNonWhitespace(2);\n      return second?.type === TokenType.Identifier && third?.type === TokenType.Equals;\n    }\n\n    return false;\n  }\n\n  private parseConstructBlock(): BlockNode {\n    this.stream.expect(TokenType.Construct);\n    const body = this.parseBlock({ allowDeclarations: false });\n    body.type = \"Construct\";\n    return body;\n  }\n\n  private parseDestructBlock(): BlockNode {\n    this.stream.expect(TokenType.Destruct);\n    const body = this.parseBlock({ allowDeclarations: false });\n    body.type = \"Destruct\";\n    return body;\n  }\n\n  private parseQueryExpression(): QueryExpression {\n    this.stream.expect(TokenType.Question);\n    let direction: \"self\" | \"descendant\" | \"ancestor\" = \"self\";\n\n    if (this.stream.peek()?.type === TokenType.Greater) {\n      this.stream.next();\n      direction = \"descendant\";\n    } else if (this.stream.peek()?.type === TokenType.Less) {\n      this.stream.next();\n      direction = \"ancestor\";\n    }\n\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    const selector = this.readSelectorUntil(TokenType.RParen);\n    return new QueryExpression(direction, selector);\n  }\n\n  private readSelectorUntil(terminator: TokenType): string {\n    let selectorText = \"\";\n    let sawNonWhitespace = false;\n\n    while (true) {\n      const token = this.stream.peek();\n      if (!token) {\n        throw new Error(\"Unterminated selector\");\n      }\n      if (token.type === terminator) {\n        this.stream.next();\n        break;\n      }\n\n      if (token.type === TokenType.Whitespace) {\n        this.stream.next();\n        if (sawNonWhitespace && selectorText[selectorText.length - 1] !== \" \") {\n          selectorText += \" \";\n        }\n        continue;\n      }\n\n      sawNonWhitespace = true;\n      selectorText += this.stream.next().value;\n    }\n\n    return selectorText.trim();\n  }\n\n  private parseIdentifierPath(): string {\n    let value = this.stream.expect(TokenType.Identifier).value;\n    while (this.stream.peek()?.type === TokenType.Dot) {\n      this.stream.next();\n      const part = this.stream.expect(TokenType.Identifier).value;\n      value = `${value}.${part}`;\n    }\n    return value;\n  }\n}\n","export class Scope {\n  private data = new Map<string, any>();\n  private root: Scope;\n  private listeners = new Map<string, Set<() => void>>();\n\n  constructor(public readonly parent?: Scope) {\n    this.root = parent ? parent.root : this;\n  }\n\n  get(key: string): any {\n    return this.getPath(key);\n  }\n\n  set(key: string, value: any): void {\n    this.setPath(key, value);\n  }\n\n  getPath(path: string): any {\n    const { targetScope, targetPath } = this.resolveScope(path);\n    if (!targetScope || !targetPath) {\n      return undefined;\n    }\n\n    const parts = targetPath.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return undefined;\n    }\n    let value = targetScope.data.get(root);\n    for (let i = 1; i < parts.length; i += 1) {\n      if (value == null) {\n        return undefined;\n      }\n      const key = parts[i];\n      if (!key) {\n        return undefined;\n      }\n      value = value[key];\n    }\n    return value;\n  }\n\n  setPath(path: string, value: any): void {\n    const { targetScope, targetPath } = this.resolveScope(path);\n    if (!targetScope || !targetPath) {\n      return;\n    }\n\n    const parts = targetPath.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return;\n    }\n    if (parts.length === 1) {\n      targetScope.data.set(root, value);\n      targetScope.emitChange(targetPath);\n      return;\n    }\n    let obj = targetScope.data.get(root);\n    if (obj == null || typeof obj !== \"object\") {\n      obj = {};\n      targetScope.data.set(root, obj);\n    }\n    let cursor = obj;\n    for (let i = 1; i < parts.length - 1; i += 1) {\n      const key = parts[i];\n      if (!key) {\n        return;\n      }\n      if (cursor[key] == null || typeof cursor[key] !== \"object\") {\n        cursor[key] = {};\n      }\n      cursor = cursor[key];\n    }\n    const lastKey = parts[parts.length - 1];\n    if (!lastKey) {\n      return;\n    }\n    cursor[lastKey] = value;\n    this.emitChange(path);\n  }\n\n  on(path: string, handler: () => void): void {\n    const key = path.trim();\n    if (!key) {\n      return;\n    }\n    const set = this.listeners.get(key) ?? new Set<() => void>();\n    set.add(handler);\n    this.listeners.set(key, set);\n  }\n\n  off(path: string, handler: () => void): void {\n    const key = path.trim();\n    const set = this.listeners.get(key);\n    if (!set) {\n      return;\n    }\n    set.delete(handler);\n    if (set.size === 0) {\n      this.listeners.delete(key);\n    }\n  }\n\n  private emitChange(path: string): void {\n    const key = path.trim();\n    if (!key) {\n      return;\n    }\n    this.listeners.get(key)?.forEach((fn) => fn());\n    const rootKey = key.split(\".\")[0];\n    if (rootKey && rootKey !== key) {\n      this.listeners.get(rootKey)?.forEach((fn) => fn());\n    }\n  }\n\n  private resolveScope(path: string): { targetScope: Scope | undefined; targetPath: string | undefined } {\n    if (path.startsWith(\"parent.\")) {\n      return { targetScope: this.parent, targetPath: path.slice(\"parent.\".length) };\n    }\n    if (path.startsWith(\"root.\")) {\n      return { targetScope: this.root, targetPath: path.slice(\"root.\".length) };\n    }\n    if (path.startsWith(\"self.\")) {\n      return { targetScope: this, targetPath: path.slice(\"self.\".length) };\n    }\n    return { targetScope: this, targetPath: path };\n  }\n}\n","import { Scope } from \"./scope\";\n\nexport type BindDirection = \"both\" | \"from\" | \"to\";\n\nfunction getElementValue(element: Element): string {\n  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n    return element.value;\n  }\n  return element.textContent ?? \"\";\n}\n\nfunction setElementValue(element: Element, value: string): void {\n  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n    element.value = value;\n    element.setAttribute(\"value\", value);\n    return;\n  }\n  element.textContent = value;\n}\n\nexport function applyBindToScope(element: Element, expression: string, scope: Scope): void {\n  const key = expression.trim();\n  if (!key) {\n    return;\n  }\n\n  const value = getElementValue(element).trim();\n  if (value !== \"\") {\n    scope.set(key, value);\n  }\n}\n\nexport function applyBindToElement(element: Element, expression: string, scope: Scope): void {\n  const key = expression.trim();\n  if (!key) {\n    return;\n  }\n  const value = scope.get(key);\n  if (value == null) {\n    return;\n  }\n  setElementValue(element, String(value));\n}\n","import { Scope } from \"./scope\";\n\nfunction readCondition(expression: string, scope: Scope): boolean {\n  const key = expression.trim();\n  if (!key) {\n    return false;\n  }\n  return !!scope.get(key);\n}\n\nexport function applyIf(element: HTMLElement, expression: string, scope: Scope): void {\n  element.style.display = readCondition(expression, scope) ? \"\" : \"none\";\n}\n\nexport function applyShow(element: HTMLElement, expression: string, scope: Scope): void {\n  element.style.display = readCondition(expression, scope) ? \"\" : \"none\";\n}\n","import { Scope } from \"./scope\";\n\nfunction sanitizeHtml(value: string): string {\n  return value.replace(/<script\\b[^>]*>[\\s\\S]*?<\\/script>/gi, \"\");\n}\n\nexport function applyHtml(\n  element: HTMLElement,\n  expression: string,\n  scope: Scope,\n  trusted: boolean\n): void {\n  const key = expression.trim();\n  if (!key) {\n    return;\n  }\n  const value = scope.get(key);\n  const html = value == null ? \"\" : String(value);\n  element.innerHTML = trusted ? html : sanitizeHtml(html);\n}\n","import { applyHtml } from \"./html\";\nimport { Scope } from \"./scope\";\n\nexport interface GetConfig {\n  url: string;\n  targetSelector?: string;\n  swap?: \"inner\" | \"outer\";\n  trusted: boolean;\n}\n\nexport async function applyGet(\n  element: Element,\n  config: GetConfig,\n  scope: Scope\n): Promise<void> {\n  if (!globalThis.fetch) {\n    throw new Error(\"fetch is not available\");\n  }\n\n  const response = await globalThis.fetch(config.url);\n  if (!response || !response.ok) {\n    return;\n  }\n\n  const html = await response.text();\n  const target = resolveTarget(element, config.targetSelector);\n  if (!target) {\n    element.dispatchEvent(new CustomEvent(\"vsn:targetError\", { detail: { selector: config.targetSelector } }));\n    return;\n  }\n\n  if (config.swap === \"outer\") {\n    const wrapper = document.createElement(\"div\");\n    applyHtml(wrapper, \"__html\", { get: () => html } as Scope, config.trusted);\n    const replacement = wrapper.firstElementChild;\n    if (replacement && target.parentNode) {\n      target.parentNode.replaceChild(replacement, target);\n    }\n    return;\n  }\n\n  applyHtml(target as HTMLElement, \"__html\", { get: () => html } as Scope, config.trusted);\n}\n\nfunction resolveTarget(element: Element, selector?: string): Element | null {\n  if (!selector) {\n    return element;\n  }\n  return element.ownerDocument.querySelector(selector);\n}\n","type Debounced = (...args: any[]) => void;\n\nexport function debounce<T extends (...args: any[]) => void>(fn: T, waitMs: number): Debounced {\n  let timer: ReturnType<typeof setTimeout> | undefined;\n  return (...args: any[]) => {\n    if (timer) {\n      clearTimeout(timer);\n    }\n    timer = setTimeout(() => {\n      timer = undefined;\n      fn(...args);\n    }, waitMs);\n  };\n}\n","import { Scope } from \"./scope\";\nimport { applyBindToElement, applyBindToScope, BindDirection } from \"./bindings\";\nimport { applyIf, applyShow } from \"./conditionals\";\nimport { applyHtml } from \"./html\";\nimport { applyGet, GetConfig } from \"./http\";\nimport { debounce } from \"./debounce\";\nimport { Parser } from \"../parser/parser\";\nimport { BehaviorNode, BlockNode, ExecutionContext } from \"../ast/nodes\";\n\ninterface OnConfig {\n  event: string;\n  code: string;\n  debounceMs?: number;\n}\n\ninterface BindConfig {\n  expr: string;\n  direction: BindDirection;\n}\n\ninterface LifecycleConfig {\n  construct?: string;\n  destruct?: string;\n}\n\ninterface RegisteredBehavior {\n  id: number;\n  selector: string;\n  construct?: BlockNode;\n  destruct?: BlockNode;\n}\n\ntype AttributeHandler = {\n  id: string;\n  match: (name: string) => boolean;\n  handle: (element: Element, name: string, value: string, scope: Scope) => boolean | void;\n};\n\nexport class Engine {\n  private scopes = new WeakMap<Element, Scope>();\n  private bindBindings = new WeakMap<Element, BindConfig>();\n  private ifBindings = new WeakMap<Element, string>();\n  private showBindings = new WeakMap<Element, string>();\n  private htmlBindings = new WeakMap<Element, { expr: string; trusted: boolean }>();\n  private getBindings = new WeakMap<Element, GetConfig>();\n  private lifecycleBindings = new WeakMap<Element, LifecycleConfig>();\n  private behaviorRegistry: RegisteredBehavior[] = [];\n  private behaviorBindings = new WeakMap<Element, Set<number>>();\n  private behaviorId = 0;\n  private codeCache = new Map<string, BlockNode>();\n  private observer?: MutationObserver;\n  private attributeHandlers: AttributeHandler[] = [];\n\n  constructor() {\n    this.registerDefaultAttributeHandlers();\n  }\n\n  async mount(root: HTMLElement): Promise<void> {\n    const elements: Element[] = [root, ...Array.from(root.querySelectorAll(\"*\"))];\n    for (const element of elements) {\n      if (!this.hasVsnAttributes(element)) {\n        continue;\n      }\n      const parentScope = this.findParentScope(element);\n      this.getScope(element, parentScope);\n      this.attachAttributes(element);\n      this.runConstruct(element);\n    }\n    await this.applyBehaviors(root);\n    this.attachObserver(root);\n  }\n\n  unmount(element: Element): void {\n    this.runDestruct(element);\n  }\n\n  registerBehaviors(source: string): void {\n    const program = new Parser(source).parseProgram();\n    for (const behavior of program.behaviors) {\n      this.collectBehavior(behavior);\n    }\n  }\n\n  registerAttributeHandler(handler: AttributeHandler): void {\n    this.attributeHandlers.push(handler);\n  }\n\n  getScope(element: Element, parentScope?: Scope): Scope {\n    const existing = this.scopes.get(element);\n    if (existing) {\n      return existing;\n    }\n    const scope = new Scope(parentScope ?? this.findParentScope(element));\n    this.scopes.set(element, scope);\n    return scope;\n  }\n\n  evaluate(element: Element): void {\n    const scope = this.getScope(element);\n    const bindConfig = this.bindBindings.get(element);\n    if (bindConfig && (bindConfig.direction === \"from\" || bindConfig.direction === \"both\")) {\n      applyBindToElement(element, bindConfig.expr, scope);\n    }\n    const ifExpr = this.ifBindings.get(element);\n    if (ifExpr && element instanceof HTMLElement) {\n      applyIf(element, ifExpr, scope);\n    }\n    const showExpr = this.showBindings.get(element);\n    if (showExpr && element instanceof HTMLElement) {\n      applyShow(element, showExpr, scope);\n    }\n    const htmlBinding = this.htmlBindings.get(element);\n    if (htmlBinding && element instanceof HTMLElement) {\n      applyHtml(element, htmlBinding.expr, scope, htmlBinding.trusted);\n    }\n  }\n\n  private attachObserver(root: HTMLElement): void {\n    if (this.observer) {\n      return;\n    }\n    this.observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        for (const node of Array.from(mutation.removedNodes)) {\n          if (node && node.nodeType === 1) {\n            this.handleRemovedNode(node as Element);\n          }\n        }\n      }\n    });\n    this.observer.observe(root, { childList: true, subtree: true });\n  }\n\n  private handleRemovedNode(node: Element): void {\n    if (this.lifecycleBindings.has(node)) {\n      this.runDestruct(node);\n    }\n    if (this.behaviorBindings.has(node)) {\n      this.runBehaviorDestruct(node);\n    }\n    for (const child of Array.from(node.querySelectorAll(\"*\"))) {\n      if (this.lifecycleBindings.has(child)) {\n        this.runDestruct(child);\n      }\n      if (this.behaviorBindings.has(child)) {\n        this.runBehaviorDestruct(child);\n      }\n    }\n  }\n\n  private async applyBehaviors(root: HTMLElement): Promise<void> {\n    if (this.behaviorRegistry.length === 0) {\n      return;\n    }\n    for (const behavior of this.behaviorRegistry) {\n      const matches: Element[] = [];\n      if (root.matches(behavior.selector)) {\n        matches.push(root);\n      }\n      matches.push(...Array.from(root.querySelectorAll(behavior.selector)));\n      for (const element of matches) {\n        const bound = this.behaviorBindings.get(element) ?? new Set<number>();\n        if (bound.has(behavior.id)) {\n          continue;\n        }\n        bound.add(behavior.id);\n        this.behaviorBindings.set(element, bound);\n        const scope = this.getScope(element);\n        if (behavior.construct) {\n          await this.executeBlock(behavior.construct, scope);\n        }\n      }\n    }\n  }\n\n  private runBehaviorDestruct(element: Element): void {\n    const bound = this.behaviorBindings.get(element);\n    if (!bound) {\n      return;\n    }\n    const scope = this.getScope(element);\n    for (const behavior of this.behaviorRegistry) {\n      if (!bound.has(behavior.id) || !behavior.destruct) {\n        continue;\n      }\n      void this.executeBlock(behavior.destruct, scope);\n    }\n  }\n\n  private attachAttributes(element: Element): void {\n    const scope = this.getScope(element);\n    for (const name of element.getAttributeNames()) {\n      if (!name.startsWith(\"vsn-\")) {\n        continue;\n      }\n      const value = element.getAttribute(name) ?? \"\";\n      for (const handler of this.attributeHandlers) {\n        if (!handler.match(name)) {\n          continue;\n        }\n        const handled = handler.handle(element, name, value, scope);\n        if (handled !== false) {\n          break;\n        }\n      }\n    }\n  }\n\n  private setLifecycle(element: Element, patch: LifecycleConfig): void {\n    const current = this.lifecycleBindings.get(element) ?? {};\n    this.lifecycleBindings.set(element, { ...current, ...patch });\n  }\n\n  private runConstruct(element: Element): void {\n    const config = this.lifecycleBindings.get(element);\n    if (!config?.construct) {\n      return;\n    }\n    const scope = this.getScope(element);\n    this.execute(config.construct, scope);\n  }\n\n  private runDestruct(element: Element): void {\n    const config = this.lifecycleBindings.get(element);\n    if (!config?.destruct) {\n      return;\n    }\n    const scope = this.getScope(element);\n    this.execute(config.destruct, scope);\n  }\n\n  private attachBindInputHandler(element: Element, expr: string): void {\n    if (!(element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement)) {\n      return;\n    }\n    const handler = () => {\n      const scope = this.getScope(element);\n      applyBindToScope(element, expr, scope);\n    };\n    element.addEventListener(\"input\", handler);\n    element.addEventListener(\"change\", handler);\n  }\n\n  private parseBindDirection(name: string): BindDirection {\n    if (name.includes(\":from\")) {\n      return \"from\";\n    }\n    if (name.includes(\":to\")) {\n      return \"to\";\n    }\n    return \"both\";\n  }\n\n  private hasVsnAttributes(element: Element): boolean {\n    return element.getAttributeNames().some((name) => name.startsWith(\"vsn-\"));\n  }\n\n  private findParentScope(element: Element): Scope | undefined {\n    let parent = element.parentElement;\n    while (parent) {\n      const scope = this.scopes.get(parent);\n      if (scope) {\n        return scope;\n      }\n      parent = parent.parentElement;\n    }\n    return undefined;\n  }\n\n  private watch(scope: Scope, expr: string, handler: () => void): void {\n    const key = expr.trim();\n    if (!key) {\n      return;\n    }\n    scope.on(key, handler);\n  }\n\n  private parseOnAttribute(name: string, value: string): OnConfig | null {\n    if (!name.startsWith(\"vsn-on:\")) {\n      return null;\n    }\n\n    const eventWithFlags = name.slice(\"vsn-on:\".length);\n    const [event, ...flags] = eventWithFlags.split(\"!\");\n    if (!event) {\n      return null;\n    }\n\n    let debounceMs: number | undefined;\n    for (const flag of flags) {\n      if (!flag.startsWith(\"debounce\")) {\n        continue;\n      }\n      const match = flag.match(/debounce\\((\\d+)\\)/);\n      debounceMs = match ? Number(match[1]) : 200;\n    }\n\n    const config: OnConfig = {\n      event,\n      code: value,\n      ...(debounceMs !== undefined ? { debounceMs } : {})\n    };\n    return config;\n  }\n\n  private attachOnHandler(element: Element, config: OnConfig): void {\n    const handler = async () => {\n      const scope = this.getScope(element);\n      await this.execute(config.code, scope);\n      this.evaluate(element);\n    };\n    const effectiveHandler = config.debounceMs ? debounce(handler, config.debounceMs) : handler;\n    element.addEventListener(config.event, effectiveHandler);\n  }\n\n  private attachGetHandler(element: Element): void {\n    element.addEventListener(\"click\", async () => {\n      const config = this.getBindings.get(element);\n      if (!config) {\n        return;\n      }\n      await applyGet(element, config, this.getScope(element));\n    });\n  }\n\n  private async execute(code: string, scope: Scope): Promise<void> {\n    let block = this.codeCache.get(code);\n    if (!block) {\n      block = Parser.parseInline(code);\n      this.codeCache.set(code, block);\n    }\n    const context: ExecutionContext = { scope };\n    await block.evaluate(context);\n  }\n\n  private async executeBlock(block: BlockNode, scope: Scope): Promise<void> {\n    const context: ExecutionContext = { scope };\n    await block.evaluate(context);\n  }\n\n  private collectBehavior(behavior: BehaviorNode, parentSelector?: string): void {\n    const selector = parentSelector\n      ? `${parentSelector} ${behavior.selector.selectorText}`\n      : behavior.selector.selectorText;\n    const lifecycle = this.extractLifecycle(behavior.body);\n    this.behaviorRegistry.push({\n      id: this.behaviorId += 1,\n      selector,\n      ...lifecycle\n    });\n    for (const statement of behavior.body.statements) {\n      if (statement instanceof BehaviorNode) {\n        this.collectBehavior(statement, selector);\n      }\n    }\n  }\n\n  private extractLifecycle(body: BlockNode): { construct?: BlockNode; destruct?: BlockNode } {\n    let construct: BlockNode | undefined;\n    let destruct: BlockNode | undefined;\n    for (const statement of body.statements) {\n      if (!(statement instanceof BlockNode)) {\n        continue;\n      }\n      if (statement.type === \"Construct\") {\n        construct = statement;\n      } else if (statement.type === \"Destruct\") {\n        destruct = statement;\n      }\n    }\n    return {\n      ...(construct ? { construct } : {}),\n      ...(destruct ? { destruct } : {})\n    };\n  }\n\n  private registerDefaultAttributeHandlers(): void {\n    this.registerAttributeHandler({\n      id: \"vsn-bind\",\n      match: (name) => name.startsWith(\"vsn-bind\"),\n      handle: (element, name, value, scope) => {\n        const direction = this.parseBindDirection(name);\n        this.bindBindings.set(element, { expr: value, direction });\n        if (direction === \"to\" || direction === \"both\") {\n          applyBindToScope(element, value, scope);\n          this.attachBindInputHandler(element, value);\n        }\n        if (direction === \"from\" || direction === \"both\") {\n          this.watch(scope, value, () => applyBindToElement(element, value, scope));\n        }\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-if\",\n      match: (name) => name === \"vsn-if\",\n      handle: (element, _name, value, scope) => {\n        this.ifBindings.set(element, value);\n        if (element instanceof HTMLElement) {\n          applyIf(element, value, scope);\n        }\n        this.watch(scope, value, () => this.evaluate(element));\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-show\",\n      match: (name) => name === \"vsn-show\",\n      handle: (element, _name, value, scope) => {\n        this.showBindings.set(element, value);\n        if (element instanceof HTMLElement) {\n          applyShow(element, value, scope);\n        }\n        this.watch(scope, value, () => this.evaluate(element));\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-html\",\n      match: (name) => name.startsWith(\"vsn-html\"),\n      handle: (element, name, value, scope) => {\n        const trusted = name.includes(\"!trusted\");\n        this.htmlBindings.set(element, { expr: value, trusted });\n        if (element instanceof HTMLElement) {\n          applyHtml(element, value, scope, trusted);\n        }\n        this.watch(scope, value, () => this.evaluate(element));\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-get\",\n      match: (name) => name.startsWith(\"vsn-get\"),\n      handle: (element, name) => {\n        const trusted = name.includes(\"!trusted\");\n        const url = element.getAttribute(name) ?? \"\";\n        const target = element.getAttribute(\"vsn-target\") ?? undefined;\n        const swap = (element.getAttribute(\"vsn-swap\") as \"inner\" | \"outer\" | null) ?? \"inner\";\n        const config: GetConfig = {\n          url,\n          swap,\n          trusted,\n          ...(target ? { targetSelector: target } : {})\n        };\n        this.getBindings.set(element, config);\n        this.attachGetHandler(element);\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-construct\",\n      match: (name) => name === \"vsn-construct\",\n      handle: (element, _name, value) => {\n        this.setLifecycle(element, { construct: value });\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-destruct\",\n      match: (name) => name === \"vsn-destruct\",\n      handle: (element, _name, value) => {\n        this.setLifecycle(element, { destruct: value });\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-on\",\n      match: (name) => name.startsWith(\"vsn-on:\"),\n      handle: (element, name, value) => {\n        const onConfig = this.parseOnAttribute(name, value);\n        if (onConfig) {\n          this.attachOnHandler(element, onConfig);\n        }\n      }\n    });\n  }\n}\n","export const VERSION = \"0.1.0\";\n\nexport { Lexer } from \"./parser/lexer\";\nimport { Parser } from \"./parser/parser\";\nimport { Engine } from \"./runtime/engine\";\nexport { Parser };\nexport { TokenType } from \"./parser/token\";\nexport * from \"./ast/nodes\";\nexport { Engine } from \"./runtime/engine\";\n\nexport function parseCFS(source: string) {\n  const parser = new Parser(source);\n  return parser.parseProgram();\n}\n\nexport function autoMount(root: HTMLElement | Document = document): Engine | null {\n  console.log('auto mounting');\n  if (typeof document === \"undefined\") {\n    return null;\n  }\n  const engine = new Engine();\n  const mount = () => {\n    const target = root instanceof Document ? root.body : root;\n    if (target) {\n      engine.mount(target);\n    }\n  };\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", mount, { once: true });\n  } else {\n    mount();\n  }\n  return engine;\n}\n\nif (typeof document !== \"undefined\") {\n  const scriptTag = document.querySelector(\"script[auto-mount]\");\n  if (scriptTag) {\n    autoMount();\n  }\n}\n"],"mappings":"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","names":["TokenType"]}