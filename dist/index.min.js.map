{"version":3,"sources":["../src/parser/token.ts","../src/parser/lexer.ts","../src/ast/nodes.ts","../src/parser/token-stream.ts","../src/parser/parser.ts","../src/runtime/scope.ts","../src/runtime/bindings.ts","../src/runtime/conditionals.ts","../src/runtime/html.ts","../src/runtime/http.ts","../src/runtime/debounce.ts","../src/runtime/engine.ts","../src/index.ts"],"sourcesContent":["export enum TokenType {\n  Whitespace = \"Whitespace\",\n  Identifier = \"Identifier\",\n  Number = \"Number\",\n  String = \"String\",\n  Template = \"Template\",\n  Boolean = \"Boolean\",\n  Null = \"Null\",\n\n  Behavior = \"Behavior\",\n  Use = \"Use\",\n  State = \"State\",\n  On = \"On\",\n  Construct = \"Construct\",\n  Destruct = \"Destruct\",\n  Return = \"Return\",\n  If = \"If\",\n  Else = \"Else\",\n  For = \"For\",\n  While = \"While\",\n  Try = \"Try\",\n  Catch = \"Catch\",\n  Assert = \"Assert\",\n  Break = \"Break\",\n  Continue = \"Continue\",\n\n  LBrace = \"LBrace\",\n  RBrace = \"RBrace\",\n  LParen = \"LParen\",\n  RParen = \"RParen\",\n  LBracket = \"LBracket\",\n  RBracket = \"RBracket\",\n\n  Colon = \"Colon\",\n  Semicolon = \"Semicolon\",\n  Comma = \"Comma\",\n\n  Ellipsis = \"Ellipsis\",\n  Dot = \"Dot\",\n  Hash = \"Hash\",\n  Greater = \"Greater\",\n  Less = \"Less\",\n  Plus = \"Plus\",\n  PlusPlus = \"PlusPlus\",\n  Minus = \"Minus\",\n  MinusMinus = \"MinusMinus\",\n  Tilde = \"Tilde\",\n  Star = \"Star\",\n  Slash = \"Slash\",\n  Percent = \"Percent\",\n\n  Equals = \"Equals\",\n  Arrow = \"Arrow\",\n  DoubleEquals = \"DoubleEquals\",\n  TripleEquals = \"TripleEquals\",\n  NotEquals = \"NotEquals\",\n  StrictNotEquals = \"StrictNotEquals\",\n  LessEqual = \"LessEqual\",\n  GreaterEqual = \"GreaterEqual\",\n  And = \"And\",\n  Or = \"Or\",\n  Pipe = \"Pipe\",\n  NullishCoalesce = \"NullishCoalesce\",\n  OptionalChain = \"OptionalChain\",\n  Bang = \"Bang\",\n\n  At = \"At\",\n  Dollar = \"Dollar\",\n  Question = \"Question\"\n}\n\nexport interface Position {\n  index: number;\n  line: number;\n  column: number;\n}\n\nexport interface Token {\n  type: TokenType;\n  value: string;\n  start: Position;\n  end: Position;\n}\n","import { Token, TokenType } from \"./token\";\n\nconst KEYWORDS: Record<string, TokenType> = {\n  behavior: TokenType.Behavior,\n  use: TokenType.Use,\n  state: TokenType.State,\n  on: TokenType.On,\n  construct: TokenType.Construct,\n  destruct: TokenType.Destruct,\n  return: TokenType.Return,\n  if: TokenType.If,\n  else: TokenType.Else,\n  for: TokenType.For,\n  while: TokenType.While,\n  try: TokenType.Try,\n  catch: TokenType.Catch,\n  assert: TokenType.Assert,\n  break: TokenType.Break,\n  continue: TokenType.Continue,\n  true: TokenType.Boolean,\n  false: TokenType.Boolean,\n  null: TokenType.Null\n};\n\nexport class Lexer {\n  private index = 0;\n  private line = 1;\n  private column = 1;\n  private pendingTokens: Token[] = [];\n  private templateMode = false;\n  private templateExpressionMode = false;\n  private templateBraceDepth = 0;\n\n  constructor(private input: string) {}\n\n  tokenize(): Token[] {\n    const tokens: Token[] = [];\n\n    while (!this.eof()) {\n      if (this.pendingTokens.length > 0) {\n        const pending = this.pendingTokens.shift();\n        if (pending) {\n          tokens.push(pending);\n          this.trackTemplateBrace(pending);\n          continue;\n        }\n      }\n\n      if (this.templateMode) {\n        const chunk = this.readTemplateChunk();\n        tokens.push(chunk);\n        continue;\n      }\n\n      const ch = this.peek();\n\n      if (this.isWhitespace(ch)) {\n        tokens.push(this.readWhitespace());\n        continue;\n      }\n\n      if (ch === \"`\") {\n        this.next();\n        this.templateMode = true;\n        continue;\n      }\n\n      if (ch === \"/\" && this.peek(1) === \"/\") {\n        this.readLineComment();\n        continue;\n      }\n\n      if (ch === \"/\" && this.peek(1) === \"*\") {\n        this.readBlockComment();\n        continue;\n      }\n\n      if (this.isAlpha(ch) || ch === \"_\") {\n        tokens.push(this.readIdentifier());\n        continue;\n      }\n\n    if (this.isDigit(ch) || (ch === \"-\" && this.isDigit(this.peek(1)))) {\n      tokens.push(this.readNumber());\n      continue;\n    }\n\n    if (ch === \"\\\"\" || ch === \"'\") {\n      tokens.push(this.readString());\n      continue;\n    }\n\n      const punct = this.readPunctuator();\n      if (punct) {\n        tokens.push(punct);\n        this.trackTemplateBrace(punct);\n        continue;\n      }\n\n      throw new Error(`Unexpected character '${ch}' at ${this.line}:${this.column}`);\n    }\n\n    return tokens;\n  }\n\n  private readWhitespace(): Token {\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof() && this.isWhitespace(this.peek())) {\n      value += this.next();\n    }\n    return this.token(TokenType.Whitespace, value, start);\n  }\n\n  private readLineComment(): void {\n    this.next();\n    this.next();\n    while (!this.eof() && this.peek() !== \"\\n\") {\n      this.next();\n    }\n  }\n\n  private readBlockComment(): void {\n    this.next();\n    this.next();\n    while (!this.eof()) {\n      if (this.peek() === \"*\" && this.peek(1) === \"/\") {\n        this.next();\n        this.next();\n        return;\n      }\n      this.next();\n    }\n  }\n\n  private readIdentifier(): Token {\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof()) {\n      const ch = this.peek();\n      if (this.isAlphaNumeric(ch) || ch === \"_\") {\n        value += this.next();\n        continue;\n      }\n      if (ch === \"-\") {\n        if (this.peek(1) === \"-\") {\n          break;\n        }\n        value += this.next();\n        continue;\n      }\n      break;\n    }\n\n    const keywordType = KEYWORDS[value];\n    if (keywordType) {\n      return this.token(keywordType, value, start);\n    }\n\n    return this.token(TokenType.Identifier, value, start);\n  }\n\n  private readNumber(): Token {\n    const start = this.position();\n    let value = \"\";\n    if (this.peek() === \"-\") {\n      value += this.next();\n    }\n    while (!this.eof() && this.isDigit(this.peek())) {\n      value += this.next();\n    }\n    if (this.peek() === \".\") {\n      value += this.next();\n      while (!this.eof() && this.isDigit(this.peek())) {\n        value += this.next();\n      }\n    }\n    return this.token(TokenType.Number, value, start);\n  }\n\n  private readString(): Token {\n    const quote = this.next();\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof()) {\n      const ch = this.next();\n      if (ch === \"\\\\\") {\n        const escaped = this.next();\n        value += escaped;\n        continue;\n      }\n      if (ch === quote) {\n        return this.token(TokenType.String, value, start);\n      }\n      value += ch;\n    }\n    throw new Error(`Unterminated string at ${start.line}:${start.column}`);\n  }\n\n  private readTemplateChunk(): Token {\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof()) {\n      const ch = this.peek();\n      if (ch === \"`\") {\n        this.next();\n        this.templateMode = false;\n        return this.token(TokenType.Template, value, start);\n      }\n      if (ch === \"$\" && this.peek(1) === \"{\") {\n        const dollarStart = this.position();\n        this.next();\n        const braceStart = this.position();\n        this.next();\n        this.templateMode = false;\n        this.templateExpressionMode = true;\n        this.templateBraceDepth = 0;\n        this.pendingTokens.push(this.token(TokenType.Dollar, \"$\", dollarStart));\n        this.pendingTokens.push(this.token(TokenType.LBrace, \"{\", braceStart));\n        return this.token(TokenType.Template, value, start);\n      }\n      if (ch === \"\\\\\") {\n        this.next();\n        const escaped = this.next();\n        value += escaped;\n        continue;\n      }\n      value += this.next();\n    }\n    throw new Error(`Unterminated template literal at ${start.line}:${start.column}`);\n  }\n\n  private readPunctuator(): Token | null {\n    const start = this.position();\n    const ch = this.peek();\n    const next = this.peek(1);\n\n    if (ch === \"=\" && next === \"=\" && this.peek(2) === \"=\") {\n      this.next();\n      this.next();\n      this.next();\n      return this.token(TokenType.TripleEquals, \"===\", start);\n    }\n    if (ch === \"=\" && next === \"=\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.DoubleEquals, \"==\", start);\n    }\n    if (ch === \"=\" && next === \">\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.Arrow, \"=>\", start);\n    }\n    if (ch === \"!\" && next === \"=\" && this.peek(2) === \"=\") {\n      this.next();\n      this.next();\n      this.next();\n      return this.token(TokenType.StrictNotEquals, \"!==\", start);\n    }\n    if (ch === \"!\" && next === \"=\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.NotEquals, \"!=\", start);\n    }\n    if (ch === \"<\" && next === \"=\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.LessEqual, \"<=\", start);\n    }\n    if (ch === \">\" && next === \"=\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.GreaterEqual, \">=\", start);\n    }\n    if (ch === \"&\" && next === \"&\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.And, \"&&\", start);\n    }\n    if (ch === \"|\" && next === \"|\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.Or, \"||\", start);\n    }\n    if (ch === \"?\" && next === \"?\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.NullishCoalesce, \"??\", start);\n    }\n    if (ch === \"?\" && next === \".\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.OptionalChain, \"?.\", start);\n    }\n    if (ch === \"|\" && next === \">\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.Pipe, \"|>\", start);\n    }\n    if (ch === \"+\" && next === \"+\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.PlusPlus, \"++\", start);\n    }\n    if (ch === \"-\" && next === \"-\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.MinusMinus, \"--\", start);\n    }\n    if (ch === \".\" && next === \".\" && this.peek(2) === \".\") {\n      this.next();\n      this.next();\n      this.next();\n      return this.token(TokenType.Ellipsis, \"...\", start);\n    }\n    const punctMap: Record<string, TokenType> = {\n      \"{\": TokenType.LBrace,\n      \"}\": TokenType.RBrace,\n      \"(\": TokenType.LParen,\n      \")\": TokenType.RParen,\n      \"[\": TokenType.LBracket,\n      \"]\": TokenType.RBracket,\n      \":\": TokenType.Colon,\n      \";\": TokenType.Semicolon,\n      \",\": TokenType.Comma,\n      \".\": TokenType.Dot,\n      \"#\": TokenType.Hash,\n      \">\": TokenType.Greater,\n      \"<\": TokenType.Less,\n      \"+\": TokenType.Plus,\n      \"-\": TokenType.Minus,\n      \"~\": TokenType.Tilde,\n      \"*\": TokenType.Star,\n      \"/\": TokenType.Slash,\n      \"%\": TokenType.Percent,\n      \"=\": TokenType.Equals,\n      \"!\": TokenType.Bang,\n      \"@\": TokenType.At,\n      \"$\": TokenType.Dollar,\n      \"?\": TokenType.Question\n    };\n\n    const type = punctMap[ch];\n    if (!type) {\n      return null;\n    }\n\n    this.next();\n    return this.token(type, ch, start);\n  }\n\n  private trackTemplateBrace(token: Token): void {\n    if (!this.templateExpressionMode) {\n      return;\n    }\n    if (token.type === TokenType.LBrace) {\n      this.templateBraceDepth += 1;\n    } else if (token.type === TokenType.RBrace) {\n      this.templateBraceDepth -= 1;\n      if (this.templateBraceDepth <= 0) {\n        this.templateExpressionMode = false;\n        this.templateMode = true;\n      }\n    }\n  }\n\n  private token(type: TokenType, value: string, start: { index: number; line: number; column: number }): Token {\n    return {\n      type,\n      value,\n      start,\n      end: this.position()\n    };\n  }\n\n  private position() {\n    return { index: this.index, line: this.line, column: this.column };\n  }\n\n  private peek(offset = 0): string {\n    return this.input[this.index + offset] ?? \"\";\n  }\n\n  private next(): string {\n    const ch = this.input[this.index++] ?? \"\";\n    if (ch === \"\\n\") {\n      this.line += 1;\n      this.column = 1;\n    } else {\n      this.column += 1;\n    }\n    return ch;\n  }\n\n  private eof(): boolean {\n    return this.index >= this.input.length;\n  }\n\n  private isWhitespace(ch: string): boolean {\n    return ch === \" \" || ch === \"\\t\" || ch === \"\\n\" || ch === \"\\r\";\n  }\n\n  private isAlpha(ch: string): boolean {\n    return (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\");\n  }\n\n  private isDigit(ch: string): boolean {\n    return ch >= \"0\" && ch <= \"9\";\n  }\n\n  private isAlphaNumeric(ch: string): boolean {\n    return this.isAlpha(ch) || this.isDigit(ch);\n  }\n}\n","export interface ExecutionContext {\n  scope: {\n    getPath(key: string): any;\n    setPath?(key: string, value: any): void;\n    hasKey?(key: string): boolean;\n    createChild?(): ExecutionContext[\"scope\"];\n  } | undefined;\n  rootScope: ExecutionContext[\"scope\"];\n  globals?: Record<string, any>;\n  element?: Element;\n  returnValue?: any;\n  returning?: boolean;\n  breaking?: boolean;\n  continuing?: boolean;\n}\n\nexport interface CFSNode {\n  type: string;\n  prepare(context: ExecutionContext): Promise<void>;\n  evaluate(context: ExecutionContext): any;\n}\n\nexport abstract class BaseNode implements CFSNode {\n  constructor(public type: string) {}\n\n  async prepare(_context: ExecutionContext): Promise<void> {\n    return;\n  }\n\n  evaluate(_context: ExecutionContext): any {\n    return undefined;\n  }\n}\n\nfunction isPromiseLike<T>(value: T | Promise<T>): value is Promise<T> {\n  return Boolean(value) && typeof (value as Promise<T>).then === \"function\";\n}\n\nfunction resolveMaybe<T, R>(value: T | Promise<T>, next: (value: T) => R | Promise<R>): R | Promise<R> {\n  if (isPromiseLike(value)) {\n    return value.then(next);\n  }\n  return next(value);\n}\n\nfunction evaluateWithChildScope(context: ExecutionContext, block: BlockNode): any {\n  const scope = context.scope;\n  if (!scope || !scope.createChild) {\n    return block.evaluate(context);\n  }\n  const previousScope = context.scope;\n  context.scope = scope.createChild();\n  try {\n    return block.evaluate(context);\n  } finally {\n    context.scope = previousScope;\n  }\n}\n\nexport class ProgramNode extends BaseNode {\n  constructor(public behaviors: BehaviorNode[], public uses: UseNode[] = []) {\n    super(\"Program\");\n  }\n}\n\nexport interface UseFlags {\n  wait?: boolean;\n}\n\nexport interface UseFlagArgs {\n  wait?: { timeoutMs?: number; intervalMs?: number };\n}\n\nexport class UseNode extends BaseNode {\n  constructor(\n    public name: string,\n    public alias: string,\n    public flags: UseFlags = {},\n    public flagArgs: UseFlagArgs = {}\n  ) {\n    super(\"Use\");\n  }\n}\n\nexport class BlockNode extends BaseNode {\n  constructor(public statements: CFSNode[]) {\n    super(\"Block\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    let index = 0;\n    const run = (): any => {\n      while (index < this.statements.length) {\n        if (context.returning || context.breaking || context.continuing) {\n          break;\n        }\n        const statement = this.statements[index];\n        index += 1;\n        if (statement && typeof statement.evaluate === \"function\") {\n          const result = statement.evaluate(context);\n          if (isPromiseLike(result)) {\n            return result.then(() => run());\n          }\n        }\n      }\n      return undefined;\n    };\n    return run();\n  }\n}\n\nexport class SelectorNode extends BaseNode {\n  constructor(public selectorText: string) {\n    super(\"Selector\");\n  }\n}\n\nexport class BehaviorNode extends BaseNode {\n  constructor(\n    public selector: SelectorNode,\n    public body: BlockNode,\n    public flags: BehaviorFlags = {},\n    public flagArgs: BehaviorFlagArgs = {}\n  ) {\n    super(\"Behavior\");\n  }\n}\n\n\nexport class OnBlockNode extends BaseNode {\n  constructor(\n    public eventName: string,\n    public args: string[],\n    public body: BlockNode,\n    public flags: DeclarationFlags = {},\n    public flagArgs: DeclarationFlagArgs = {}\n  ) {\n    super(\"OnBlock\");\n  }\n}\n\nexport class AssignmentNode extends BaseNode {\n  constructor(\n    public target: AssignmentTarget,\n    public value: ExpressionNode,\n    public operator: \"=\" | \"+=\" | \"-=\" | \"*=\" | \"/=\" | \"~=\" | \"++\" | \"--\" = \"=\",\n    public prefix = false\n  ) {\n    super(\"Assignment\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const target = this.target;\n    if (target instanceof DirectiveExpression) {\n      const value = this.value.evaluate(context);\n      return resolveMaybe(value, (resolvedValue) => {\n        this.assignDirectiveTarget(context, target, resolvedValue, this.operator);\n        return resolvedValue;\n      });\n    }\n    if (target instanceof ElementDirectiveExpression) {\n      const elementValue = target.element.evaluate(context);\n      return resolveMaybe(elementValue, (resolvedElement) => {\n        const element = resolveElementFromReference(resolvedElement);\n        if (!element) {\n          return undefined;\n        }\n        const value = this.value.evaluate(context);\n        return resolveMaybe(value, (resolvedValue) => {\n          this.assignDirectiveTarget(\n            { ...context, element },\n            target.directive,\n            resolvedValue,\n            this.operator\n          );\n          return resolvedValue;\n        });\n      });\n    }\n    if (!context.scope || !context.scope.setPath) {\n      return undefined;\n    }\n    if (this.operator === \"++\" || this.operator === \"--\") {\n      return this.applyIncrement(context);\n    }\n    const value = this.value.evaluate(context);\n    return resolveMaybe(value, (resolvedValue) => {\n      if (this.operator !== \"=\") {\n        return this.applyCompoundAssignment(context, resolvedValue);\n      }\n      if (this.target instanceof IdentifierExpression && this.target.name.startsWith(\"root.\") && context.rootScope) {\n        const path = this.target.name.slice(\"root.\".length);\n        context.rootScope.setPath?.(`self.${path}`, resolvedValue);\n        return resolvedValue;\n      }\n      if (this.target instanceof MemberExpression || this.target instanceof IndexExpression) {\n        const resolved = this.resolveAssignmentTarget(context);\n        return resolveMaybe(resolved, (resolvedTarget) => {\n          if (resolvedTarget?.scope?.setPath) {\n            resolvedTarget.scope.setPath(resolvedTarget.path, resolvedValue);\n            return resolvedValue;\n          }\n          this.assignTarget(context, this.target, resolvedValue);\n          return resolvedValue;\n        });\n      }\n      this.assignTarget(context, this.target, resolvedValue, this.operator);\n      return resolvedValue;\n    });\n  }\n\n  private applyCompoundAssignment(context: ExecutionContext, value: any): any {\n    if (!context.scope || !context.scope.setPath) {\n      return undefined;\n    }\n    const resolved = this.resolveAssignmentTarget(context);\n    return resolveMaybe(resolved, (resolvedTarget) => {\n      if (!resolvedTarget) {\n        throw new Error(\"Compound assignment requires a simple identifier or member path\");\n      }\n      const { scope, path } = resolvedTarget;\n      const current = scope?.getPath ? scope.getPath(path) : undefined;\n      let result: any;\n      if (this.operator === \"+=\") {\n        result = current + value;\n      } else if (this.operator === \"-=\") {\n        result = current - value;\n      } else if (this.operator === \"*=\") {\n        result = current * value;\n      } else {\n        result = current / value;\n      }\n      scope?.setPath?.(path, result);\n      return result;\n    });\n  }\n\n  private applyIncrement(context: ExecutionContext): any {\n    if (!context.scope || !context.scope.setPath) {\n      return undefined;\n    }\n    const resolved = this.resolveAssignmentTarget(context);\n    return resolveMaybe(resolved, (resolvedTarget) => {\n      if (!resolvedTarget) {\n        throw new Error(\"Increment/decrement requires a simple identifier or member path\");\n      }\n      const { scope, path } = resolvedTarget;\n      const current = scope?.getPath ? scope.getPath(path) : undefined;\n      const numeric = typeof current === \"number\" ? current : Number(current);\n      const delta = this.operator === \"++\" ? 1 : -1;\n      const next = (Number.isNaN(numeric) ? 0 : numeric) + delta;\n      scope?.setPath?.(path, next);\n      return this.prefix ? next : numeric;\n    });\n  }\n\n  private resolveAssignmentTarget(\n    context: ExecutionContext\n  ): { scope: ExecutionContext[\"scope\"]; path: string } | null | Promise<{ scope: ExecutionContext[\"scope\"]; path: string } | null> {\n    if (this.target instanceof IdentifierExpression) {\n      const isRoot = this.target.name.startsWith(\"root.\");\n      const rawPath = isRoot ? this.target.name.slice(\"root.\".length) : this.target.name;\n      if (isRoot) {\n        if (context.rootScope) {\n          return { scope: context.rootScope, path: `self.${rawPath}` };\n        }\n        return { scope: context.scope, path: `root.${rawPath}` };\n      }\n      return { scope: context.scope, path: rawPath };\n    }\n    if (this.target instanceof MemberExpression) {\n      const resolvedPath = this.target.getIdentifierPath();\n      if (resolvedPath) {\n        const path = resolvedPath.path;\n        const isRoot = path.startsWith(\"root.\");\n        const rawPath = isRoot ? path.slice(\"root.\".length) : path;\n        if (isRoot) {\n          if (context.rootScope) {\n            return { scope: context.rootScope, path: `self.${rawPath}` };\n          }\n          return { scope: context.scope, path: `root.${rawPath}` };\n        }\n        return { scope: context.scope, path: rawPath };\n      }\n      const targetExpr = this.target;\n      const basePath = this.resolveTargetPath(context, targetExpr.target);\n      return resolveMaybe(basePath, (resolvedBase) => {\n        if (!resolvedBase) {\n          return null;\n        }\n        const path = `${resolvedBase}.${targetExpr.property}`;\n        const isRoot = path.startsWith(\"root.\");\n        const rawPath = isRoot ? path.slice(\"root.\".length) : path;\n        if (isRoot) {\n          if (context.rootScope) {\n            return { scope: context.rootScope, path: `self.${rawPath}` };\n          }\n          return { scope: context.scope, path: `root.${rawPath}` };\n        }\n        return { scope: context.scope, path: rawPath };\n      });\n    }\n    if (this.target instanceof IndexExpression) {\n      const path = this.resolveIndexPath(context, this.target);\n      return resolveMaybe(path, (resolvedPath) => {\n        if (!resolvedPath) {\n          return null;\n        }\n        const isRoot = resolvedPath.startsWith(\"root.\");\n        const rawPath = isRoot ? resolvedPath.slice(\"root.\".length) : resolvedPath;\n        if (isRoot) {\n          if (context.rootScope) {\n            return { scope: context.rootScope, path: `self.${rawPath}` };\n          }\n          return { scope: context.scope, path: `root.${rawPath}` };\n        }\n        return { scope: context.scope, path: rawPath };\n      });\n    }\n    return null;\n  }\n\n  private resolveIndexPath(context: ExecutionContext, expr: IndexExpression): string | null | Promise<string | null> {\n    const base = this.resolveTargetPath(context, expr.target);\n    return resolveMaybe(base, (resolvedBase) => {\n      if (!resolvedBase) {\n        return null;\n      }\n      const indexValue = expr.index.evaluate(context);\n      return resolveMaybe(indexValue, (resolvedIndex) => {\n        if (resolvedIndex == null) {\n          return null;\n        }\n        return `${resolvedBase}.${resolvedIndex}`;\n      });\n    });\n  }\n\n  private resolveTargetPath(context: ExecutionContext, target: ExpressionNode): string | null | Promise<string | null> {\n    if (target instanceof IdentifierExpression) {\n      return target.name;\n    }\n    if (target instanceof MemberExpression) {\n      return target.getIdentifierPath()?.path ?? null;\n    }\n    if (target instanceof IndexExpression) {\n      return this.resolveIndexPath(context, target);\n    }\n    return null;\n  }\n\n  private assignTarget(\n    context: ExecutionContext,\n    target: AssignmentTarget,\n    value: any,\n    operator: AssignmentNode[\"operator\"] = \"=\"\n  ): void {\n    if (!context.scope || !context.scope.setPath) {\n      return;\n    }\n    if (target instanceof DirectiveExpression) {\n      this.assignDirectiveTarget(context, target, value, operator);\n      return;\n    }\n    if (target instanceof ElementDirectiveExpression) {\n      const elementValue = target.element.evaluate(context);\n      const next = resolveMaybe(elementValue, (resolvedElement) => {\n        const element = resolveElementFromReference(resolvedElement);\n        if (!element) {\n          return;\n        }\n        this.assignDirectiveTarget(\n          { ...context, element },\n          target.directive,\n          value,\n          operator\n        );\n      });\n      if (isPromiseLike(next)) {\n        void next;\n      }\n      return;\n    }\n    if (target instanceof ElementPropertyExpression) {\n      const elementValue = target.element.evaluate(context);\n      const next = resolveMaybe(elementValue, (resolvedElement) => {\n        if (resolvedElement && typeof resolvedElement === \"object\" && resolvedElement.__scope) {\n          resolvedElement.__scope.setPath?.(target.property, value);\n          return;\n        }\n        const element = resolveElementFromReference(resolvedElement);\n        if (!element) {\n          return;\n        }\n        (element as any)[target.property] = value;\n      });\n      if (isPromiseLike(next)) {\n        void next;\n      }\n      return;\n    }\n    if (target instanceof IdentifierExpression) {\n      context.scope.setPath(target.name, value);\n      return;\n    }\n    if (target instanceof ArrayPattern) {\n      const source = Array.isArray(value) ? value : [];\n      let index = 0;\n      for (const element of target.elements) {\n        if (element instanceof RestElement) {\n          context.scope.setPath(element.target.name, source.slice(index));\n          return;\n        }\n        if (element === null) {\n          index += 1;\n          continue;\n        }\n        this.assignTarget(context, element, source[index], operator);\n        index += 1;\n      }\n      return;\n    }\n    if (target instanceof ObjectPattern) {\n      const source = value && typeof value === \"object\" ? value : {};\n      const usedKeys = new Set<string>();\n      for (const entry of target.entries) {\n        if (\"rest\" in entry) {\n          const rest: Record<string, any> = {};\n          for (const key of Object.keys(source)) {\n            if (!usedKeys.has(key)) {\n              rest[key] = (source as any)[key];\n            }\n          }\n          context.scope.setPath(entry.rest.name, rest);\n          continue;\n        }\n        usedKeys.add(entry.key);\n        this.assignTarget(context, entry.target, (source as any)[entry.key], operator);\n      }\n      return;\n    }\n  }\n\n  private assignDirectiveTarget(\n    context: ExecutionContext,\n    target: DirectiveExpression,\n    value: any,\n    operator: AssignmentNode[\"operator\"] = \"=\"\n  ): void {\n    const element = context.element;\n    if (!element) {\n      return;\n    }\n    if (target.kind === \"attr\") {\n      if (target.name === \"class\" && \"classList\" in element && operator !== \"=\") {\n        const classes = normalizeClassList(value);\n        if (classes.length === 0) {\n          return;\n        }\n        if (operator === \"+=\") {\n          element.classList.add(...classes);\n          return;\n        }\n        if (operator === \"-=\") {\n          element.classList.remove(...classes);\n          return;\n        }\n        if (operator === \"~=\") {\n          for (const name of classes) {\n            element.classList.toggle(name);\n          }\n          return;\n        }\n      }\n      if (target.name === \"value\") {\n        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n          element.value = value == null ? \"\" : String(value);\n          element.setAttribute(\"value\", element.value);\n          return;\n        }\n        if (element instanceof HTMLSelectElement) {\n          element.value = value == null ? \"\" : String(value);\n          return;\n        }\n      }\n      if (target.name === \"checked\" && element instanceof HTMLInputElement) {\n        const checked = value === true || value === \"true\" || value === 1 || value === \"1\";\n        element.checked = checked;\n        if (checked) {\n          element.setAttribute(\"checked\", \"\");\n        } else {\n          element.removeAttribute(\"checked\");\n        }\n        return;\n      }\n      if (target.name === \"html\" && element instanceof HTMLElement) {\n        element.innerHTML = value == null ? \"\" : String(value);\n        return;\n      }\n      element.setAttribute(target.name, value == null ? \"\" : String(value));\n      return;\n    }\n    if (target.kind === \"style\" && element instanceof HTMLElement) {\n      element.style.setProperty(target.name, value == null ? \"\" : String(value));\n    }\n  }\n}\n\nfunction normalizeClassList(value: any): string[] {\n  if (value == null) {\n    return [];\n  }\n  if (Array.isArray(value)) {\n    return value\n      .flatMap((entry) => String(entry).split(/\\s+/))\n      .map((entry) => entry.trim())\n      .filter(Boolean);\n  }\n  return String(value)\n    .split(/\\s+/)\n    .map((entry) => entry.trim())\n    .filter(Boolean);\n}\n\nexport class ReturnNode extends BaseNode {\n  constructor(public value?: ExpressionNode) {\n    super(\"Return\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    if (context.returning) {\n      return context.returnValue;\n    }\n    const nextValue = this.value ? this.value.evaluate(context) : undefined;\n    return resolveMaybe(nextValue, (resolved) => {\n      context.returnValue = resolved;\n      context.returning = true;\n      return context.returnValue;\n    });\n  }\n}\n\nexport class BreakNode extends BaseNode {\n  constructor() {\n    super(\"Break\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    context.breaking = true;\n    return undefined;\n  }\n}\n\nexport class ContinueNode extends BaseNode {\n  constructor() {\n    super(\"Continue\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    context.continuing = true;\n    return undefined;\n  }\n}\n\nexport class AssertError extends Error {\n  constructor(message = \"Assertion failed\") {\n    super(message);\n    this.name = \"AssertError\";\n  }\n}\n\nexport class AssertNode extends BaseNode {\n  constructor(public test: ExpressionNode) {\n    super(\"Assert\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const value = this.test.evaluate(context);\n    return resolveMaybe(value, (resolved) => {\n      if (!resolved) {\n        throw new AssertError();\n      }\n      return resolved;\n    });\n  }\n}\n\nexport class IfNode extends BaseNode {\n  constructor(\n    public test: ExpressionNode,\n    public consequent: BlockNode,\n    public alternate?: BlockNode\n  ) {\n    super(\"If\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const condition = this.test.evaluate(context);\n    return resolveMaybe(condition, (resolved) => {\n      if (resolved) {\n        return evaluateWithChildScope(context, this.consequent);\n      }\n      if (this.alternate) {\n        return evaluateWithChildScope(context, this.alternate);\n      }\n      return undefined;\n    });\n  }\n}\n\nexport class WhileNode extends BaseNode {\n  constructor(public test: ExpressionNode, public body: BlockNode) {\n    super(\"While\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const previousScope = context.scope;\n    if (context.scope?.createChild) {\n      context.scope = context.scope.createChild();\n    }\n    const run = (): any => {\n      const condition = this.test.evaluate(context);\n      return resolveMaybe(condition, (resolved) => {\n        if (!resolved || context.returning) {\n          return undefined;\n        }\n        const bodyResult = this.body.evaluate(context);\n        return resolveMaybe(bodyResult, () => {\n          if (context.breaking) {\n            context.breaking = false;\n            return undefined;\n          }\n          if (context.continuing) {\n            context.continuing = false;\n          }\n          return run();\n        });\n      });\n    };\n    const result = run();\n    if (isPromiseLike(result)) {\n      return result.finally(() => {\n        context.scope = previousScope;\n      });\n    }\n    context.scope = previousScope;\n    return result;\n  }\n}\n\nexport class ForEachNode extends BaseNode {\n  constructor(\n    public target: IdentifierExpression,\n    public iterable: ExpressionNode,\n    public kind: \"in\" | \"of\",\n    public body: BlockNode\n  ) {\n    super(\"ForEach\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const iterableValue = this.iterable.evaluate(context);\n    return resolveMaybe(iterableValue, (resolved) => {\n      const entries = this.getEntries(resolved);\n      const previousScope = context.scope;\n      let bodyScope = context.scope;\n      if (context.scope?.createChild) {\n        bodyScope = context.scope.createChild();\n      }\n      let index = 0;\n      const loop = (): any => {\n        if (index >= entries.length || context.returning) {\n          context.scope = previousScope;\n          return undefined;\n        }\n        const value = entries[index]!;\n        index += 1;\n        context.scope = bodyScope;\n        context.scope?.setPath?.(this.target.name, value);\n        const bodyResult = this.body.evaluate(context);\n        return resolveMaybe(bodyResult, () => {\n          if (context.breaking) {\n            context.breaking = false;\n            context.scope = previousScope;\n            return undefined;\n          }\n          if (context.continuing) {\n            context.continuing = false;\n          }\n          context.scope = previousScope;\n          return loop();\n        });\n      };\n      return loop();\n    });\n  }\n\n  private getEntries(value: any): any[] {\n    if (value == null) {\n      return [];\n    }\n    if (this.kind === \"in\") {\n      if (typeof value === \"object\") {\n        return Object.keys(value);\n      }\n      return [];\n    }\n    if (typeof value === \"string\") {\n      return Array.from(value);\n    }\n    if (typeof value[Symbol.iterator] === \"function\") {\n      return Array.from(value as Iterable<any>);\n    }\n    if (typeof value === \"object\") {\n      return Object.values(value);\n    }\n    return [];\n  }\n}\n\nexport class ForNode extends BaseNode {\n  constructor(\n    public init: CFSNode | undefined,\n    public test: ExpressionNode | undefined,\n    public update: CFSNode | undefined,\n    public body: BlockNode\n  ) {\n    super(\"For\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const initResult = this.init ? this.init.evaluate(context) : undefined;\n    const run = (): any => {\n      const previousScope = context.scope;\n      let bodyScope = context.scope;\n      if (context.scope?.createChild) {\n        bodyScope = context.scope.createChild();\n      }\n      const loop = (): any => {\n        const testResult = this.test ? this.test.evaluate(context) : true;\n        return resolveMaybe(testResult, (passed) => {\n          if (!passed || context.returning) {\n            context.scope = previousScope;\n            return undefined;\n          }\n          context.scope = bodyScope;\n          const bodyResult = this.body.evaluate(context);\n          return resolveMaybe(bodyResult, () => {\n            if (context.returning) {\n              context.scope = previousScope;\n              return undefined;\n            }\n            if (context.breaking) {\n              context.breaking = false;\n              context.scope = previousScope;\n              return undefined;\n            }\n            context.scope = previousScope;\n            if (context.continuing) {\n              context.continuing = false;\n            }\n            const updateResult = this.update ? this.update.evaluate(context) : undefined;\n            return resolveMaybe(updateResult, () => loop());\n          });\n        });\n      };\n      return loop();\n    };\n    return resolveMaybe(initResult, () => run());\n  }\n}\n\nexport class TryNode extends BaseNode {\n  constructor(\n    public body: BlockNode,\n    public errorName: string,\n    public handler: BlockNode\n  ) {\n    super(\"Try\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const handleError = (error: any): any => {\n      if (context.returning) {\n        return context.returnValue;\n      }\n      const previousScope = context.scope;\n      let handlerScope = context.scope;\n      if (context.scope?.createChild) {\n        handlerScope = context.scope.createChild();\n      }\n      context.scope = handlerScope;\n      const scope = context.scope;\n      let previous: any = undefined;\n      if (scope) {\n        previous = scope.getPath(this.errorName);\n        if (scope.setPath) {\n          scope.setPath(`self.${this.errorName}`, error);\n        }\n      }\n      const handlerResult = this.handler.evaluate(context);\n      return resolveMaybe(handlerResult, () => {\n        if (scope && scope.setPath && handlerScope === previousScope) {\n          scope.setPath(this.errorName, previous);\n        }\n        context.scope = previousScope;\n        return undefined;\n      });\n    };\n\n    try {\n      const bodyResult = evaluateWithChildScope(context, this.body);\n      if (isPromiseLike(bodyResult)) {\n        return bodyResult.catch((error) => handleError(error));\n      }\n      return bodyResult;\n    } catch (error) {\n      return handleError(error);\n    }\n  }\n}\n\nexport class FunctionDeclarationNode extends BaseNode {\n  constructor(\n    public name: string,\n    public params: FunctionParam[],\n    public body: BlockNode,\n    public isAsync = false\n  ) {\n    super(\"FunctionDeclaration\");\n  }\n}\n\nexport class FunctionExpression extends BaseNode {\n  constructor(\n    public params: FunctionParam[],\n    public body: BlockNode,\n    public isAsync = false\n  ) {\n    super(\"FunctionExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const scope = context.scope;\n    const globals = context.globals;\n    const element = context.element;\n\n    if (this.isAsync) {\n      return (...args: any[]) => {\n        const activeScope = scope?.createChild ? scope.createChild() : scope;\n        const inner: ExecutionContext = {\n          scope: activeScope,\n          rootScope: context.rootScope,\n          ...(globals ? { globals } : {}),\n          ...(element ? { element } : {}),\n          returnValue: undefined,\n          returning: false,\n          breaking: false,\n          continuing: false\n        };\n        const previousValues = new Map<string, any>();\n        const applyResult = activeScope\n          ? this.applyParams(activeScope, previousValues, inner, args)\n          : undefined;\n        const bodyResult = resolveMaybe(applyResult, () => this.body.evaluate(inner));\n        const finalResult = resolveMaybe(bodyResult, () => inner.returnValue);\n        return Promise.resolve(finalResult).finally(() => {\n          if (activeScope && activeScope === scope) {\n            this.restoreParams(activeScope, previousValues);\n          }\n        });\n      };\n    }\n\n    return (...args: any[]) => {\n      const activeScope = scope?.createChild ? scope.createChild() : scope;\n      const inner: ExecutionContext = {\n        scope: activeScope,\n        rootScope: context.rootScope,\n        ...(globals ? { globals } : {}),\n        ...(element ? { element } : {}),\n        returnValue: undefined,\n        returning: false,\n        breaking: false,\n        continuing: false\n      };\n      const previousValues = new Map<string, any>();\n      const applyResult = activeScope\n        ? this.applyParams(activeScope, previousValues, inner, args)\n        : undefined;\n      const bodyResult = resolveMaybe(applyResult, () => this.body.evaluate(inner));\n      const finalResult = resolveMaybe(bodyResult, () => inner.returnValue);\n      if (isPromiseLike(finalResult)) {\n        return finalResult.finally(() => {\n          if (activeScope && activeScope === scope) {\n            this.restoreParams(activeScope, previousValues);\n          }\n        });\n      }\n      if (activeScope && activeScope === scope) {\n        this.restoreParams(activeScope, previousValues);\n      }\n      return finalResult;\n    };\n  }\n\n  private applyParams(\n    scope: ExecutionContext[\"scope\"],\n    previousValues: Map<string, any>,\n    context: ExecutionContext,\n    args: any[]\n  ): any {\n    if (!scope) {\n      return;\n    }\n    const setPath = scope.setPath?.bind(scope);\n    if (!setPath) {\n      return;\n    }\n    const params = this.params;\n    const applyAt = (paramIndex: number, argIndex: number): any => {\n      for (let i = paramIndex; i < params.length; i += 1) {\n        const param = params[i]!;\n        const name = param.name;\n        if (!name) {\n          continue;\n        }\n        previousValues.set(name, scope.getPath(name));\n        if (param.rest) {\n          setPath(`self.${name}`, args.slice(argIndex));\n          return;\n        }\n        let value = args[argIndex];\n        if (value === undefined && param.defaultValue) {\n          const defaultValue = param.defaultValue.evaluate(context);\n          return resolveMaybe(defaultValue, (resolvedDefault) => {\n            setPath(`self.${name}`, resolvedDefault);\n            return applyAt(i + 1, argIndex + 1);\n          });\n        }\n        setPath(`self.${name}`, value);\n        argIndex += 1;\n      }\n      return;\n    };\n    return applyAt(0, 0);\n  }\n\n  private restoreParams(scope: ExecutionContext[\"scope\"], previousValues: Map<string, any>): void {\n    if (!scope) {\n      return;\n    }\n    const setPath = scope.setPath?.bind(scope);\n    if (!setPath) {\n      return;\n    }\n    for (const param of this.params) {\n      const name = param.name;\n      if (!name) {\n        continue;\n      }\n      setPath(name, previousValues.get(name));\n    }\n  }\n}\n\nexport interface DeclarationFlags {\n  important?: boolean;\n  debounce?: boolean;\n  [key: string]: boolean | undefined;\n}\n\nexport interface DeclarationFlagArgs {\n  debounce?: number;\n  [key: string]: any;\n}\n\nexport interface BehaviorFlags {\n  [key: string]: boolean | undefined;\n}\n\nexport interface BehaviorFlagArgs {\n  [key: string]: any;\n}\n\nexport class DeclarationNode extends BaseNode {\n  constructor(\n    public target: DeclarationTarget,\n    public operator: \":\" | \":=\" | \":<\" | \":>\",\n    public value: ExpressionNode,\n    public flags: DeclarationFlags,\n    public flagArgs: DeclarationFlagArgs\n  ) {\n    super(\"Declaration\");\n  }\n}\n\nexport type ExpressionNode =\n  | AssignmentNode\n  | IdentifierExpression\n  | ElementRefExpression\n  | LiteralExpression\n  | TemplateExpression\n  | UnaryExpression\n  | BinaryExpression\n  | MemberExpression\n  | CallExpression\n  | ArrayExpression\n  | ObjectExpression\n  | IndexExpression\n  | FunctionExpression\n  | AwaitExpression\n  | TernaryExpression\n  | DirectiveExpression\n  | ElementDirectiveExpression\n  | ElementPropertyExpression\n  | QueryExpression;\n\nexport type DeclarationTarget = IdentifierExpression | DirectiveExpression;\nexport type AssignmentTarget =\n  | IdentifierExpression\n  | MemberExpression\n  | IndexExpression\n  | DirectiveExpression\n  | ElementDirectiveExpression\n  | ElementPropertyExpression\n  | ArrayPattern\n  | ObjectPattern;\n\nexport type FunctionParam = {\n  name: string;\n  defaultValue?: ExpressionNode;\n  rest?: boolean;\n};\n\nexport type PatternNode = IdentifierExpression | ArrayPattern | ObjectPattern;\n\nexport class IdentifierExpression extends BaseNode {\n  constructor(public name: string) {\n    super(\"Identifier\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    if (this.name.startsWith(\"root.\") && context.rootScope) {\n      const path = this.name.slice(\"root.\".length);\n      return context.rootScope.getPath(`self.${path}`);\n    }\n    if (context.scope) {\n      const value = context.scope.getPath(this.name);\n      const root = this.name.split(\".\")[0];\n      const explicit = this.name.startsWith(\"parent.\")\n        || this.name.startsWith(\"root.\")\n        || this.name.startsWith(\"self.\");\n      if (explicit || value !== undefined || (root && context.scope.hasKey?.(root))) {\n        return value;\n      }\n    }\n    return context.globals ? context.globals[this.name] : undefined;\n  }\n}\n\nexport class ElementRefExpression extends BaseNode {\n  constructor(public id: string) {\n    super(\"ElementRef\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const doc = context.element?.ownerDocument ?? (typeof document !== \"undefined\" ? document : undefined);\n    if (!doc) {\n      return undefined;\n    }\n    const element = doc.getElementById(this.id);\n    if (!element) {\n      return undefined;\n    }\n    const engine = (globalThis as any).VSNEngine;\n    const scope = engine?.getScope ? engine.getScope(element) : undefined;\n    return { __element: element, __scope: scope };\n  }\n}\n\nexport class SpreadElement extends BaseNode {\n  constructor(public value: ExpressionNode) {\n    super(\"SpreadElement\");\n  }\n}\n\nexport class RestElement extends BaseNode {\n  constructor(public target: IdentifierExpression) {\n    super(\"RestElement\");\n  }\n}\n\nexport type ArrayPatternElement = PatternNode | RestElement | null;\n\nexport class ArrayPattern extends BaseNode {\n  constructor(public elements: ArrayPatternElement[]) {\n    super(\"ArrayPattern\");\n  }\n}\n\nexport type ObjectPatternEntry =\n  | { key: string; target: PatternNode }\n  | { rest: IdentifierExpression };\n\nexport class ObjectPattern extends BaseNode {\n  constructor(public entries: ObjectPatternEntry[]) {\n    super(\"ObjectPattern\");\n  }\n}\n\nexport class LiteralExpression extends BaseNode {\n  constructor(public value: string | number | boolean | null) {\n    super(\"Literal\");\n  }\n\n  evaluate(): any {\n    return this.value;\n  }\n}\n\nexport class TemplateExpression extends BaseNode {\n  constructor(public parts: ExpressionNode[]) {\n    super(\"TemplateExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    let result = \"\";\n    let index = 0;\n    const run = (): any => {\n      while (index < this.parts.length) {\n        const part = this.parts[index]!;\n        index += 1;\n        const value = part.evaluate(context);\n        return resolveMaybe(value, (resolved) => {\n          result += resolved == null ? \"\" : String(resolved);\n          return run();\n        });\n      }\n      return result;\n    };\n    return run();\n  }\n}\n\nexport class UnaryExpression extends BaseNode {\n  constructor(public operator: string, public argument: ExpressionNode) {\n    super(\"UnaryExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const value = this.argument.evaluate(context);\n    return resolveMaybe(value, (resolved) => {\n      if (this.operator === \"!\") {\n        return !resolved;\n      }\n      if (this.operator === \"-\") {\n        return -(resolved as any);\n      }\n      return resolved;\n    });\n  }\n}\n\nexport class BinaryExpression extends BaseNode {\n  constructor(\n    public operator: string,\n    public left: ExpressionNode,\n    public right: ExpressionNode\n  ) {\n    super(\"BinaryExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const leftValue = this.left.evaluate(context);\n    return resolveMaybe(leftValue, (resolvedLeft) => {\n      if (this.operator === \"&&\") {\n        if (!resolvedLeft) {\n          return resolvedLeft;\n        }\n        return this.right.evaluate(context);\n      }\n      if (this.operator === \"||\") {\n        if (resolvedLeft) {\n          return resolvedLeft;\n        }\n        return this.right.evaluate(context);\n      }\n      if (this.operator === \"??\") {\n        if (resolvedLeft !== null && resolvedLeft !== undefined) {\n          return resolvedLeft;\n        }\n        return this.right.evaluate(context);\n      }\n      const rightValue = this.right.evaluate(context);\n      return resolveMaybe(rightValue, (resolvedRight) => {\n        if (this.operator === \"+\") {\n          return (resolvedLeft as any) + (resolvedRight as any);\n        }\n        if (this.operator === \"-\") {\n          return (resolvedLeft as any) - (resolvedRight as any);\n        }\n        if (this.operator === \"*\") {\n          return (resolvedLeft as any) * (resolvedRight as any);\n        }\n        if (this.operator === \"/\") {\n          return (resolvedLeft as any) / (resolvedRight as any);\n        }\n        if (this.operator === \"%\") {\n          return (resolvedLeft as any) % (resolvedRight as any);\n        }\n        if (this.operator === \"==\") {\n          return resolvedLeft == resolvedRight;\n        }\n        if (this.operator === \"!=\") {\n          return resolvedLeft != resolvedRight;\n        }\n        if (this.operator === \"===\") {\n          return resolvedLeft === resolvedRight;\n        }\n        if (this.operator === \"!==\") {\n          return resolvedLeft !== resolvedRight;\n        }\n        if (this.operator === \"<\") {\n          return (resolvedLeft as any) < (resolvedRight as any);\n        }\n        if (this.operator === \">\") {\n          return (resolvedLeft as any) > (resolvedRight as any);\n        }\n        if (this.operator === \"<=\") {\n          return (resolvedLeft as any) <= (resolvedRight as any);\n        }\n        if (this.operator === \">=\") {\n          return (resolvedLeft as any) >= (resolvedRight as any);\n        }\n        return undefined;\n      });\n    });\n  }\n}\n\nexport class TernaryExpression extends BaseNode {\n  constructor(\n    public test: ExpressionNode,\n    public consequent: ExpressionNode,\n    public alternate: ExpressionNode\n  ) {\n    super(\"TernaryExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const condition = this.test.evaluate(context);\n    return resolveMaybe(condition, (resolved) => {\n      if (resolved) {\n        return this.consequent.evaluate(context);\n      }\n      return this.alternate.evaluate(context);\n    });\n  }\n}\n\nexport class MemberExpression extends BaseNode {\n  constructor(\n    public target: ExpressionNode,\n    public property: string,\n    public optional = false\n  ) {\n    super(\"MemberExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const resolved = this.resolve(context);\n    return resolveMaybe(resolved, (resolvedValue) => resolvedValue?.value);\n  }\n\n  resolve(\n    context: ExecutionContext\n  ): { value: any; target?: any; optional?: boolean } | undefined | Promise<{ value: any; target?: any; optional?: boolean } | undefined> {\n    const path = this.getIdentifierPath();\n    if (path) {\n      const resolved = this.resolveFromScope(context, path);\n      if (resolved) {\n        return resolved;\n      }\n      const resolvedGlobal = this.resolveFromGlobals(context, path);\n      if (resolvedGlobal) {\n        return resolvedGlobal;\n      }\n    }\n\n    const target = this.target.evaluate(context);\n    return resolveMaybe(target, (resolvedTarget) => {\n      if (resolvedTarget == null) {\n        return { value: undefined, target: resolvedTarget, optional: this.optional };\n      }\n      return { value: (resolvedTarget as any)[this.property], target: resolvedTarget, optional: this.optional };\n    });\n  }\n\n  getIdentifierPath(): { path: string; root: string } | undefined {\n    const targetPath = this.getTargetIdentifierPath();\n    if (!targetPath) {\n      return undefined;\n    }\n    const path = `${targetPath.path}.${this.property}`;\n    return { path, root: targetPath.root };\n  }\n\n  private getTargetIdentifierPath(): { path: string; root: string } | undefined {\n    if (this.target instanceof IdentifierExpression) {\n      const name = this.target.name;\n      const root = name.split(\".\")[0];\n      if (!root) {\n        return undefined;\n      }\n      return { path: name, root };\n    }\n    if (this.target instanceof MemberExpression) {\n      return this.target.getIdentifierPath();\n    }\n    return undefined;\n  }\n\n  private resolveFromScope(\n    context: ExecutionContext,\n    path: { path: string; root: string }\n  ): { value: any; target?: any; optional?: boolean } | undefined {\n    if (!context.scope) {\n      return undefined;\n    }\n    if (path.path.startsWith(\"root.\") && context.rootScope) {\n      const localPath = path.path.slice(\"root.\".length);\n      const value = context.rootScope.getPath(`self.${localPath}`);\n      const targetPath = localPath.split(\".\").slice(0, -1).join(\".\");\n      const target = targetPath\n        ? context.rootScope.getPath(`self.${targetPath}`)\n        : context.rootScope;\n      return { value, target, optional: this.optional };\n    }\n    const value = context.scope.getPath(path.path);\n    const explicit = path.path.startsWith(\"parent.\")\n      || path.path.startsWith(\"root.\")\n      || path.path.startsWith(\"self.\");\n    if (!explicit && value === undefined && !context.scope.hasKey?.(path.root)) {\n      return undefined;\n    }\n    const targetPath = this.getTargetPath(path.path);\n    const target = targetPath ? context.scope.getPath(targetPath) : undefined;\n    return { value, target, optional: this.optional };\n  }\n\n  private resolveFromGlobals(\n    context: ExecutionContext,\n    path: { path: string; root: string }\n  ): { value: any; target?: any; optional?: boolean } | undefined {\n    const globals = context.globals ?? {};\n    if (!path.root || !(path.root in globals)) {\n      return undefined;\n    }\n    let value = globals[path.root];\n    let parent: any = undefined;\n    const parts = path.path.split(\".\");\n    for (let i = 1; i < parts.length; i += 1) {\n      parent = value;\n      const part = parts[i];\n      if (!part) {\n        return { value: undefined, target: parent, optional: this.optional };\n      }\n      value = value?.[part];\n    }\n    return { value, target: parent, optional: this.optional };\n  }\n\n  private getTargetPath(path: string): string | undefined {\n    const parts = path.split(\".\");\n    if (parts.length <= 1) {\n      return undefined;\n    }\n    return parts.slice(0, -1).join(\".\");\n  }\n}\n\nexport class CallExpression extends BaseNode {\n  constructor(public callee: ExpressionNode, public args: ExpressionNode[]) {\n    super(\"CallExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const resolved = this.resolveCallee(context);\n    return resolveMaybe(resolved, (resolvedCallee) => {\n      const fnValue = resolvedCallee?.fn ?? this.callee.evaluate(context);\n      return resolveMaybe(fnValue, (resolvedFn) => {\n        if (typeof resolvedFn !== \"function\") {\n          return undefined;\n        }\n        const values: any[] = [];\n        const evalArgs = (index: number): any => {\n          for (let i = index; i < this.args.length; i += 1) {\n            const arg = this.args[i]!;\n            const argValue = arg.evaluate(context);\n            return resolveMaybe(argValue, (resolvedArg) => {\n              values.push(resolvedArg);\n              return evalArgs(i + 1);\n            });\n          }\n          return resolvedFn.apply(resolvedCallee?.thisArg, values);\n        };\n        return evalArgs(0);\n      });\n    });\n  }\n\n  private resolveCallee(\n    context: ExecutionContext\n  ): { fn: any; thisArg?: any } | undefined | Promise<{ fn: any; thisArg?: any } | undefined> {\n    if (this.callee instanceof MemberExpression) {\n      const resolved = this.callee.resolve(context);\n      return resolveMaybe(resolved, (resolvedValue) => {\n        if (!resolvedValue) {\n          return undefined;\n        }\n        return { fn: resolvedValue.value, thisArg: resolvedValue.target };\n      });\n    }\n    if (!(this.callee instanceof IdentifierExpression)) {\n      return undefined;\n    }\n    const name = this.callee.name;\n    const globals = context.globals ?? {};\n    const parts = name.split(\".\");\n    const root = parts[0];\n    if (!root || !(root in globals)) {\n      if (parts.length > 1 && context.scope) {\n        const parentPath = parts.slice(0, -1).join(\".\");\n        const methodName = parts[parts.length - 1];\n        if (!methodName) {\n          return undefined;\n        }\n        const parentValue = context.scope.getPath(parentPath);\n        if (parentValue == null) {\n          return undefined;\n        }\n        return { fn: parentValue?.[methodName], thisArg: parentValue };\n      }\n      return undefined;\n    }\n    let value = globals[root];\n    let parent: any = undefined;\n    for (let i = 1; i < parts.length; i += 1) {\n      parent = value;\n      const part = parts[i];\n      if (!part) {\n        return undefined;\n      }\n      value = value?.[part];\n    }\n    return { fn: value, thisArg: parent };\n  }\n}\n\nexport type ArrayElement = ExpressionNode | SpreadElement;\n\nexport class ArrayExpression extends BaseNode {\n  constructor(public elements: ArrayElement[]) {\n    super(\"ArrayExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const values: any[] = [];\n    const pushElements = (value: any) => {\n      if (value == null) {\n        return;\n      }\n      const iterator = (value as any)[Symbol.iterator];\n      if (typeof iterator === \"function\") {\n        for (const entry of value as any) {\n          values.push(entry);\n        }\n      } else {\n        values.push(value);\n      }\n    };\n    const evalAt = (index: number): any => {\n      for (let i = index; i < this.elements.length; i += 1) {\n        const element = this.elements[i]!;\n        if (element instanceof SpreadElement) {\n          const spreadValue = element.value.evaluate(context);\n          return resolveMaybe(spreadValue, (resolvedSpread) => {\n            pushElements(resolvedSpread);\n            return evalAt(i + 1);\n          });\n        }\n        const value = element.evaluate(context);\n        return resolveMaybe(value, (resolvedValue) => {\n          values.push(resolvedValue);\n          return evalAt(i + 1);\n        });\n      }\n      return values;\n    };\n    return evalAt(0);\n  }\n}\n\nexport type ObjectEntry =\n  | { key: string; value: ExpressionNode; computed?: false }\n  | { keyExpr: ExpressionNode; value: ExpressionNode; computed: true }\n  | { spread: ExpressionNode };\n\nexport class ObjectExpression extends BaseNode {\n  constructor(public entries: ObjectEntry[]) {\n    super(\"ObjectExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const result: Record<string, any> = {};\n    const evalAt = (index: number): any => {\n      for (let i = index; i < this.entries.length; i += 1) {\n        const entry = this.entries[i]!;\n        if (\"spread\" in entry) {\n          const spreadValue = entry.spread.evaluate(context);\n          return resolveMaybe(spreadValue, (resolvedSpread) => {\n            if (resolvedSpread != null) {\n              Object.assign(result, resolvedSpread);\n            }\n            return evalAt(i + 1);\n          });\n        }\n        if (\"computed\" in entry && entry.computed) {\n          const keyValue = entry.keyExpr.evaluate(context);\n          return resolveMaybe(keyValue, (resolvedKey) => {\n            const entryValue = entry.value.evaluate(context);\n            return resolveMaybe(entryValue, (resolvedValue) => {\n              result[String(resolvedKey)] = resolvedValue;\n              return evalAt(i + 1);\n            });\n          });\n        }\n        const value = entry.value.evaluate(context);\n        return resolveMaybe(value, (resolvedValue) => {\n          result[entry.key] = resolvedValue;\n          return evalAt(i + 1);\n        });\n      }\n      return result;\n    };\n    return evalAt(0);\n  }\n}\n\nexport class IndexExpression extends BaseNode {\n  constructor(public target: ExpressionNode, public index: ExpressionNode) {\n    super(\"IndexExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const target = this.target.evaluate(context);\n    return resolveMaybe(target, (resolvedTarget) => {\n      if (resolvedTarget == null) {\n        return undefined;\n      }\n      const index = this.index.evaluate(context);\n      return resolveMaybe(index, (resolvedIndex) => {\n        if (resolvedIndex == null) {\n          return undefined;\n        }\n        const key = this.normalizeIndexKey(resolvedTarget, resolvedIndex);\n        return (resolvedTarget as any)[key as any];\n      });\n    });\n  }\n\n  private normalizeIndexKey(target: unknown, index: unknown): unknown {\n    if (Array.isArray(target) && typeof index === \"string\" && index.trim() !== \"\") {\n      const numeric = Number(index);\n      if (!Number.isNaN(numeric)) {\n        return numeric;\n      }\n    }\n    return index;\n  }\n}\n\nexport class DirectiveExpression extends BaseNode {\n  constructor(public kind: \"attr\" | \"style\", public name: string) {\n    super(\"Directive\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const element = context.element;\n    if (!element) {\n      return `${this.kind}:${this.name}`;\n    }\n    if (this.kind === \"attr\") {\n      if (this.name === \"value\") {\n        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n          return element.value;\n        }\n        if (element instanceof HTMLSelectElement) {\n          return element.value;\n        }\n      }\n      if (this.name === \"text\" && element instanceof HTMLElement) {\n        return element.innerText;\n      }\n      if (this.name === \"content\" && element instanceof HTMLElement) {\n        return element.textContent ?? \"\";\n      }\n      if (this.name === \"checked\" && element instanceof HTMLInputElement) {\n        return element.checked;\n      }\n      if (this.name === \"html\" && element instanceof HTMLElement) {\n        return element.innerHTML;\n      }\n      return element.getAttribute(this.name) ?? undefined;\n    }\n    if (this.kind === \"style\" && element instanceof HTMLElement) {\n      return element.style.getPropertyValue(this.name) ?? undefined;\n    }\n    return undefined;\n  }\n}\n\nexport class ElementDirectiveExpression extends BaseNode {\n  constructor(public element: ExpressionNode, public directive: DirectiveExpression) {\n    super(\"ElementDirective\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const elementValue = this.element.evaluate(context);\n    return resolveMaybe(elementValue, (resolvedElement) => {\n      const element = resolveElementFromReference(resolvedElement);\n      if (!element) {\n        return undefined;\n      }\n      const nextContext: ExecutionContext = { ...context, element };\n      return this.directive.evaluate(nextContext);\n    });\n  }\n}\n\nexport class ElementPropertyExpression extends BaseNode {\n  constructor(public element: ExpressionNode, public property: string) {\n    super(\"ElementProperty\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const elementValue = this.element.evaluate(context);\n    return resolveMaybe(elementValue, (resolvedElement) => {\n      if (resolvedElement && typeof resolvedElement === \"object\" && resolvedElement.__scope) {\n        return resolvedElement.__scope.getPath?.(this.property);\n      }\n      const element = resolveElementFromReference(resolvedElement);\n      if (!element) {\n        return undefined;\n      }\n      return (element as any)[this.property];\n    });\n  }\n}\n\nfunction resolveElementFromReference(value: any): Element | undefined {\n  if (value && typeof value === \"object\") {\n    if (value.nodeType === 1) {\n      return value as Element;\n    }\n    const candidate = value.__element;\n    if (candidate && typeof candidate === \"object\" && candidate.nodeType === 1) {\n      return candidate as Element;\n    }\n  }\n  return undefined;\n}\n\nexport class AwaitExpression extends BaseNode {\n  constructor(public argument: ExpressionNode) {\n    super(\"AwaitExpression\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const value = this.argument.evaluate(context);\n    return Promise.resolve(value);\n  }\n}\n\nexport class QueryExpression extends BaseNode {\n  constructor(public direction: \"self\" | \"descendant\" | \"ancestor\", public selector: string) {\n    super(\"Query\");\n  }\n\n  evaluate(context: ExecutionContext): any {\n    const selector = this.selector.trim();\n    if (!selector) {\n      return [];\n    }\n    if (this.direction === \"ancestor\") {\n      const results: Element[] = [];\n      let cursor = context.element?.parentElement;\n      while (cursor) {\n        if (cursor.matches(selector)) {\n          results.push(cursor);\n        }\n        cursor = cursor.parentElement;\n      }\n      return results;\n    }\n    const root = this.direction === \"descendant\"\n      ? context.element ?? (typeof document !== \"undefined\" ? document : undefined)\n      : (typeof document !== \"undefined\" ? document : undefined);\n    if (!root || !(\"querySelectorAll\" in root)) {\n      return [];\n    }\n    return Array.from((root as ParentNode).querySelectorAll(selector));\n  }\n}\n","import { Token, TokenType } from \"./token\";\n\nexport class TokenStream {\n  private index = 0;\n\n  constructor(private tokens: Token[]) {}\n\n  peek(offset = 0): Token | null {\n    return this.tokens[this.index + offset] ?? null;\n  }\n\n  next(): Token {\n    const token = this.tokens[this.index++];\n    if (!token) {\n      throw new Error(\"Unexpected end of input\");\n    }\n    return token;\n  }\n\n  eof(): boolean {\n    return this.index >= this.tokens.length;\n  }\n\n  match(type: TokenType): boolean {\n    if (this.peek()?.type === type) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n\n  expect(type: TokenType): Token {\n    const token = this.next();\n    if (token.type !== type) {\n      throw new Error(`Expected ${type} but got ${token.type}`);\n    }\n    return token;\n  }\n\n  skipWhitespace(): void {\n    while (this.peek()?.type === TokenType.Whitespace) {\n      this.next();\n    }\n  }\n\n  peekNonWhitespace(offset = 0): Token | null {\n    let count = 0;\n    for (let i = this.index; i < this.tokens.length; i++) {\n      const token = this.tokens[i];\n      if (!token) {\n        continue;\n      }\n      if (token.type === TokenType.Whitespace) {\n        continue;\n      }\n      if (count === offset) {\n        return token;\n      }\n      count += 1;\n    }\n    return null;\n  }\n\n  indexAfterDelimited(openType: TokenType, closeType: TokenType, offset = 0): number | null {\n    const first = this.peekNonWhitespace(offset);\n    if (!first || first.type !== openType) {\n      return null;\n    }\n    let index = offset + 1;\n    let depth = 1;\n    while (true) {\n      const token = this.peekNonWhitespace(index);\n      if (!token) {\n        return null;\n      }\n      if (token.type === openType) {\n        depth += 1;\n      } else if (token.type === closeType) {\n        depth -= 1;\n        if (depth === 0) {\n          return index + 1;\n        }\n      }\n      index += 1;\n    }\n  }\n}\n","import {\n  AssignmentNode,\n  ArrayExpression,\n  ArrayPattern,\n  AssertNode,\n  BreakNode,\n  CFSNode,\n  BehaviorNode,\n  BehaviorFlags,\n  BehaviorFlagArgs,\n  BinaryExpression,\n  BlockNode,\n  AssignmentTarget,\n  CallExpression,\n  DeclarationNode,\n  DeclarationTarget,\n  DeclarationFlags,\n  DeclarationFlagArgs,\n  MemberExpression,\n  DirectiveExpression,\n  ElementDirectiveExpression,\n  FunctionDeclarationNode,\n  FunctionExpression,\n  FunctionParam,\n  IdentifierExpression,\n  ElementRefExpression,\n  LiteralExpression,\n  ElementPropertyExpression,\n  RestElement,\n  SpreadElement,\n  TemplateExpression,\n  ForNode,\n  ForEachNode,\n  IfNode,\n  TryNode,\n  WhileNode,\n  ObjectPattern,\n  ObjectExpression,\n  ObjectEntry,\n  OnBlockNode,\n  ProgramNode,\n  QueryExpression,\n  ReturnNode,\n  ContinueNode,\n  SelectorNode,\n  TernaryExpression,\n  UnaryExpression,\n  UseNode,\n  IndexExpression,\n  ExpressionNode,\n  AwaitExpression,\n  UseFlags,\n  UseFlagArgs\n} from \"../ast/nodes\";\nimport { Lexer } from \"./lexer\";\nimport { TokenStream } from \"./token-stream\";\nimport { Token, TokenType } from \"./token\";\n\nexport class Parser {\n  private stream: TokenStream;\n  private source: string;\n  private customFlags: Set<string>;\n  private behaviorFlags: Set<string>;\n  private allowImplicitSemicolon = false;\n  private awaitStack: boolean[] = [];\n  private functionDepth = 0;\n\n  constructor(input: string, options?: { customFlags?: Set<string>; behaviorFlags?: Set<string> }) {\n    this.source = input;\n    this.customFlags = options?.customFlags ?? new Set<string>([\"important\", \"debounce\"]);\n    this.behaviorFlags = options?.behaviorFlags ?? new Set<string>();\n    const lexer = new Lexer(input);\n    this.stream = new TokenStream(lexer.tokenize());\n  }\n\n  static parseInline(code: string): BlockNode {\n    const parser = new Parser(`{${code}}`);\n    return parser.parseInlineBlock();\n  }\n\n  parseProgram(): ProgramNode {\n    return this.wrapErrors(() => {\n      const behaviors: BehaviorNode[] = [];\n      const uses: UseNode[] = [];\n      this.stream.skipWhitespace();\n      while (!this.stream.eof()) {\n        const next = this.stream.peek();\n        if (!next) {\n          break;\n        }\n        if (next.type === TokenType.Use) {\n          uses.push(this.parseUseStatement());\n        } else {\n          behaviors.push(this.parseBehavior());\n        }\n        this.stream.skipWhitespace();\n      }\n      return new ProgramNode(behaviors, uses);\n    });\n  }\n\n  parseInlineBlock(): BlockNode {\n    return this.wrapErrors(() => {\n      this.stream.skipWhitespace();\n      this.allowImplicitSemicolon = true;\n      return this.parseBlock({ allowDeclarations: false });\n    });\n  }\n\n  private parseBehavior(): BehaviorNode {\n    return this.wrapErrors(() => {\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Behavior);\n      const selector = this.parseSelector();\n      const { flags, flagArgs } = this.parseBehaviorFlags();\n      const body = this.parseBlock({ allowDeclarations: true });\n      return new BehaviorNode(selector, body, flags, flagArgs);\n    });\n  }\n\n  private parseSelector(): SelectorNode {\n    let selectorText = \"\";\n    let sawNonWhitespace = false;\n\n    while (true) {\n      const token = this.stream.peek();\n      if (!token) {\n        break;\n      }\n\n      if (token.type === TokenType.LBrace) {\n        break;\n      }\n      if (token.type === TokenType.Bang) {\n        break;\n      }\n\n      if (token.type === TokenType.Whitespace) {\n        this.stream.next();\n        if (sawNonWhitespace && selectorText[selectorText.length - 1] !== \" \") {\n          selectorText += \" \";\n        }\n        continue;\n      }\n\n      sawNonWhitespace = true;\n      selectorText += this.stream.next().value;\n    }\n\n    if (!selectorText.trim()) {\n      throw new Error(\"Behavior selector is required\");\n    }\n\n    return new SelectorNode(selectorText.trim());\n  }\n\n  private parseBehaviorFlags(): { flags: BehaviorFlags; flagArgs: BehaviorFlagArgs } {\n    const result = this.parseFlags(this.behaviorFlags, \"behavior modifier\");\n    return { flags: result.flags, flagArgs: result.flagArgs };\n  }\n\n  private parseUseStatement(): UseNode {\n    return this.wrapErrors(() => {\n      this.stream.expect(TokenType.Use);\n      this.stream.skipWhitespace();\n      const name = this.parseIdentifierPath();\n      this.stream.skipWhitespace();\n      let alias = name;\n      const next = this.stream.peek();\n      if (next?.type === TokenType.Identifier && next.value === \"as\") {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        alias = this.stream.expect(TokenType.Identifier).value;\n      }\n      const { flags, flagArgs } = this.parseUseFlags();\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Semicolon);\n      return new UseNode(name, alias, flags, flagArgs);\n    });\n  }\n\n  private parseUseFlags(): { flags: UseFlags; flagArgs: UseFlagArgs } {\n    const flags: UseFlags = {};\n    const flagArgs: UseFlagArgs = {};\n\n    while (true) {\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type !== TokenType.Bang) {\n        break;\n      }\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier).value;\n      if (name !== \"wait\") {\n        throw new Error(`Unknown flag ${name}`);\n      }\n      flags.wait = true;\n      if (this.stream.peek()?.type === TokenType.LParen) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const timeoutToken = this.stream.expect(TokenType.Number);\n        const timeoutMs = Number(timeoutToken.value);\n        let intervalMs: number | undefined;\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.Comma) {\n          this.stream.next();\n          this.stream.skipWhitespace();\n          const intervalToken = this.stream.expect(TokenType.Number);\n          intervalMs = Number(intervalToken.value);\n          this.stream.skipWhitespace();\n        }\n        this.stream.expect(TokenType.RParen);\n        flagArgs.wait = { timeoutMs, ...(intervalMs !== undefined ? { intervalMs } : {}) };\n      }\n    }\n\n    return { flags, flagArgs };\n  }\n\n  private wrapErrors<T>(fn: () => T): T {\n    try {\n      return fn();\n    } catch (error) {\n      if (error instanceof Error && !/\\(line\\s+\\d+, column\\s+\\d+\\)/i.test(error.message)) {\n        throw new Error(this.formatError(error.message));\n      }\n      throw error;\n    }\n  }\n\n  private formatError(message: string): string {\n    const token = this.stream.peek() ?? this.stream.peekNonWhitespace(0);\n    if (!token) {\n      return `Parse error: ${message}`;\n    }\n    const line = token.start.line;\n    const column = token.start.column;\n    const snippet = this.getLineSnippet(line, column);\n    return `Parse error (line ${line}, column ${column}): ${message}\\n${snippet}`;\n  }\n\n  private getLineSnippet(line: number, column: number): string {\n    const lines = this.source.split(/\\r?\\n/);\n    const content = lines[line - 1] ?? \"\";\n    const caret = `${\" \".repeat(Math.max(column - 1, 0))}^`;\n    return `${content}\\n${caret}`;\n  }\n\n  private parseBlock(options?: { allowDeclarations?: boolean; allowReturn?: boolean }): BlockNode {\n    const allowDeclarations = options?.allowDeclarations ?? false;\n    const allowReturn = options?.allowReturn ?? this.functionDepth > 0;\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LBrace);\n    const statements = [];\n    let declarationsOpen = allowDeclarations;\n    let sawConstruct = false;\n    let sawFunctionOrOn = false;\n    let sawNestedBehavior = false;\n\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated block\");\n      }\n      if (next.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n\n      if (allowDeclarations && next.type === TokenType.Behavior) {\n        sawNestedBehavior = true;\n      }\n\n      if (allowDeclarations && sawNestedBehavior && next.type !== TokenType.Behavior) {\n        throw new Error(\"Nested behaviors must appear after construct, function, and on blocks\");\n      }\n\n      const isFunctionDeclaration = allowDeclarations && this.isFunctionDeclarationStart();\n      if (isFunctionDeclaration) {\n        if (!sawConstruct) {\n          sawFunctionOrOn = true;\n        }\n        statements.push(this.parseFunctionDeclaration());\n        continue;\n      }\n      const isFunctionExpressionAssignment = allowDeclarations && this.isFunctionExpressionAssignmentStart();\n      if (isFunctionExpressionAssignment) {\n        if (!declarationsOpen) {\n          throw new Error(\"Declarations must appear before blocks\");\n        }\n        statements.push(this.parseAssignment());\n        continue;\n      }\n      const isDeclaration = this.isDeclarationStart();\n      if (isDeclaration) {\n        if (!allowDeclarations) {\n          throw new Error(\"Declarations are only allowed at the behavior root\");\n        }\n        if (!declarationsOpen) {\n          throw new Error(\"Declarations must appear before blocks\");\n        }\n        statements.push(this.parseDeclaration());\n      } else {\n        if (declarationsOpen) {\n          declarationsOpen = false;\n        }\n        if (allowDeclarations && next.type === TokenType.On && !sawConstruct) {\n          sawFunctionOrOn = true;\n        }\n        if (allowDeclarations && next.type === TokenType.Construct) {\n          if (sawFunctionOrOn) {\n            throw new Error(\"Construct blocks must appear before functions and on blocks\");\n          }\n          sawConstruct = true;\n        }\n        statements.push(this.parseStatement({ allowReturn }));\n      }\n    }\n\n    return new BlockNode(statements);\n  }\n\n  private parseStatement(options?: { allowBlocks?: boolean; allowReturn?: boolean }) {\n    this.stream.skipWhitespace();\n    const next = this.stream.peek();\n    if (!next) {\n      throw new Error(\"Unexpected end of input\");\n    }\n\n    const allowBlocks = options?.allowBlocks ?? true;\n    const allowReturn = options?.allowReturn ?? false;\n\n    if (next.type === TokenType.Return) {\n      if (!allowReturn) {\n        throw new Error(\"Return is only allowed inside functions\");\n      }\n      return this.parseReturnStatement();\n    }\n\n    if (next.type === TokenType.Assert) {\n      return this.parseAssertStatement();\n    }\n\n    if (next.type === TokenType.Break) {\n      return this.parseBreakStatement();\n    }\n\n    if (next.type === TokenType.Continue) {\n      return this.parseContinueStatement();\n    }\n\n    if (allowBlocks && next.type === TokenType.On) {\n      return this.parseOnBlock();\n    }\n\n    if (allowBlocks && next.type === TokenType.If) {\n      return this.parseIfBlock();\n    }\n\n    if (allowBlocks && next.type === TokenType.For) {\n      return this.parseForBlock();\n    }\n\n    if (allowBlocks && next.type === TokenType.While) {\n      return this.parseWhileBlock();\n    }\n\n    if (allowBlocks && next.type === TokenType.Try) {\n      return this.parseTryBlock();\n    }\n\n    if (allowBlocks && next.type === TokenType.Construct) {\n      return this.parseConstructBlock();\n    }\n\n    if (allowBlocks && next.type === TokenType.Destruct) {\n      return this.parseDestructBlock();\n    }\n\n    if (allowBlocks && next.type === TokenType.Behavior) {\n      return this.parseBehavior();\n    }\n\n    if (this.isAwaitAllowed() && next.type === TokenType.Identifier && next.value === \"await\") {\n      return this.parseExpressionStatement();\n    }\n\n    if (this.isAssignmentStart()) {\n      return this.parseAssignment();\n    }\n\n    if (this.isExpressionStatementStart()) {\n      return this.parseExpressionStatement();\n    }\n\n    throw new Error(`Unexpected token ${next.type}`);\n  }\n\n  private parseOnBlock(): OnBlockNode {\n    this.stream.expect(TokenType.On);\n    this.stream.skipWhitespace();\n    const event = this.parseIdentifierPath();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    const args: string[] = [];\n\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated on() arguments\");\n      }\n      if (next.type === TokenType.RParen) {\n        this.stream.next();\n        break;\n      }\n      if (next.type === TokenType.Identifier) {\n        args.push(this.stream.next().value);\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.Comma) {\n          this.stream.next();\n        }\n        continue;\n      }\n      throw new Error(`Unexpected token in on() args: ${next.type}`);\n    }\n\n    const { flags, flagArgs } = this.parseFlags(this.customFlags, \"flag\");\n    const body = this.parseBlock({ allowDeclarations: false });\n    return new OnBlockNode(event, args, body, flags, flagArgs);\n  }\n\n  private parseAssignment(): AssignmentNode {\n    const target = this.parseAssignmentTarget();\n    this.stream.skipWhitespace();\n    const operator = this.parseAssignmentOperator();\n    this.stream.skipWhitespace();\n    const value = this.parseExpression();\n    this.consumeStatementTerminator();\n    return new AssignmentNode(target, value, operator);\n  }\n\n  private parseExpression(): ExpressionNode {\n    return this.parsePipeExpression();\n  }\n\n  private parsePipeExpression(): ExpressionNode {\n    let expr = this.parseTernaryExpression();\n    while (true) {\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type !== TokenType.Pipe) {\n        break;\n      }\n      this.stream.next();\n      this.stream.skipWhitespace();\n      let awaitStage = false;\n      const next = this.stream.peek();\n      if (this.isAwaitAllowed() && next?.type === TokenType.Identifier && next.value === \"await\") {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        awaitStage = true;\n      }\n      const stage = this.parseCallExpression();\n      const call = this.buildPipeCall(expr, stage);\n      expr = awaitStage ? new AwaitExpression(call) : call;\n    }\n    return expr;\n  }\n\n  private buildPipeCall(input: ExpressionNode, stage: ExpressionNode): ExpressionNode {\n    if (stage instanceof CallExpression) {\n      return new CallExpression(stage.callee, [input, ...stage.args]);\n    }\n    if (stage instanceof IdentifierExpression || stage instanceof MemberExpression) {\n      return new CallExpression(stage, [input]);\n    }\n    throw new Error(\"Pipe operator requires a function call\");\n  }\n\n  private parseTernaryExpression(): ExpressionNode {\n    let test = this.parseNullishExpression();\n    this.stream.skipWhitespace();\n    if (this.stream.peek()?.type !== TokenType.Question) {\n      return test;\n    }\n    this.stream.next();\n    this.stream.skipWhitespace();\n    const consequent = this.parseExpression();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Colon);\n    this.stream.skipWhitespace();\n    const alternate = this.parseExpression();\n    return new TernaryExpression(test, consequent, alternate);\n  }\n\n  private parseNullishExpression(): ExpressionNode {\n    let expr = this.parseLogicalOrExpression();\n    while (true) {\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type !== TokenType.NullishCoalesce) {\n        break;\n      }\n      this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseLogicalOrExpression();\n      expr = new BinaryExpression(\"??\", expr, right);\n    }\n    return expr;\n  }\n\n  private parseLogicalOrExpression(): ExpressionNode {\n    let left = this.parseLogicalAndExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next || next.type !== TokenType.Or) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseLogicalAndExpression();\n      this.stream.skipWhitespace();\n      left = new BinaryExpression(\"||\", left, right);\n    }\n    return left;\n  }\n\n  private parseLogicalAndExpression(): ExpressionNode {\n    let left = this.parseEqualityExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next || next.type !== TokenType.And) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseEqualityExpression();\n      this.stream.skipWhitespace();\n      left = new BinaryExpression(\"&&\", left, right);\n    }\n    return left;\n  }\n\n  private parseEqualityExpression(): ExpressionNode {\n    let left = this.parseComparisonExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next || (next.type !== TokenType.DoubleEquals &&\n          next.type !== TokenType.NotEquals &&\n          next.type !== TokenType.TripleEquals &&\n          next.type !== TokenType.StrictNotEquals)) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      const op = this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseComparisonExpression();\n      this.stream.skipWhitespace();\n      let operator = \"==\";\n      if (op.type === TokenType.NotEquals) {\n        operator = \"!=\";\n      } else if (op.type === TokenType.TripleEquals) {\n        operator = \"===\";\n      } else if (op.type === TokenType.StrictNotEquals) {\n        operator = \"!==\";\n      }\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n\n  private parseComparisonExpression(): ExpressionNode {\n    let left = this.parseAdditiveExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next) {\n        break;\n      }\n      if (next.type !== TokenType.Less &&\n          next.type !== TokenType.Greater &&\n          next.type !== TokenType.LessEqual &&\n          next.type !== TokenType.GreaterEqual) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      const op = this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseAdditiveExpression();\n      this.stream.skipWhitespace();\n      let operator = \"<\";\n      if (op.type === TokenType.Greater) {\n        operator = \">\";\n      } else if (op.type === TokenType.LessEqual) {\n        operator = \"<=\";\n      } else if (op.type === TokenType.GreaterEqual) {\n        operator = \">=\";\n      }\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n\n  private parseMultiplicativeExpression(): ExpressionNode {\n    let left = this.parseUnaryExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next) {\n        break;\n      }\n      if (next.type !== TokenType.Star &&\n          next.type !== TokenType.Slash &&\n          next.type !== TokenType.Percent) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      const op = this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseUnaryExpression();\n      this.stream.skipWhitespace();\n      let operator = \"*\";\n      if (op.type === TokenType.Slash) {\n        operator = \"/\";\n      } else if (op.type === TokenType.Percent) {\n        operator = \"%\";\n      }\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n\n  private parseAdditiveExpression(): ExpressionNode {\n    let left = this.parseMultiplicativeExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next || (next.type !== TokenType.Plus && next.type !== TokenType.Minus)) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      const op = this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseMultiplicativeExpression();\n      this.stream.skipWhitespace();\n      left = new BinaryExpression(op.type === TokenType.Plus ? \"+\" : \"-\", left, right);\n    }\n    return left;\n  }\n\n  private parseUnaryExpression(): ExpressionNode {\n    this.stream.skipWhitespace();\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected expression\");\n    }\n    if (token.type === TokenType.PlusPlus || token.type === TokenType.MinusMinus) {\n      this.stream.next();\n      const argument = this.parseUnaryExpression();\n      return this.createIncrementNode(token, argument, true);\n    }\n    if (token.type === TokenType.Bang) {\n      this.stream.next();\n      const argument = this.parseUnaryExpression();\n      return new UnaryExpression(\"!\", argument);\n    }\n    if (token.type === TokenType.Minus) {\n      this.stream.next();\n      const argument = this.parseUnaryExpression();\n      return new UnaryExpression(\"-\", argument);\n    }\n    if (this.isAwaitAllowed() && token.type === TokenType.Identifier && token.value === \"await\") {\n      this.stream.next();\n      const argument = this.parseUnaryExpression();\n      return new AwaitExpression(argument);\n    }\n    return this.parsePostfixExpression();\n  }\n\n  private parsePostfixExpression(): ExpressionNode {\n    let expr = this.parseCallExpression();\n    while (true) {\n      this.stream.skipWhitespace();\n      const token = this.stream.peek();\n      if (!token) {\n        break;\n      }\n      if (token.type === TokenType.PlusPlus || token.type === TokenType.MinusMinus) {\n        this.stream.next();\n        expr = this.createIncrementNode(token, expr, false);\n        continue;\n      }\n      break;\n    }\n    return expr;\n  }\n\n  private createIncrementNode(token: Token, argument: ExpressionNode, prefix: boolean): ExpressionNode {\n    if (\n      !(argument instanceof IdentifierExpression)\n      && !(argument instanceof MemberExpression)\n      && !(argument instanceof IndexExpression)\n      && !(argument instanceof DirectiveExpression)\n      && !(argument instanceof ElementDirectiveExpression)\n    ) {\n      throw new Error(\"Increment/decrement requires a mutable target\");\n    }\n    const operator = token.type === TokenType.PlusPlus ? \"++\" : \"--\";\n    return new AssignmentNode(argument, new LiteralExpression(1), operator, prefix) as ExpressionNode;\n  }\n\n  private parseCallExpression(): ExpressionNode {\n    let expr = this.parsePrimaryExpression();\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        break;\n      }\n      if (next.type === TokenType.LParen) {\n        this.stream.next();\n        const args: ExpressionNode[] = [];\n        while (true) {\n          this.stream.skipWhitespace();\n          const argToken = this.stream.peek();\n          if (!argToken) {\n            throw new Error(\"Unterminated call expression\");\n          }\n          if (argToken.type === TokenType.RParen) {\n            this.stream.next();\n            break;\n          }\n          args.push(this.parseExpression());\n          this.stream.skipWhitespace();\n          if (this.stream.peek()?.type === TokenType.Comma) {\n            this.stream.next();\n            continue;\n          }\n          if (this.stream.peek()?.type === TokenType.RParen) {\n            this.stream.next();\n            break;\n          }\n          throw new Error(\"Expected ',' or ')' in call arguments\");\n        }\n        expr = new CallExpression(expr, args);\n        continue;\n      }\n      if (next.type === TokenType.OptionalChain) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const chained = this.stream.peek();\n        if (!chained) {\n          throw new Error(\"Expected property or call after ?.\");\n        }\n        if (chained.type === TokenType.LParen) {\n          this.stream.next();\n          const args: ExpressionNode[] = [];\n          while (true) {\n            this.stream.skipWhitespace();\n            const argToken = this.stream.peek();\n            if (!argToken) {\n              throw new Error(\"Unterminated call expression\");\n            }\n            if (argToken.type === TokenType.RParen) {\n              this.stream.next();\n              break;\n            }\n            args.push(this.parseExpression());\n            this.stream.skipWhitespace();\n            if (this.stream.peek()?.type === TokenType.Comma) {\n              this.stream.next();\n              continue;\n            }\n            if (this.stream.peek()?.type === TokenType.RParen) {\n              this.stream.next();\n              break;\n            }\n            throw new Error(\"Expected ',' or ')' in call arguments\");\n          }\n          expr = new CallExpression(expr, args);\n          continue;\n        }\n        if (chained.type === TokenType.Identifier) {\n          const name = this.stream.next();\n          expr = new MemberExpression(expr, name.value, true);\n          continue;\n        }\n        throw new Error(\"Expected property or call after ?.\");\n      }\n      if (next.type === TokenType.Dot) {\n        this.stream.next();\n        const chained = this.stream.peek();\n        if (chained?.type === TokenType.At || chained?.type === TokenType.Dollar) {\n          const directive = this.parseDirectiveExpression();\n          expr = new ElementDirectiveExpression(expr, directive);\n        } else {\n          const name = this.stream.expect(TokenType.Identifier);\n          if (expr instanceof ElementRefExpression) {\n            expr = new ElementPropertyExpression(expr, name.value);\n          } else {\n            expr = new MemberExpression(expr, name.value);\n          }\n        }\n        continue;\n      }\n      if (next.type === TokenType.LBracket) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const index = this.parseExpression();\n        this.stream.skipWhitespace();\n        this.stream.expect(TokenType.RBracket);\n        expr = new IndexExpression(expr, index);\n        continue;\n      }\n      break;\n    }\n    return expr;\n  }\n\n  private parsePrimaryExpression(): ExpressionNode {\n    this.stream.skipWhitespace();\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected expression\");\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      return this.parseDirectiveExpression();\n    }\n\n    if (token.type === TokenType.Hash) {\n      return this.parseElementRefExpression();\n    }\n\n    if (token.type === TokenType.Question) {\n      return this.parseQueryExpression();\n    }\n\n    if (token.type === TokenType.LBracket) {\n      return this.parseArrayExpression();\n    }\n\n    if (token.type === TokenType.LBrace) {\n      return this.parseObjectExpression();\n    }\n\n    if (token.type === TokenType.LParen) {\n      if (this.isArrowFunctionStart()) {\n        return this.parseArrowFunctionExpression();\n      }\n      this.stream.next();\n      const value = this.parseExpression();\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.RParen);\n      return value;\n    }\n\n    if (token.type === TokenType.Identifier) {\n      if (this.isAsyncToken(token) && this.isAsyncArrowFunctionStart()) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        return this.parseArrowFunctionExpression(true);\n      }\n      return new IdentifierExpression(this.stream.next().value);\n    }\n\n    if (token.type === TokenType.Boolean) {\n      return new LiteralExpression(this.stream.next().value === \"true\");\n    }\n\n    if (token.type === TokenType.Null) {\n      this.stream.next();\n      return new LiteralExpression(null);\n    }\n\n    if (token.type === TokenType.Number) {\n      return new LiteralExpression(Number(this.stream.next().value));\n    }\n\n    if (token.type === TokenType.String) {\n      return new LiteralExpression(this.stream.next().value);\n    }\n\n    if (token.type === TokenType.Template) {\n      return this.parseTemplateExpression();\n    }\n\n    throw new Error(`Unsupported expression token ${token.type}`);\n  }\n\n  private parseDirectiveExpression(): DirectiveExpression {\n    const token = this.stream.peek();\n    if (!token || (token.type !== TokenType.At && token.type !== TokenType.Dollar)) {\n      throw new Error(\"Expected directive\");\n    }\n    const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n    this.stream.next();\n    const name = this.stream.expect(TokenType.Identifier);\n    return new DirectiveExpression(kind, name.value);\n  }\n\n  private parseElementRefExpression(): ElementRefExpression {\n    this.stream.expect(TokenType.Hash);\n    const id = this.stream.expect(TokenType.Identifier).value;\n    return new ElementRefExpression(id);\n  }\n\n  private parseArrayExpression(): ExpressionNode {\n    this.stream.expect(TokenType.LBracket);\n    const elements: (ExpressionNode | SpreadElement)[] = [];\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated array literal\");\n      }\n      if (next.type === TokenType.RBracket) {\n        this.stream.next();\n        break;\n      }\n      if (next.type === TokenType.Ellipsis) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const value = this.parseExpression();\n        elements.push(new SpreadElement(value));\n      } else {\n        elements.push(this.parseExpression());\n      }\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.Comma) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.RBracket) {\n          this.stream.next();\n          break;\n        }\n        continue;\n      }\n      if (this.stream.peek()?.type === TokenType.RBracket) {\n        this.stream.next();\n        break;\n      }\n      throw new Error(\"Expected ',' or ']' in array literal\");\n    }\n    return new ArrayExpression(elements);\n  }\n\n  private parseTemplateExpression(): ExpressionNode {\n    const parts: ExpressionNode[] = [];\n    while (true) {\n      const token = this.stream.peek();\n      if (!token) {\n        throw new Error(\"Unterminated template literal\");\n      }\n      if (token.type !== TokenType.Template) {\n        throw new Error(\"Expected template literal\");\n      }\n      const literal = this.stream.next().value;\n      if (literal) {\n        parts.push(new LiteralExpression(literal));\n      }\n      const next = this.stream.peek();\n      if (!next || next.type !== TokenType.Dollar) {\n        break;\n      }\n      this.stream.next();\n      this.stream.expect(TokenType.LBrace);\n      this.stream.skipWhitespace();\n      const expr = this.parseExpression();\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.RBrace);\n      parts.push(expr);\n    }\n    return new TemplateExpression(parts);\n  }\n\n  private parseObjectExpression(): ExpressionNode {\n    this.stream.expect(TokenType.LBrace);\n    const entries: ObjectEntry[] = [];\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated object literal\");\n      }\n      if (next.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n\n      let value: ExpressionNode | undefined;\n      let entry: ObjectEntry | undefined;\n      if (next.type === TokenType.Ellipsis) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        entry = { spread: this.parseExpression() };\n      } else if (next.type === TokenType.LBracket) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const keyExpr = this.parseExpression();\n        this.stream.skipWhitespace();\n        this.stream.expect(TokenType.RBracket);\n        this.stream.skipWhitespace();\n        this.stream.expect(TokenType.Colon);\n        this.stream.skipWhitespace();\n        value = this.parseExpression();\n        entry = { keyExpr, value, computed: true };\n      } else if (next.type === TokenType.Identifier) {\n        const name = this.stream.next().value;\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.Colon) {\n          this.stream.next();\n          this.stream.skipWhitespace();\n          value = this.parseExpression();\n        } else {\n          value = new IdentifierExpression(name);\n        }\n        entry = { key: name, value };\n      } else if (next.type === TokenType.String) {\n        const key = this.stream.next().value;\n        this.stream.skipWhitespace();\n        this.stream.expect(TokenType.Colon);\n        this.stream.skipWhitespace();\n        value = this.parseExpression();\n        entry = { key, value };\n      } else {\n        throw new Error(`Unexpected token in object literal: ${next.type}`);\n      }\n\n      if (!entry) {\n        throw new Error(\"Invalid object literal entry\");\n      }\n      entries.push(entry);\n\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.Comma) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.RBrace) {\n          this.stream.next();\n          break;\n        }\n        continue;\n      }\n      if (this.stream.peek()?.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n      throw new Error(\"Expected ',' or '}' in object literal\");\n    }\n    return new ObjectExpression(entries);\n  }\n\n  private consumeStatementTerminator(): void {\n    this.stream.skipWhitespace();\n    const next = this.stream.peek();\n    if (next?.type === TokenType.Semicolon) {\n      this.stream.next();\n      return;\n    }\n    if (this.allowImplicitSemicolon && next?.type === TokenType.RBrace) {\n      return;\n    }\n    this.stream.expect(TokenType.Semicolon);\n  }\n\n  private parseFunctionBlockWithAwait(allowAwait: boolean): BlockNode {\n    this.stream.expect(TokenType.LBrace);\n    const statements = [];\n    this.awaitStack.push(allowAwait);\n    this.functionDepth += 1;\n    try {\n      while (true) {\n        this.stream.skipWhitespace();\n        const next = this.stream.peek();\n        if (!next) {\n          throw new Error(\"Unterminated function block\");\n        }\n        if (next.type === TokenType.RBrace) {\n          this.stream.next();\n          break;\n        }\n        statements.push(this.parseStatement({ allowBlocks: true, allowReturn: true }));\n      }\n    } finally {\n      this.functionDepth -= 1;\n      this.awaitStack.pop();\n    }\n    return new BlockNode(statements);\n  }\n\n  private isAsyncToken(token?: Token | null): boolean {\n    return token?.type === TokenType.Identifier && token.value === \"async\";\n  }\n\n  private isAwaitAllowed(): boolean {\n    if (this.awaitStack.length === 0) {\n      return false;\n    }\n    return this.awaitStack[this.awaitStack.length - 1] === true;\n  }\n\n  private parseArrowExpressionBody(allowAwait: boolean): BlockNode {\n    this.awaitStack.push(allowAwait);\n    try {\n      const expression = this.parseExpression();\n      return new BlockNode([new ReturnNode(expression)]);\n    } finally {\n      this.awaitStack.pop();\n    }\n  }\n\n  private parseAssignmentTarget(): AssignmentTarget {\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected assignment target\");\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier);\n      return new DirectiveExpression(kind, name.value);\n    }\n\n    if (token.type === TokenType.LBracket) {\n      return this.parseArrayPattern();\n    }\n\n    if (token.type === TokenType.LBrace) {\n      return this.parseObjectPattern();\n    }\n\n    if (token.type === TokenType.Identifier) {\n      const expr = this.parseCallExpression();\n      if (expr instanceof CallExpression) {\n        throw new Error(\"Invalid assignment target CallExpression\");\n      }\n      if (\n        expr instanceof IdentifierExpression\n        || expr instanceof MemberExpression\n        || expr instanceof IndexExpression\n        || expr instanceof ElementDirectiveExpression\n      ) {\n        return expr;\n      }\n      throw new Error(\"Invalid assignment target\");\n    }\n\n    if (token.type === TokenType.Hash) {\n      const expr = this.parseCallExpression();\n      if (expr instanceof ElementDirectiveExpression) {\n        return expr;\n      }\n      throw new Error(\"Invalid assignment target\");\n    }\n\n    throw new Error(`Invalid assignment target ${token.type}`);\n  }\n\n  private parseArrayPattern(): ArrayPattern {\n    this.stream.expect(TokenType.LBracket);\n    const elements: (IdentifierExpression | ArrayPattern | ObjectPattern | RestElement | null)[] = [];\n    let sawRest = false;\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated array pattern\");\n      }\n      if (next.type === TokenType.RBracket) {\n        this.stream.next();\n        break;\n      }\n      if (next.type === TokenType.Comma) {\n        this.stream.next();\n        elements.push(null);\n        continue;\n      }\n      if (next.type === TokenType.Ellipsis) {\n        if (sawRest) {\n          throw new Error(\"Array patterns can only include one rest element\");\n        }\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const name = this.stream.expect(TokenType.Identifier);\n        elements.push(new RestElement(new IdentifierExpression(name.value)));\n        sawRest = true;\n      } else if (next.type === TokenType.LBracket) {\n        elements.push(this.parseArrayPattern());\n      } else if (next.type === TokenType.LBrace) {\n        elements.push(this.parseObjectPattern());\n      } else if (next.type === TokenType.Identifier) {\n        elements.push(new IdentifierExpression(this.parseIdentifierPath()));\n      } else {\n        throw new Error(`Unexpected token in array pattern: ${next.type}`);\n      }\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.Comma) {\n        this.stream.next();\n        continue;\n      }\n      if (this.stream.peek()?.type === TokenType.RBracket) {\n        this.stream.next();\n        break;\n      }\n      throw new Error(\"Expected ',' or ']' in array pattern\");\n    }\n    if (sawRest) {\n      const last = elements[elements.length - 1];\n      if (!(last instanceof RestElement)) {\n        throw new Error(\"Rest element must be last in array pattern\");\n      }\n    }\n    return new ArrayPattern(elements);\n  }\n\n  private parseObjectPattern(): ObjectPattern {\n    this.stream.expect(TokenType.LBrace);\n    const entries: { key: string; target: IdentifierExpression | ArrayPattern | ObjectPattern }[] = [];\n    let rest: IdentifierExpression | undefined;\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated object pattern\");\n      }\n      if (next.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n      if (next.type === TokenType.Ellipsis) {\n        if (rest) {\n          throw new Error(\"Object patterns can only include one rest element\");\n        }\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const name = this.stream.expect(TokenType.Identifier);\n        rest = new IdentifierExpression(name.value);\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.Comma) {\n          this.stream.next();\n          this.stream.skipWhitespace();\n        }\n        if (this.stream.peek()?.type !== TokenType.RBrace) {\n          throw new Error(\"Rest element must be last in object pattern\");\n        }\n        this.stream.next();\n        break;\n      } else if (next.type === TokenType.Identifier || next.type === TokenType.String) {\n        const keyToken = this.stream.next();\n        const key = keyToken.value;\n        this.stream.skipWhitespace();\n        let target: IdentifierExpression | ArrayPattern | ObjectPattern;\n        if (this.stream.peek()?.type === TokenType.Colon) {\n          this.stream.next();\n          this.stream.skipWhitespace();\n          const valueToken = this.stream.peek();\n          if (!valueToken) {\n            throw new Error(\"Expected object pattern target\");\n          }\n          if (valueToken.type === TokenType.LBracket) {\n            target = this.parseArrayPattern();\n          } else if (valueToken.type === TokenType.LBrace) {\n            target = this.parseObjectPattern();\n          } else if (valueToken.type === TokenType.Identifier) {\n            target = new IdentifierExpression(this.parseIdentifierPath());\n          } else {\n            throw new Error(`Unexpected token in object pattern: ${valueToken.type}`);\n          }\n        } else {\n          target = new IdentifierExpression(key);\n        }\n        entries.push({ key, target });\n      } else {\n        throw new Error(`Unexpected token in object pattern: ${next.type}`);\n      }\n\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.Comma) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.RBrace) {\n          this.stream.next();\n          break;\n        }\n        continue;\n      }\n      if (this.stream.peek()?.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n      throw new Error(\"Expected ',' or '}' in object pattern\");\n    }\n    const patternEntries = rest ? [...entries, { rest }] : entries;\n    if (rest && entries.length === 0) {\n      return new ObjectPattern([{ rest }]);\n    }\n    return new ObjectPattern(patternEntries);\n  }\n\n  private parseDeclaration(): DeclarationNode {\n    const target = this.parseDeclarationTarget();\n    this.stream.skipWhitespace();\n    const operator = this.parseDeclarationOperator();\n    this.stream.skipWhitespace();\n    const value = this.parseExpression();\n    const { flags, flagArgs } = this.parseFlags(this.customFlags, \"flag\");\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Semicolon);\n    return new DeclarationNode(target, operator, value, flags, flagArgs);\n  }\n\n  private parseDeclarationTarget(): DeclarationTarget {\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected declaration target\");\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier);\n      return new DirectiveExpression(kind, name.value);\n    }\n\n    if (token.type === TokenType.Identifier) {\n      return new IdentifierExpression(this.stream.next().value);\n    }\n\n    throw new Error(`Invalid declaration target ${token.type}`);\n  }\n\n  private parseDeclarationOperator(): \":\" | \":=\" | \":<\" | \":>\" {\n    this.stream.expect(TokenType.Colon);\n    const next = this.stream.peek();\n    if (!next) {\n      return \":\";\n    }\n    if (next.type === TokenType.Equals) {\n      this.stream.next();\n      return \":=\";\n    }\n    if (next.type === TokenType.Less) {\n      this.stream.next();\n      return \":<\";\n    }\n    if (next.type === TokenType.Greater) {\n      this.stream.next();\n      return \":>\";\n    }\n    return \":\";\n  }\n\n  private parseFlags(\n    allowed: Set<string> | null,\n    errorLabel: string\n  ): { flags: DeclarationFlags; flagArgs: DeclarationFlagArgs } {\n    const flags: DeclarationFlags = {};\n    const flagArgs: DeclarationFlagArgs = {};\n\n    while (true) {\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type !== TokenType.Bang) {\n        break;\n      }\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier).value;\n      if (allowed && !allowed.has(name)) {\n        throw new Error(`Unknown ${errorLabel} ${name}`);\n      }\n      (flags as Record<string, boolean>)[name] = true;\n      const customArg = this.parseCustomFlagArg();\n      if (customArg !== undefined) {\n        (flagArgs as Record<string, any>)[name] = customArg;\n      }\n    }\n\n    return { flags, flagArgs };\n  }\n\n  private parseCustomFlagArg(): any {\n    if (this.stream.peek()?.type !== TokenType.LParen) {\n      return undefined;\n    }\n    this.stream.next();\n    this.stream.skipWhitespace();\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Unterminated flag arguments\");\n    }\n    const value = this.parseCustomFlagLiteral();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.RParen);\n    return value;\n  }\n\n  private parseCustomFlagLiteral(): any {\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Unterminated flag arguments\");\n    }\n    if (token.type === TokenType.Number) {\n      return Number(this.stream.next().value);\n    }\n    if (token.type === TokenType.String) {\n      return this.stream.next().value;\n    }\n    if (token.type === TokenType.Boolean) {\n      return this.stream.next().value === \"true\";\n    }\n    if (token.type === TokenType.Identifier) {\n      return this.stream.next().value;\n    }\n    if (token.type === TokenType.LBracket) {\n      return this.parseCustomFlagArray();\n    }\n    if (token.type === TokenType.LBrace) {\n      return this.parseCustomFlagObject();\n    }\n    throw new Error(`Unsupported flag argument ${token.type}`);\n  }\n\n  private parseCustomFlagArray(): any[] {\n    this.stream.expect(TokenType.LBracket);\n    const items: any[] = [];\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated flag array\");\n      }\n      if (next.type === TokenType.RBracket) {\n        this.stream.next();\n        break;\n      }\n      items.push(this.parseCustomFlagLiteral());\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.Comma) {\n        this.stream.next();\n      }\n    }\n    return items;\n  }\n\n  private parseCustomFlagObject(): Record<string, any> {\n    this.stream.expect(TokenType.LBrace);\n    const obj: Record<string, any> = {};\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated flag object\");\n      }\n      if (next.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n      let key: string;\n      if (next.type === TokenType.Identifier || next.type === TokenType.String) {\n        key = this.stream.next().value;\n      } else {\n        throw new Error(`Unsupported flag object key ${next.type}`);\n      }\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Colon);\n      this.stream.skipWhitespace();\n      obj[key] = this.parseCustomFlagLiteral();\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.Comma) {\n        this.stream.next();\n      }\n    }\n    return obj;\n  }\n\n  private isDeclarationStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first) {\n      return false;\n    }\n\n    if (first.type === TokenType.Identifier) {\n      const second = this.stream.peekNonWhitespace(1);\n      return second?.type === TokenType.Colon;\n    }\n\n    if (first.type === TokenType.At || first.type === TokenType.Dollar) {\n      const second = this.stream.peekNonWhitespace(1);\n      const third = this.stream.peekNonWhitespace(2);\n      return second?.type === TokenType.Identifier && third?.type === TokenType.Colon;\n    }\n\n    return false;\n  }\n\n  private isAssignmentStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first) {\n      return false;\n    }\n\n    if (first.type === TokenType.Identifier) {\n      let index = 1;\n      while (true) {\n        const token = this.stream.peekNonWhitespace(index);\n        if (!token) {\n          return false;\n        }\n        if (\n          token.type === TokenType.Dot &&\n          this.stream.peekNonWhitespace(index + 1)?.type === TokenType.Identifier\n        ) {\n          index += 2;\n          continue;\n        }\n        if (token.type === TokenType.LBracket) {\n          const indexAfter = this.stream.indexAfterDelimited(TokenType.LBracket, TokenType.RBracket, index);\n          if (indexAfter === null) {\n            return false;\n          }\n          index = indexAfter;\n          continue;\n        }\n        break;\n      }\n      return this.isAssignmentOperatorStart(index);\n    }\n\n    if (first.type === TokenType.At || first.type === TokenType.Dollar) {\n      const second = this.stream.peekNonWhitespace(1);\n      return second?.type === TokenType.Identifier && this.isAssignmentOperatorStart(2);\n    }\n\n    if (first.type === TokenType.Hash) {\n      let index = 1;\n      if (this.stream.peekNonWhitespace(index)?.type !== TokenType.Identifier) {\n        return false;\n      }\n      index += 1;\n      while (true) {\n        const token = this.stream.peekNonWhitespace(index);\n        if (!token) {\n          return false;\n        }\n        if (token.type === TokenType.Dot) {\n          const next = this.stream.peekNonWhitespace(index + 1);\n          if (next?.type === TokenType.Identifier) {\n            index += 2;\n            continue;\n          }\n          if (next?.type === TokenType.At || next?.type === TokenType.Dollar) {\n            const afterDirective = this.stream.peekNonWhitespace(index + 2);\n            if (afterDirective?.type !== TokenType.Identifier) {\n              return false;\n            }\n            index += 3;\n            continue;\n          }\n          return false;\n        }\n        if (token.type === TokenType.LBracket) {\n          const indexAfter = this.stream.indexAfterDelimited(TokenType.LBracket, TokenType.RBracket, index);\n          if (indexAfter === null) {\n            return false;\n          }\n          index = indexAfter;\n          continue;\n        }\n        break;\n      }\n      return this.isAssignmentOperatorStart(index);\n    }\n\n    if (first.type === TokenType.LBrace || first.type === TokenType.LBracket) {\n      const stack: TokenType[] = [];\n      let index = 0;\n      while (true) {\n        const token = this.stream.peekNonWhitespace(index);\n        if (!token) {\n          return false;\n        }\n        if (token.type === TokenType.LBrace || token.type === TokenType.LBracket) {\n          stack.push(token.type);\n        } else if (token.type === TokenType.RBrace || token.type === TokenType.RBracket) {\n          stack.pop();\n          if (stack.length === 0) {\n            return this.isAssignmentOperatorStart(index + 1);\n          }\n        }\n        index += 1;\n      }\n    }\n\n    return false;\n  }\n\n  private isAssignmentOperatorStart(index: number): boolean {\n    const token = this.stream.peekNonWhitespace(index);\n    if (!token) {\n      return false;\n    }\n    if (token.type === TokenType.Equals) {\n      return true;\n    }\n    if (token.type === TokenType.Tilde) {\n      const next = this.stream.peekNonWhitespace(index + 1);\n      return next?.type === TokenType.Equals;\n    }\n    if (token.type === TokenType.Plus ||\n        token.type === TokenType.Minus ||\n        token.type === TokenType.Star ||\n        token.type === TokenType.Slash) {\n      const next = this.stream.peekNonWhitespace(index + 1);\n      return next?.type === TokenType.Equals;\n    }\n    return false;\n  }\n\n  private isExpressionStatementStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first) {\n      return false;\n    }\n    if (first.type === TokenType.Identifier) {\n      return true;\n    }\n    return (\n      first.type === TokenType.Number\n      || first.type === TokenType.String\n      || first.type === TokenType.Boolean\n      || first.type === TokenType.Null\n      || first.type === TokenType.LParen\n      || first.type === TokenType.LBracket\n      || first.type === TokenType.LBrace\n      || first.type === TokenType.At\n      || first.type === TokenType.Dollar\n      || first.type === TokenType.Hash\n      || first.type === TokenType.Question\n      || first.type === TokenType.Bang\n      || first.type === TokenType.Minus\n    );\n  }\n\n  private isFunctionDeclarationStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first) {\n      return false;\n    }\n    let index = 0;\n    if (this.isAsyncToken(first)) {\n      const next = this.stream.peekNonWhitespace(1);\n      if (!next || next.type !== TokenType.Identifier) {\n        return false;\n      }\n      index = 1;\n    } else if (first.type !== TokenType.Identifier) {\n      return false;\n    }\n    index += 1;\n    if (this.stream.peekNonWhitespace(index)?.type !== TokenType.LParen) {\n      return false;\n    }\n    const indexAfterParams = this.stream.indexAfterDelimited(TokenType.LParen, TokenType.RParen, index);\n    if (indexAfterParams === null) {\n      return false;\n    }\n    return this.stream.peekNonWhitespace(indexAfterParams)?.type === TokenType.LBrace;\n  }\n\n  private isArrowFunctionStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first || first.type !== TokenType.LParen) {\n      return false;\n    }\n    const indexAfterParams = this.stream.indexAfterDelimited(TokenType.LParen, TokenType.RParen, 0);\n    if (indexAfterParams === null) {\n      return false;\n    }\n    return this.stream.peekNonWhitespace(indexAfterParams)?.type === TokenType.Arrow;\n  }\n\n  private isAsyncArrowFunctionStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!this.isAsyncToken(first)) {\n      return false;\n    }\n    if (this.stream.peekNonWhitespace(1)?.type !== TokenType.LParen) {\n      return false;\n    }\n    const indexAfterParams = this.stream.indexAfterDelimited(TokenType.LParen, TokenType.RParen, 1);\n    if (indexAfterParams === null) {\n      return false;\n    }\n    return this.stream.peekNonWhitespace(indexAfterParams)?.type === TokenType.Arrow;\n  }\n\n  private isFunctionExpressionAssignmentStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first || first.type !== TokenType.Identifier) {\n      return false;\n    }\n    if (this.stream.peekNonWhitespace(1)?.type !== TokenType.Equals) {\n      return false;\n    }\n    let index = 2;\n    if (this.isAsyncToken(this.stream.peekNonWhitespace(index))) {\n      index += 1;\n    }\n    if (this.stream.peekNonWhitespace(index)?.type !== TokenType.LParen) {\n      return false;\n    }\n    const indexAfterParams = this.stream.indexAfterDelimited(TokenType.LParen, TokenType.RParen, index);\n    if (indexAfterParams === null) {\n      return false;\n    }\n    return this.stream.peekNonWhitespace(indexAfterParams)?.type === TokenType.Arrow;\n  }\n\n  private parseExpressionStatement(): ExpressionNode {\n    const expr = this.parseExpression();\n    this.consumeStatementTerminator();\n    return expr;\n  }\n\n  private parseIfBlock(): IfNode {\n    this.stream.expect(TokenType.If);\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    this.stream.skipWhitespace();\n    const test = this.parseExpression();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.RParen);\n    const consequent = this.parseConditionalBody();\n    this.stream.skipWhitespace();\n    let alternate: BlockNode | undefined;\n    if (this.stream.peek()?.type === TokenType.Else) {\n      this.stream.next();\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.If) {\n        const nested = this.parseIfBlock();\n        alternate = new BlockNode([nested]);\n      } else {\n        alternate = this.parseConditionalBody();\n      }\n    }\n    return new IfNode(test, consequent, alternate);\n  }\n\n  private parseConditionalBody(): BlockNode {\n    this.stream.skipWhitespace();\n    if (this.stream.peek()?.type === TokenType.LBrace) {\n      return this.parseBlock({ allowDeclarations: false });\n    }\n    const statement = this.parseStatement({ allowBlocks: false, allowReturn: this.functionDepth > 0 });\n    return new BlockNode([statement]);\n  }\n\n  private parseWhileBlock(): WhileNode {\n    this.stream.expect(TokenType.While);\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    this.stream.skipWhitespace();\n    const test = this.parseExpression();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.RParen);\n    const body = this.parseBlock({ allowDeclarations: false });\n    return new WhileNode(test, body);\n  }\n\n  private parseForBlock(): ForNode | ForEachNode {\n    this.stream.expect(TokenType.For);\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    this.stream.skipWhitespace();\n    const eachKind = this.detectForEachKind();\n    if (eachKind) {\n      const target = this.parseForEachTarget();\n      this.stream.skipWhitespace();\n      const keyword = this.stream.expect(TokenType.Identifier);\n      if (keyword.value !== eachKind) {\n        throw new Error(`Expected '${eachKind}' but got '${keyword.value}'`);\n      }\n      this.stream.skipWhitespace();\n      const iterable = this.parseExpression();\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.RParen);\n      const body = this.parseBlock({ allowDeclarations: false });\n      return new ForEachNode(target, iterable, eachKind, body);\n    }\n    let init: CFSNode | undefined;\n    if (this.stream.peek()?.type !== TokenType.Semicolon) {\n      init = this.parseForClause();\n    }\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Semicolon);\n    this.stream.skipWhitespace();\n    let test: ExpressionNode | undefined;\n    if (this.stream.peek()?.type !== TokenType.Semicolon) {\n      test = this.parseExpression();\n    }\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Semicolon);\n    this.stream.skipWhitespace();\n    let update: CFSNode | undefined;\n    if (this.stream.peek()?.type !== TokenType.RParen) {\n      update = this.parseForClause();\n    }\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.RParen);\n    const body = this.parseBlock({ allowDeclarations: false });\n    return new ForNode(init, test, update, body);\n  }\n\n  private detectForEachKind(): \"in\" | \"of\" | null {\n    let offset = 0;\n    let depth = 0;\n    while (true) {\n      const token = this.stream.peekNonWhitespace(offset);\n      if (!token) {\n        return null;\n      }\n      if (token.type === TokenType.LParen || token.type === TokenType.LBracket || token.type === TokenType.LBrace) {\n        depth += 1;\n      } else if (\n        token.type === TokenType.RParen\n        || token.type === TokenType.RBracket\n        || token.type === TokenType.RBrace\n      ) {\n        if (depth === 0) {\n          return null;\n        }\n        depth -= 1;\n      }\n      if (depth === 0) {\n        if (token.type === TokenType.Semicolon) {\n          return null;\n        }\n        if (\n          token.type === TokenType.Identifier\n          && (token.value === \"in\" || token.value === \"of\")\n        ) {\n          return token.value;\n        }\n      }\n      offset += 1;\n    }\n  }\n\n  private parseForEachTarget(): IdentifierExpression {\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected for-each target\");\n    }\n    if (token.type !== TokenType.Identifier) {\n      throw new Error(\"for-in/of target must be an identifier\");\n    }\n    return new IdentifierExpression(this.stream.next().value);\n  }\n\n  private parseForClause(): CFSNode {\n    if (this.isAssignmentStart()) {\n      return this.parseAssignmentExpression();\n    }\n    return this.parseExpression();\n  }\n\n  private parseAssignmentExpression(): AssignmentNode {\n    const target = this.parseAssignmentTarget();\n    this.stream.skipWhitespace();\n    const operator = this.parseAssignmentOperator();\n    this.stream.skipWhitespace();\n    const value = this.parseExpression();\n    return new AssignmentNode(target, value, operator);\n  }\n\n  private parseAssignmentOperator(): \"=\" | \"+=\" | \"-=\" | \"*=\" | \"/=\" | \"~=\" {\n    const next = this.stream.peek();\n    if (!next) {\n      throw new Error(\"Expected assignment operator\");\n    }\n    if (next.type === TokenType.Equals) {\n      this.stream.next();\n      return \"=\";\n    }\n    if (next.type === TokenType.Tilde) {\n      this.stream.next();\n      this.stream.expect(TokenType.Equals);\n      return \"~=\";\n    }\n    if (next.type === TokenType.Plus ||\n        next.type === TokenType.Minus ||\n        next.type === TokenType.Star ||\n        next.type === TokenType.Slash) {\n      const op = this.stream.next();\n      this.stream.expect(TokenType.Equals);\n      if (op.type === TokenType.Plus) {\n        return \"+=\";\n      }\n      if (op.type === TokenType.Minus) {\n        return \"-=\";\n      }\n      if (op.type === TokenType.Star) {\n        return \"*=\";\n      }\n      return \"/=\";\n    }\n    throw new Error(\"Expected assignment operator\");\n  }\n\n  private parseTryBlock(): TryNode {\n    this.stream.expect(TokenType.Try);\n    const body = this.parseBlock({ allowDeclarations: false });\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Catch);\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    this.stream.skipWhitespace();\n    const errorName = this.stream.expect(TokenType.Identifier).value;\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.RParen);\n    const handler = this.parseBlock({ allowDeclarations: false });\n    return new TryNode(body, errorName, handler);\n  }\n\n  private parseConstructBlock(): BlockNode {\n    this.stream.expect(TokenType.Construct);\n    const body = this.parseBlock({ allowDeclarations: false });\n    body.type = \"Construct\";\n    return body;\n  }\n\n  private parseDestructBlock(): BlockNode {\n    this.stream.expect(TokenType.Destruct);\n    const body = this.parseBlock({ allowDeclarations: false });\n    body.type = \"Destruct\";\n    return body;\n  }\n\n  private parseQueryExpression(): QueryExpression {\n    this.stream.expect(TokenType.Question);\n    let direction: \"self\" | \"descendant\" | \"ancestor\" = \"self\";\n\n    if (this.stream.peek()?.type === TokenType.Greater) {\n      this.stream.next();\n      direction = \"descendant\";\n    } else if (this.stream.peek()?.type === TokenType.Less) {\n      this.stream.next();\n      direction = \"ancestor\";\n    }\n\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    const selector = this.readSelectorUntil(TokenType.RParen);\n    return new QueryExpression(direction, selector);\n  }\n\n  private parseFunctionDeclaration(): FunctionDeclarationNode {\n    let isAsync = false;\n    const first = this.stream.peekNonWhitespace(0);\n    if (this.isAsyncToken(first)) {\n      this.stream.next();\n      this.stream.skipWhitespace();\n      isAsync = true;\n    }\n    const name = this.stream.expect(TokenType.Identifier).value;\n    this.stream.skipWhitespace();\n    const params = this.parseFunctionParams();\n    this.stream.skipWhitespace();\n    const body = this.parseFunctionBlockWithAwait(isAsync);\n    return new FunctionDeclarationNode(name, params, body, isAsync);\n  }\n\n  private parseReturnStatement(): ReturnNode {\n    this.stream.expect(TokenType.Return);\n    this.stream.skipWhitespace();\n    if (this.stream.peek()?.type === TokenType.Semicolon) {\n      this.stream.next();\n      return new ReturnNode();\n    }\n    const value = this.parseExpression();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Semicolon);\n    return new ReturnNode(value);\n  }\n\n  private parseAssertStatement(): AssertNode {\n    this.stream.expect(TokenType.Assert);\n    this.stream.skipWhitespace();\n    const test = this.parseExpression();\n    this.consumeStatementTerminator();\n    return new AssertNode(test);\n  }\n\n  private parseBreakStatement(): BreakNode {\n    this.stream.expect(TokenType.Break);\n    this.consumeStatementTerminator();\n    return new BreakNode();\n  }\n\n  private parseContinueStatement(): ContinueNode {\n    this.stream.expect(TokenType.Continue);\n    this.consumeStatementTerminator();\n    return new ContinueNode();\n  }\n\n  private parseArrowFunctionExpression(isAsync = false): FunctionExpression {\n    const params = this.parseFunctionParams();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Arrow);\n    this.stream.skipWhitespace();\n    if (this.stream.peek()?.type === TokenType.LBrace) {\n      const body = this.parseFunctionBlockWithAwait(isAsync);\n      return new FunctionExpression(params, body, isAsync);\n    }\n    const body = this.parseArrowExpressionBody(isAsync);\n    return new FunctionExpression(params, body, isAsync);\n  }\n\n  private parseFunctionParams(): FunctionParam[] {\n    this.stream.expect(TokenType.LParen);\n    const params: FunctionParam[] = [];\n    let sawRest = false;\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated function parameters\");\n      }\n      if (next.type === TokenType.RParen) {\n        this.stream.next();\n        break;\n      }\n      if (next.type === TokenType.Ellipsis) {\n        if (sawRest) {\n          throw new Error(\"Function parameters can only include one rest parameter\");\n        }\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const name = this.stream.expect(TokenType.Identifier).value;\n        params.push({ name, rest: true });\n        sawRest = true;\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.Comma) {\n          throw new Error(\"Rest parameter must be last in function parameters\");\n        }\n        this.stream.expect(TokenType.RParen);\n        break;\n      }\n      const name = this.stream.expect(TokenType.Identifier).value;\n      this.stream.skipWhitespace();\n      let defaultValue: ExpressionNode | undefined;\n      if (this.stream.peek()?.type === TokenType.Equals) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        defaultValue = this.parseExpression();\n      }\n      params.push(defaultValue ? { name, defaultValue } : { name });\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.Comma) {\n        this.stream.next();\n        continue;\n      }\n      if (this.stream.peek()?.type === TokenType.RParen) {\n        this.stream.next();\n        break;\n      }\n      throw new Error(\"Expected ',' or ')' in function parameters\");\n    }\n    return params;\n  }\n\n  private readSelectorUntil(terminator: TokenType): string {\n    let selectorText = \"\";\n    let sawNonWhitespace = false;\n\n    while (true) {\n      const token = this.stream.peek();\n      if (!token) {\n        throw new Error(\"Unterminated selector\");\n      }\n      if (token.type === terminator) {\n        this.stream.next();\n        break;\n      }\n\n      if (token.type === TokenType.Whitespace) {\n        this.stream.next();\n        if (sawNonWhitespace && selectorText[selectorText.length - 1] !== \" \") {\n          selectorText += \" \";\n        }\n        continue;\n      }\n\n      sawNonWhitespace = true;\n      selectorText += this.stream.next().value;\n    }\n\n    return selectorText.trim();\n  }\n\n  private parseIdentifierPath(): string {\n    let value = this.stream.expect(TokenType.Identifier).value;\n    while (this.stream.peek()?.type === TokenType.Dot) {\n      this.stream.next();\n      const part = this.stream.expect(TokenType.Identifier).value;\n      value = `${value}.${part}`;\n    }\n    return value;\n  }\n}\n","export class Scope {\n  private data = new Map<string, any>();\n  private root: Scope;\n  private listeners = new Map<string, Set<() => void>>();\n  private anyListeners = new Set<() => void>();\n  public isEachItem = false;\n\n  constructor(public readonly parent?: Scope) {\n    this.root = parent ? parent.root : this;\n  }\n\n  createChild(): Scope {\n    return new Scope(this);\n  }\n\n  get(key: string): any {\n    return this.getPath(key);\n  }\n\n  set(key: string, value: any): void {\n    this.setPath(key, value);\n  }\n\n  hasKey(path: string): boolean {\n    const parts = path.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return false;\n    }\n    return this.data.has(root);\n  }\n\n  getPath(path: string): any {\n    const explicit = path.startsWith(\"parent.\") || path.startsWith(\"root.\") || path.startsWith(\"self.\");\n    const { targetScope, targetPath } = this.resolveScope(path);\n    if (!targetScope || !targetPath) {\n      return undefined;\n    }\n\n    const localValue = this.getLocalPathValue(targetScope, targetPath);\n    if (explicit || localValue !== undefined) {\n      return localValue;\n    }\n    let cursor = targetScope.parent;\n    while (cursor) {\n      const value = this.getLocalPathValue(cursor, targetPath);\n      if (value !== undefined) {\n        return value;\n      }\n      cursor = cursor.parent;\n    }\n    return undefined;\n  }\n\n  setPath(path: string, value: any): void {\n    const explicit = path.startsWith(\"parent.\") || path.startsWith(\"root.\") || path.startsWith(\"self.\");\n    const { targetScope, targetPath } = this.resolveScope(path);\n    if (!targetScope || !targetPath) {\n      return;\n    }\n\n    const scopeForSet = explicit ? targetScope : this.findNearestScopeWithKey(targetScope, targetPath) ?? targetScope;\n    const parts = targetPath.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return;\n    }\n    if (parts.length === 1) {\n      scopeForSet.data.set(root, value);\n      scopeForSet.emitChange(targetPath);\n      return;\n    }\n    let obj = scopeForSet.data.get(root);\n    if (obj == null || typeof obj !== \"object\") {\n      obj = {};\n      scopeForSet.data.set(root, obj);\n    }\n    let cursor = obj;\n    for (let i = 1; i < parts.length - 1; i += 1) {\n      const key = parts[i];\n      if (!key) {\n        return;\n      }\n      if (cursor[key] == null || typeof cursor[key] !== \"object\") {\n        cursor[key] = {};\n      }\n      cursor = cursor[key];\n    }\n    const lastKey = parts[parts.length - 1];\n    if (!lastKey) {\n      return;\n    }\n    cursor[lastKey] = value;\n    scopeForSet.emitChange(targetPath);\n  }\n\n  on(path: string, handler: () => void): void {\n    const key = path.trim();\n    if (!key) {\n      return;\n    }\n    const set = this.listeners.get(key) ?? new Set<() => void>();\n    set.add(handler);\n    this.listeners.set(key, set);\n  }\n\n  off(path: string, handler: () => void): void {\n    const key = path.trim();\n    const set = this.listeners.get(key);\n    if (!set) {\n      return;\n    }\n    set.delete(handler);\n    if (set.size === 0) {\n      this.listeners.delete(key);\n    }\n  }\n\n  onAny(handler: () => void): void {\n    this.anyListeners.add(handler);\n  }\n\n  offAny(handler: () => void): void {\n    this.anyListeners.delete(handler);\n  }\n\n  private emitChange(path: string): void {\n    const key = path.trim();\n    if (!key) {\n      return;\n    }\n    this.listeners.get(key)?.forEach((fn) => fn());\n    const rootKey = key.split(\".\")[0];\n    if (rootKey && rootKey !== key) {\n      this.listeners.get(rootKey)?.forEach((fn) => fn());\n    }\n    this.anyListeners.forEach((fn) => fn());\n  }\n\n  private resolveScope(path: string): { targetScope: Scope | undefined; targetPath: string | undefined } {\n    let targetScope: Scope | undefined = this;\n    let targetPath = path;\n    while (targetPath.startsWith(\"parent.\")) {\n      targetScope = targetScope?.parent;\n      targetPath = targetPath.slice(\"parent.\".length);\n    }\n    if (targetPath.startsWith(\"root.\")) {\n      targetScope = targetScope?.root;\n      targetPath = targetPath.slice(\"root.\".length);\n    }\n    while (targetPath.startsWith(\"self.\")) {\n      targetScope = targetScope ?? this;\n      targetPath = targetPath.slice(\"self.\".length);\n    }\n    return { targetScope, targetPath };\n  }\n\n  private getLocalPathValue(scope: Scope, path: string): any {\n    const parts = path.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return undefined;\n    }\n    let value = scope.data.get(root);\n    for (let i = 1; i < parts.length; i += 1) {\n      if (value == null) {\n        return undefined;\n      }\n      const key = parts[i];\n      if (!key) {\n        return undefined;\n      }\n      value = value[key];\n    }\n    return value;\n  }\n\n  private findNearestScopeWithKey(start: Scope, path: string): Scope | undefined {\n    const root = path.split(\".\")[0];\n    if (!root) {\n      return undefined;\n    }\n    let cursor: Scope | undefined = start;\n    while (cursor) {\n      if (cursor.data.has(root)) {\n        return cursor;\n      }\n      cursor = cursor.parent;\n    }\n    return undefined;\n  }\n}\n","import { Scope } from \"./scope\";\n\nexport type BindDirection = \"auto\" | \"both\" | \"from\" | \"to\";\n\nfunction getElementValue(element: Element): string {\n  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n    return element.value;\n  }\n  if (element instanceof HTMLSelectElement) {\n    return element.value;\n  }\n  return element.textContent ?? \"\";\n}\n\nfunction setElementValue(element: Element, value: string): void {\n  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n    element.value = value;\n    element.setAttribute(\"value\", value);\n    return;\n  }\n  if (element instanceof HTMLSelectElement) {\n    element.value = value;\n    return;\n  }\n  if (element instanceof HTMLElement && element.querySelector(\"*\")) {\n    return;\n  }\n  element.textContent = value;\n}\n\nexport function applyBindToScope(element: Element, expression: string, scope: Scope): void {\n  const key = expression.trim();\n  if (!key) {\n    return;\n  }\n\n  const value = getElementValue(element);\n  scope.set(key, value);\n}\n\nexport function applyBindToElement(element: Element, expression: string, scope: Scope): void {\n  const key = expression.trim();\n  if (!key) {\n    return;\n  }\n  const value = scope.get(key);\n  if (value == null) {\n    return;\n  }\n  setElementValue(element, String(value));\n}\n","import { Scope } from \"./scope\";\n\nfunction readCondition(expression: string, scope: Scope): boolean {\n  const key = expression.trim();\n  if (!key) {\n    return false;\n  }\n  return !!scope.get(key);\n}\n\nexport function applyIf(element: HTMLElement, expression: string, scope: Scope): void {\n  element.style.display = readCondition(expression, scope) ? \"\" : \"none\";\n}\n\nexport function applyShow(element: HTMLElement, expression: string, scope: Scope): void {\n  element.style.display = readCondition(expression, scope) ? \"\" : \"none\";\n}\n","import { Scope } from \"./scope\";\n\nexport function applyHtml(\n  element: HTMLElement,\n  expression: string,\n  scope: Scope\n): void {\n  const key = expression.trim();\n  if (!key) {\n    return;\n  }\n  const value = scope.get(key);\n  const html = value == null ? \"\" : String(value);\n  element.innerHTML = html;\n}\n","import { applyHtml } from \"./html\";\nimport { Scope } from \"./scope\";\n\nexport interface GetConfig {\n  url: string;\n  targetSelector?: string;\n  swap?: \"inner\" | \"outer\";\n}\n\nexport async function applyGet(\n  element: Element,\n  config: GetConfig,\n  scope: Scope,\n  onHtmlApplied?: (target: Element) => void\n): Promise<void> {\n  if (!globalThis.fetch) {\n    throw new Error(\"fetch is not available\");\n  }\n\n  const response = await globalThis.fetch(config.url);\n  if (!response || !response.ok) {\n    return;\n  }\n\n  const html = await response.text();\n  const target = resolveTarget(element, config.targetSelector);\n  if (!target) {\n    element.dispatchEvent(new CustomEvent(\"vsn:targetError\", { detail: { selector: config.targetSelector } }));\n    return;\n  }\n\n  if (config.swap === \"outer\") {\n    const wrapper = document.createElement(\"div\");\n    applyHtml(wrapper, \"__html\", { get: () => html } as unknown as Scope);\n    const replacement = wrapper.firstElementChild;\n    if (replacement && target.parentNode) {\n      target.parentNode.replaceChild(replacement, target);\n      onHtmlApplied?.(replacement);\n    }\n    return;\n  }\n\n  applyHtml(target as HTMLElement, \"__html\", { get: () => html } as unknown as Scope);\n  onHtmlApplied?.(target);\n}\n\nfunction resolveTarget(element: Element, selector?: string): Element | null {\n  if (!selector) {\n    return element;\n  }\n  return element.ownerDocument.querySelector(selector);\n}\n","type Debounced = (...args: any[]) => void;\n\nexport function debounce<T extends (...args: any[]) => void>(fn: T, waitMs: number): Debounced {\n  let timer: ReturnType<typeof setTimeout> | undefined;\n  return (...args: any[]) => {\n    if (timer) {\n      clearTimeout(timer);\n    }\n    timer = setTimeout(() => {\n      timer = undefined;\n      fn(...args);\n    }, waitMs);\n  };\n}\n","import { Scope } from \"./scope\";\nimport { applyBindToElement, applyBindToScope, BindDirection } from \"./bindings\";\nimport { applyIf, applyShow } from \"./conditionals\";\nimport { applyHtml } from \"./html\";\nimport { applyGet, GetConfig } from \"./http\";\nimport { debounce } from \"./debounce\";\nimport { Parser } from \"../parser/parser\";\nimport {\n  AssignmentNode,\n  BehaviorNode,\n  BehaviorFlags,\n  BehaviorFlagArgs,\n  BlockNode,\n  DeclarationFlags,\n  DeclarationFlagArgs,\n  DeclarationNode,\n  DirectiveExpression,\n  ExecutionContext,\n  ExpressionNode,\n  FunctionDeclarationNode,\n  FunctionParam,\n  FunctionExpression,\n  IdentifierExpression,\n  OnBlockNode,\n  UseNode\n} from \"../ast/nodes\";\n\ninterface OnConfig {\n  event: string;\n  code: string;\n  flags: DeclarationFlags;\n  flagArgs: DeclarationFlagArgs;\n}\n\ninterface BindConfig {\n  expr: string;\n  direction: BindDirection;\n  auto?: boolean;\n}\n\ninterface LifecycleConfig {\n  construct?: string;\n  destruct?: string;\n}\n\ninterface RegisteredBehavior {\n  id: number;\n  hash: string;\n  selector: string;\n  rootSelector: string;\n  parentSelector?: string;\n  specificity: number;\n  order: number;\n  construct?: BlockNode;\n  destruct?: BlockNode;\n  onBlocks: { event: string; body: BlockNode; flags: DeclarationFlags; flagArgs: DeclarationFlagArgs; args: string[] }[];\n  declarations: DeclarationNode[];\n  functions: FunctionBinding[];\n  flags: BehaviorFlags;\n  flagArgs: BehaviorFlagArgs;\n}\n\ntype FunctionBinding = {\n  name: string;\n  params: FunctionParam[];\n  body: BlockNode;\n};\n\ntype AttributeHandler = {\n  id: string;\n  match: (name: string) => boolean;\n  handle: (element: Element, name: string, value: string, scope: Scope) => boolean | void;\n};\n\ntype EachBinding = {\n  listExpr: string;\n  itemName: string;\n  indexName?: string;\n  rendered: Element[];\n};\n\ntype CachedBehavior = {\n  construct?: BlockNode;\n  destruct?: BlockNode;\n  onBlocks: { event: string; body: BlockNode; flags: DeclarationFlags; flagArgs: DeclarationFlagArgs; args: string[] }[];\n  declarations: DeclarationNode[];\n  functions: FunctionBinding[];\n};\n\ntype BehaviorListener = {\n  target: EventTarget;\n  event: string;\n  handler: (event?: Event) => void;\n  options?: AddEventListenerOptions | undefined;\n};\n\ntype FlagApplyContext = {\n  name: string;\n  args: any;\n  element: Element;\n  scope: Scope;\n  declaration: DeclarationNode;\n};\n\ntype FlagHandler = {\n  onApply?: (context: FlagApplyContext) => void;\n  transformValue?: (context: FlagApplyContext, value: any) => any;\n  onEventBind?: (context: EventFlagContext) => EventBindPatch | void;\n  onEventBefore?: (context: EventFlagContext) => boolean | void;\n  onEventAfter?: (context: EventFlagContext) => void;\n  transformEventArgs?: (context: EventFlagContext, args: any[]) => any[];\n};\n\ntype BehaviorModifierHandler = {\n  onBind?: (context: BehaviorModifierContext) => void | Promise<void>;\n  onConstruct?: (context: BehaviorModifierContext) => void | Promise<void>;\n  onDestruct?: (context: BehaviorModifierContext) => void | Promise<void>;\n  onUnbind?: (context: BehaviorModifierContext) => void | Promise<void>;\n};\n\ntype BehaviorModifierContext = {\n  name: string;\n  args: any;\n  element: Element;\n  scope: Scope;\n  rootScope: Scope | undefined;\n  behavior: RegisteredBehavior;\n  engine: Engine;\n};\n\ntype EventBindPatch = {\n  listenerTarget?: EventTarget;\n  options?: AddEventListenerOptions;\n  debounceMs?: number;\n};\n\ntype EventFlagContext = {\n  name: string;\n  args: any;\n  element: Element;\n  scope: Scope;\n  rootScope: Scope | undefined;\n  event: Event | undefined;\n  engine: Engine;\n};\n\ntype EngineOptions = {\n  diagnostics?: boolean;\n  logger?: Partial<Pick<Console, \"info\" | \"warn\">>;\n};\n\nexport class Engine {\n  private static activeEngines = new WeakMap<Document, Engine>();\n  private scopes = new WeakMap<Element, Scope>();\n  private bindBindings = new WeakMap<Element, BindConfig>();\n  private ifBindings = new WeakMap<Element, string>();\n  private showBindings = new WeakMap<Element, string>();\n  private htmlBindings = new WeakMap<Element, { expr: string }>();\n  private getBindings = new WeakMap<Element, GetConfig>();\n  private eachBindings = new WeakMap<Element, EachBinding>();\n  private lifecycleBindings = new WeakMap<Element, LifecycleConfig>();\n  private behaviorRegistry: RegisteredBehavior[] = [];\n  private behaviorRegistryHashes = new Set<string>();\n  private behaviorBindings = new WeakMap<Element, Set<number>>();\n  private behaviorListeners = new WeakMap<Element, Map<number, BehaviorListener[]>>();\n  private behaviorId = 0;\n  private codeCache = new Map<string, BlockNode>();\n  private behaviorCache = new Map<string, CachedBehavior>();\n  private observer: MutationObserver | undefined;\n  private attributeHandlers: AttributeHandler[] = [];\n  private globals: Record<string, any> = {};\n  private importantFlags = new WeakMap<Element, Set<string>>();\n  private inlineDeclarations = new WeakMap<Element, Set<string>>();\n  private flagHandlers = new Map<string, FlagHandler>();\n  private behaviorModifiers = new Map<string, BehaviorModifierHandler>();\n  private pendingAdded = new Set<Element>();\n  private pendingRemoved = new Set<Element>();\n  private pendingUpdated = new Set<Element>();\n  private observerFlush?: () => void;\n  private ignoredAdded = new WeakMap<Element, boolean>();\n  private diagnostics: boolean;\n  private logger: Partial<Pick<Console, \"info\" | \"warn\">>;\n  private pendingUses: Promise<void>[] = [];\n  private pendingAutoBindToScope: Array<{ element: Element; expr: string; scope: Scope }> = [];\n  private scopeWatchers = new WeakMap<Element, { scope: Scope; kind: \"path\" | \"any\"; key?: string; handler: () => void }[]>();\n  private executionStack: Element[] = [];\n  private groupProxyCache = new WeakMap<Scope, Record<string, any>>();\n\n  constructor(options: EngineOptions = {}) {\n    this.diagnostics = options.diagnostics ?? false;\n    this.logger = options.logger ?? console;\n    this.registerGlobal(\"console\", console);\n    this.registerFlag(\"important\");\n    this.registerFlag(\"debounce\", {\n      onEventBind: ({ args }) => ({\n        debounceMs: typeof args === \"number\" ? args : 200\n      })\n    });\n    this.registerFlag(\"prevent\", {\n      onEventBefore: ({ event }) => {\n        event?.preventDefault();\n      }\n    });\n    this.registerFlag(\"stop\", {\n      onEventBefore: ({ event }) => {\n        event?.stopPropagation();\n      }\n    });\n    this.registerFlag(\"self\", {\n      onEventBefore: ({ event, element }) => {\n        const target = event?.target;\n        if (!(target instanceof Node)) {\n          return false;\n        }\n        return target === element;\n      }\n    });\n    this.registerFlag(\"outside\", {\n      onEventBind: ({ element }) => ({ listenerTarget: element.ownerDocument }),\n      onEventBefore: ({ event, element }) => {\n        const target = event?.target;\n        if (!(target instanceof Node)) {\n          return false;\n        }\n        return !element.contains(target);\n      }\n    });\n    this.registerFlag(\"once\", {\n      onEventBind: () => ({ options: { once: true } })\n    });\n    this.registerFlag(\"passive\", {\n      onEventBind: () => ({ options: { passive: true } })\n    });\n    this.registerFlag(\"capture\", {\n      onEventBind: () => ({ options: { capture: true } })\n    });\n    this.registerFlag(\"shift\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"shift\")\n    });\n    this.registerFlag(\"ctrl\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"ctrl\")\n    });\n    this.registerFlag(\"control\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"ctrl\")\n    });\n    this.registerFlag(\"alt\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"alt\")\n    });\n    this.registerFlag(\"meta\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"meta\")\n    });\n    this.registerFlag(\"enter\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"enter\")\n    });\n    this.registerFlag(\"escape\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"escape\")\n    });\n    this.registerFlag(\"esc\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"escape\")\n    });\n    this.registerFlag(\"tab\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"tab\")\n    });\n    this.registerFlag(\"space\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"space\")\n    });\n    this.registerFlag(\"up\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"arrowup\")\n    });\n    this.registerFlag(\"down\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"arrowdown\")\n    });\n    this.registerFlag(\"left\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"arrowleft\")\n    });\n    this.registerFlag(\"right\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"arrowright\")\n    });\n    this.registerFlag(\"arrowup\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"arrowup\")\n    });\n    this.registerFlag(\"arrowdown\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"arrowdown\")\n    });\n    this.registerFlag(\"arrowleft\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"arrowleft\")\n    });\n    this.registerFlag(\"arrowright\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"arrowright\")\n    });\n    this.registerFlag(\"delete\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"delete\")\n    });\n    this.registerFlag(\"backspace\", {\n      onEventBefore: ({ event }) => this.matchesKeyFlag(event, \"backspace\")\n    });\n    this.registerGlobal(\"list\", {\n      async map(items: any[], fn: (item: any, index: number) => any) {\n        if (!Array.isArray(items) || typeof fn !== \"function\") {\n          return [];\n        }\n        const results = [];\n        for (let i = 0; i < items.length; i += 1) {\n          results.push(await fn(items[i], i));\n        }\n        return results;\n      },\n      async filter(items: any[], fn: (item: any, index: number) => any) {\n        if (!Array.isArray(items) || typeof fn !== \"function\") {\n          return [];\n        }\n        const results = [];\n        for (let i = 0; i < items.length; i += 1) {\n          if (await fn(items[i], i)) {\n            results.push(items[i]);\n          }\n        }\n        return results;\n      },\n      async reduce(items: any[], fn: (acc: any, item: any, index: number) => any, initial?: any) {\n        if (!Array.isArray(items) || typeof fn !== \"function\") {\n          return initial;\n        }\n        const hasInitial = arguments.length > 2;\n        let acc = hasInitial ? initial : items[0];\n        let start = hasInitial ? 0 : 1;\n        for (let i = start; i < items.length; i += 1) {\n          acc = await fn(acc, items[i], i);\n        }\n        return acc;\n      }\n    });\n    this.registerDefaultAttributeHandlers();\n    this.registerFlag(\"int\", {\n      transformValue: (_context, value) => this.coerceInt(value)\n    });\n    this.registerFlag(\"float\", {\n      transformValue: (_context, value) => this.coerceFloat(value)\n    });\n    this.registerBehaviorModifier(\"group\", {\n      onConstruct: ({ args, scope, rootScope, behavior, element }) => {\n        const key = typeof args === \"string\" ? args : undefined;\n        if (!key) {\n          return;\n        }\n        const targetScope = this.getGroupTargetScope(element, behavior, scope, rootScope);\n        const existing = targetScope.getPath?.(key);\n        const list = Array.isArray(existing) ? existing : [];\n        const proxy = this.getGroupProxy(scope);\n        if (!list.includes(proxy)) {\n          list.push(proxy);\n          targetScope.setPath?.(key, list);\n        } else if (!Array.isArray(existing)) {\n          targetScope.setPath?.(key, list);\n        }\n      },\n      onUnbind: ({ args, scope, rootScope, behavior, element }) => {\n        const key = typeof args === \"string\" ? args : undefined;\n        if (!key) {\n          return;\n        }\n        const targetScope = this.getGroupTargetScope(element, behavior, scope, rootScope);\n        const existing = targetScope.getPath?.(key);\n        if (!Array.isArray(existing)) {\n          return;\n        }\n        const proxy = this.getGroupProxy(scope);\n        const next = existing.filter((entry) => entry !== proxy);\n        if (next.length !== existing.length) {\n          targetScope.setPath?.(key, next);\n        }\n      }\n    });\n  }\n\n  private getGroupTargetScope(\n    element: Element,\n    behavior: RegisteredBehavior,\n    scope: Scope,\n    rootScope?: Scope\n  ): Scope {\n    let targetScope = rootScope ?? scope;\n    if (behavior.parentSelector) {\n      const parentElement = element.closest(behavior.parentSelector);\n      if (parentElement) {\n        targetScope = this.getScope(parentElement);\n      }\n    }\n    return targetScope;\n  }\n\n  private getGroupProxy(scope: Scope): Record<string, any> {\n    const cached = this.groupProxyCache.get(scope);\n    if (cached) {\n      return cached;\n    }\n    const proxy = new Proxy(\n      {},\n      {\n        get: (_target, prop) => {\n          if (typeof prop === \"symbol\") {\n            return undefined;\n          }\n          if (prop === \"__scope\") {\n            return scope;\n          }\n          return scope.getPath(String(prop));\n        },\n        set: (_target, prop, value) => {\n          if (typeof prop === \"symbol\") {\n            return false;\n          }\n          scope.setPath(String(prop), value);\n          return true;\n        },\n        has: (_target, prop) => {\n          if (typeof prop === \"symbol\") {\n            return false;\n          }\n          return scope.getPath(String(prop)) !== undefined;\n        },\n        getOwnPropertyDescriptor: () => ({\n          enumerable: true,\n          configurable: true\n        }),\n        ownKeys: () => []\n      }\n    );\n    this.groupProxyCache.set(scope, proxy);\n    return proxy;\n  }\n\n  async mount(root: HTMLElement): Promise<void> {\n    const documentRoot = root.ownerDocument;\n    const active = Engine.activeEngines.get(documentRoot);\n    if (active && active !== this) {\n      active.disconnectObserver();\n    }\n    Engine.activeEngines.set(documentRoot, this);\n    const elements: Element[] = [root, ...Array.from(root.querySelectorAll(\"*\"))];\n    for (const element of elements) {\n      if (!this.hasVsnAttributes(element)) {\n        continue;\n      }\n      const parentScope = this.findParentScope(element);\n      this.getScope(element, parentScope);\n      this.attachAttributes(element);\n      this.runConstruct(element);\n    }\n    await this.applyBehaviors(root);\n    this.attachObserver(root);\n  }\n\n  unmount(element: Element): void {\n    this.runDestruct(element);\n    this.disconnectObserver();\n  }\n\n  registerBehaviors(source: string): void {\n    const program = new Parser(source, {\n      customFlags: new Set(this.flagHandlers.keys()),\n      behaviorFlags: new Set(this.behaviorModifiers.keys())\n    }).parseProgram();\n    for (const use of program.uses) {\n      if (use.flags?.wait) {\n        this.pendingUses.push(this.waitForUseGlobal(use));\n        continue;\n      }\n      const value = this.resolveGlobalPath(use.name);\n      if (value === undefined) {\n        console.warn(`vsn: global '${use.name}' not found`);\n        continue;\n      }\n      this.registerGlobal(use.alias, value);\n    }\n    for (const behavior of program.behaviors) {\n      this.collectBehavior(behavior);\n    }\n  }\n\n  registerGlobal(name: string, value: any): void {\n    this.globals[name] = value;\n  }\n\n  registerGlobals(values: Record<string, any>): void {\n    Object.assign(this.globals, values);\n  }\n\n  registerFlag(name: string, handler: FlagHandler = {}): void {\n    this.flagHandlers.set(name, handler);\n  }\n\n  registerBehaviorModifier(name: string, handler: BehaviorModifierHandler = {}): void {\n    const reserved = new Set([\"important\", \"debounce\"]);\n    if (reserved.has(name)) {\n      throw new Error(`Behavior modifier '${name}' is reserved`);\n    }\n    this.behaviorModifiers.set(name, handler);\n  }\n\n  getRegistryStats(): { behaviorCount: number; behaviorCacheSize: number } {\n    return {\n      behaviorCount: this.behaviorRegistry.length,\n      behaviorCacheSize: this.behaviorCache.size\n    };\n  }\n\n  registerAttributeHandler(handler: AttributeHandler): void {\n    this.attributeHandlers.push(handler);\n  }\n\n  private resolveGlobalPath(name: string): any {\n    const parts = name.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return undefined;\n    }\n    let value: any = (globalThis as any)[root];\n    for (let i = 1; i < parts.length; i += 1) {\n      const part = parts[i];\n      if (!part) {\n        return undefined;\n      }\n      value = value?.[part];\n    }\n    return value;\n  }\n\n  private async waitForUses(): Promise<void> {\n    while (this.pendingUses.length > 0) {\n      const pending = this.pendingUses;\n      this.pendingUses = [];\n      await Promise.all(pending);\n    }\n  }\n\n  private waitForUseGlobal(use: UseNode): Promise<void> {\n    const config = use.flagArgs?.wait ?? {};\n    const timeoutMs = config.timeoutMs ?? 10000;\n    const initialDelayMs = config.intervalMs ?? 100;\n    const maxDelayMs = 1000;\n    const existing = this.resolveGlobalPath(use.name);\n    if (existing !== undefined) {\n      this.registerGlobal(use.alias, existing);\n      return Promise.resolve();\n    }\n    if (timeoutMs <= 0) {\n      this.emitUseError(use.name, new Error(`vsn: global '${use.name}' not found`));\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve) => {\n      let elapsedMs = 0;\n      let delayMs = initialDelayMs;\n      const check = () => {\n        const value = this.resolveGlobalPath(use.name);\n        if (value !== undefined) {\n          this.registerGlobal(use.alias, value);\n          resolve();\n          return;\n        }\n        if (elapsedMs >= timeoutMs) {\n          this.emitUseError(use.name, new Error(`vsn: global '${use.name}' not found`));\n          resolve();\n          return;\n        }\n        const scheduledDelay = Math.min(delayMs, timeoutMs - elapsedMs);\n        setTimeout(() => {\n          elapsedMs += scheduledDelay;\n          delayMs = Math.min(delayMs * 2, maxDelayMs);\n          check();\n        }, scheduledDelay);\n      };\n      check();\n    });\n  }\n\n  getScope(element: Element, parentScope?: Scope): Scope {\n    const existing = this.scopes.get(element);\n    if (existing) {\n      return existing;\n    }\n    const scope = new Scope(parentScope ?? this.findParentScope(element));\n    this.scopes.set(element, scope);\n    return scope;\n  }\n\n  evaluate(element: Element): void {\n    const scope = this.getScope(element);\n    const bindConfig = this.bindBindings.get(element);\n    if (bindConfig && (bindConfig.direction === \"from\" || bindConfig.direction === \"both\")) {\n      applyBindToElement(element, bindConfig.expr, scope);\n    }\n    const ifExpr = this.ifBindings.get(element);\n    if (ifExpr && element instanceof HTMLElement) {\n      applyIf(element, ifExpr, scope);\n    }\n    const showExpr = this.showBindings.get(element);\n    if (showExpr && element instanceof HTMLElement) {\n      applyShow(element, showExpr, scope);\n    }\n    const htmlBinding = this.htmlBindings.get(element);\n    if (htmlBinding && element instanceof HTMLElement) {\n      applyHtml(element, htmlBinding.expr, scope);\n      this.handleHtmlBehaviors(element);\n    }\n  }\n\n  private attachObserver(root: HTMLElement): void {\n    if (this.observer) {\n      return;\n    }\n    this.observerFlush = debounce(() => this.flushObserverQueue(), 10);\n    this.observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type === \"attributes\" && mutation.target instanceof Element) {\n          this.pendingUpdated.add(mutation.target);\n        }\n        for (const node of Array.from(mutation.addedNodes)) {\n          if (node && node.nodeType === 1) {\n            const element = node as Element;\n            if (this.ignoredAdded.has(element)) {\n              this.ignoredAdded.delete(element);\n              continue;\n            }\n            this.pendingAdded.add(element);\n          }\n        }\n        for (const node of Array.from(mutation.removedNodes)) {\n          if (node && node.nodeType === 1) {\n            this.pendingRemoved.add(node as Element);\n          }\n        }\n      }\n      this.observerFlush?.();\n    });\n    this.observer.observe(root, { childList: true, subtree: true, attributes: true, attributeFilter: [\"class\"] });\n  }\n\n  private disconnectObserver(): void {\n    this.observer?.disconnect();\n    this.observer = undefined;\n    this.pendingAdded.clear();\n    this.pendingRemoved.clear();\n    this.pendingUpdated.clear();\n  }\n\n  private flushObserverQueue(): void {\n    const removed = Array.from(this.pendingRemoved);\n    this.pendingRemoved.clear();\n    for (const node of removed) {\n      this.handleRemovedNode(node);\n    }\n    const updated = Array.from(this.pendingUpdated);\n    this.pendingUpdated.clear();\n    for (const node of updated) {\n      this.handleUpdatedNode(node);\n    }\n    const added = Array.from(this.pendingAdded);\n    this.pendingAdded.clear();\n    for (const node of added) {\n      this.handleAddedNode(node);\n    }\n  }\n\n  private handleRemovedNode(node: Element): void {\n    if (this.lifecycleBindings.has(node)) {\n      this.runDestruct(node);\n    }\n    if (this.behaviorBindings.has(node)) {\n      this.runBehaviorDestruct(node);\n    }\n    this.cleanupScopeWatchers(node);\n    this.cleanupBehaviorListeners(node);\n    for (const child of Array.from(node.querySelectorAll(\"*\"))) {\n      if (this.lifecycleBindings.has(child)) {\n        this.runDestruct(child);\n      }\n      if (this.behaviorBindings.has(child)) {\n        this.runBehaviorDestruct(child);\n      }\n      this.cleanupScopeWatchers(child);\n      this.cleanupBehaviorListeners(child);\n    }\n  }\n\n  private handleAddedNode(node: Element): void {\n    const elements = [node, ...Array.from(node.querySelectorAll(\"*\"))];\n    for (const element of elements) {\n      if (!this.hasVsnAttributes(element)) {\n        continue;\n      }\n      const parentScope = this.findParentScope(element);\n      this.getScope(element, parentScope);\n      this.attachAttributes(element);\n      this.runConstruct(element);\n    }\n    void this.applyBehaviors(node);\n  }\n\n  private handleUpdatedNode(node: Element): void {\n    const elements = [node, ...Array.from(node.querySelectorAll(\"*\"))];\n    for (const element of elements) {\n      void this.reapplyBehaviorsForElement(element);\n    }\n  }\n\n  private async applyBehaviors(root: Element): Promise<void> {\n    await this.waitForUses();\n    if (this.behaviorRegistry.length > 0) {\n      const elements: Element[] = [root, ...Array.from(root.querySelectorAll(\"*\"))];\n      for (const element of elements) {\n        await this.reapplyBehaviorsForElement(element);\n      }\n    }\n    this.flushAutoBindQueue();\n  }\n\n  private async reapplyBehaviorsForElement(element: Element): Promise<void> {\n    if (this.behaviorRegistry.length === 0) {\n      return;\n    }\n    const bound = this.behaviorBindings.get(element) ?? new Set<number>();\n    const scope = this.getScope(element);\n    const matched = this.behaviorRegistry\n      .filter((behavior) => element.matches(behavior.selector))\n      .sort((a, b) => {\n        if (a.specificity !== b.specificity) {\n          return a.specificity - b.specificity;\n        }\n        return a.order - b.order;\n      });\n\n    for (const behavior of matched) {\n      if (!bound.has(behavior.id)) {\n        await this.applyBehaviorForElement(behavior, element, scope, bound);\n      }\n    }\n\n    const matchedIds = new Set(matched.map((behavior) => behavior.id));\n    for (const behavior of this.behaviorRegistry) {\n      if (bound.has(behavior.id) && !matchedIds.has(behavior.id)) {\n        this.unbindBehaviorForElement(behavior, element, scope, bound);\n      }\n    }\n    this.behaviorBindings.set(element, bound);\n  }\n\n  private async applyBehaviorForElement(\n    behavior: RegisteredBehavior,\n    element: Element,\n    scope: Scope,\n    bound: Set<number>\n  ): Promise<void> {\n    bound.add(behavior.id);\n    const rootScope = this.getBehaviorRootScope(element, behavior);\n    this.applyBehaviorFunctions(element, scope, behavior.functions, rootScope);\n    await this.applyBehaviorDeclarations(element, scope, behavior.declarations, rootScope);\n    await this.applyBehaviorModifierHook(\"onBind\", behavior, element, scope, rootScope);\n    if (behavior.construct) {\n      await this.safeExecuteBlock(behavior.construct, scope, element, rootScope);\n    }\n    await this.applyBehaviorModifierHook(\"onConstruct\", behavior, element, scope, rootScope);\n    for (const onBlock of behavior.onBlocks) {\n      this.attachBehaviorOnHandler(\n        element,\n        onBlock.event,\n        onBlock.body,\n        onBlock.flags,\n        onBlock.flagArgs,\n        onBlock.args,\n        behavior.id,\n        rootScope\n      );\n    }\n    this.logDiagnostic(\"bind\", element, behavior);\n  }\n\n  private unbindBehaviorForElement(\n    behavior: RegisteredBehavior,\n    element: Element,\n    scope: Scope,\n    bound: Set<number>\n  ): void {\n    bound.delete(behavior.id);\n    const rootScope = this.getBehaviorRootScope(element, behavior);\n    if (behavior.destruct) {\n      void this.safeExecuteBlock(behavior.destruct, scope, element, rootScope);\n    }\n    void this.applyBehaviorModifierHook(\"onDestruct\", behavior, element, scope, rootScope);\n    const listenerMap = this.behaviorListeners.get(element);\n    const listeners = listenerMap?.get(behavior.id);\n    if (listeners) {\n      for (const listener of listeners) {\n        listener.target.removeEventListener(listener.event, listener.handler, listener.options);\n      }\n      listenerMap?.delete(behavior.id);\n    }\n    void this.applyBehaviorModifierHook(\"onUnbind\", behavior, element, scope, rootScope);\n    this.logDiagnostic(\"unbind\", element, behavior);\n  }\n\n  private runBehaviorDestruct(element: Element): void {\n    const bound = this.behaviorBindings.get(element);\n    if (!bound) {\n      return;\n    }\n    const scope = this.getScope(element);\n    for (const behavior of this.behaviorRegistry) {\n      if (!bound.has(behavior.id) || (!behavior.destruct && !this.behaviorHasModifierHooks(behavior))) {\n        continue;\n      }\n      const rootScope = this.getBehaviorRootScope(element, behavior);\n      if (behavior.destruct) {\n        void this.safeExecuteBlock(behavior.destruct, scope, element, rootScope);\n      }\n      void this.applyBehaviorModifierHook(\"onDestruct\", behavior, element, scope, rootScope);\n      void this.applyBehaviorModifierHook(\"onUnbind\", behavior, element, scope, rootScope);\n    }\n  }\n\n  private attachAttributes(element: Element): void {\n    const scope = this.getScope(element);\n    for (const name of element.getAttributeNames()) {\n      if (!name.startsWith(\"vsn-\")) {\n        continue;\n      }\n      const value = element.getAttribute(name) ?? \"\";\n      for (const handler of this.attributeHandlers) {\n        if (!handler.match(name)) {\n          continue;\n        }\n        const handled = handler.handle(element, name, value, scope);\n        if (handled !== false) {\n          break;\n        }\n      }\n    }\n  }\n\n  private setLifecycle(element: Element, patch: LifecycleConfig): void {\n    const current = this.lifecycleBindings.get(element) ?? {};\n    this.lifecycleBindings.set(element, { ...current, ...patch });\n  }\n\n  private runConstruct(element: Element): void {\n    const config = this.lifecycleBindings.get(element);\n    if (!config?.construct) {\n      return;\n    }\n    const scope = this.getScope(element);\n    void this.safeExecute(config.construct, scope, element);\n  }\n\n  private runDestruct(element: Element): void {\n    const config = this.lifecycleBindings.get(element);\n    if (!config?.destruct) {\n      return;\n    }\n    const scope = this.getScope(element);\n    void this.safeExecute(config.destruct, scope, element);\n  }\n\n  private parseEachExpression(value: string): { listExpr: string; itemName: string; indexName?: string } | null {\n    const [listPart, rest] = value.split(/\\s+as\\s+/);\n    if (!listPart || !rest) {\n      return null;\n    }\n    const listExpr = listPart.trim();\n    const names = rest.split(\",\").map((entry) => entry.trim()).filter(Boolean);\n    if (!listExpr || names.length === 0) {\n      return null;\n    }\n    const itemName = names[0] ?? \"\";\n    const indexName = names[1];\n    return { listExpr, itemName, ...(indexName ? { indexName } : {}) };\n  }\n\n  private renderEach(element: Element): void {\n    const binding = this.eachBindings.get(element);\n    if (!binding) {\n      return;\n    }\n    if (!(element instanceof HTMLTemplateElement)) {\n      return;\n    }\n    const parent = element.parentElement;\n    if (!parent) {\n      return;\n    }\n\n    for (const node of binding.rendered) {\n      this.handleRemovedNode(node);\n      if (node.parentNode) {\n        node.parentNode.removeChild(node);\n      }\n    }\n    binding.rendered = [];\n\n    const scope = this.getScope(element);\n    const list = scope.get(binding.listExpr);\n    if (!Array.isArray(list)) {\n      return;\n    }\n\n    const rendered: Element[] = [];\n    list.forEach((item, index) => {\n      const fragment = element.content.cloneNode(true) as DocumentFragment;\n      const roots = Array.from(fragment.children) as Element[];\n      const itemScope = new Scope(scope);\n      itemScope.isEachItem = true;\n      itemScope.setPath(`self.${binding.itemName}`, item);\n      if (binding.indexName) {\n        itemScope.setPath(`self.${binding.indexName}`, index);\n      }\n      for (const root of roots) {\n        this.getScope(root, itemScope);\n      }\n      parent.insertBefore(fragment, element);\n      for (const root of roots) {\n        this.ignoredAdded.set(root, true);\n        rendered.push(root);\n        this.handleAddedNode(root);\n        this.evaluate(root);\n        for (const child of Array.from(root.querySelectorAll(\"*\"))) {\n          this.evaluate(child);\n        }\n      }\n    });\n    binding.rendered = rendered;\n  }\n\n  private attachBindInputHandler(element: Element, expr: string): void {\n    if (!(element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement)) {\n      return;\n    }\n    const handler = () => {\n      const scope = this.getScope(element);\n      applyBindToScope(element, expr, scope);\n    };\n    element.addEventListener(\"input\", handler);\n    element.addEventListener(\"change\", handler);\n  }\n\n  private parseBindDirection(name: string): BindDirection {\n    if (name.includes(\":from\")) {\n      return \"from\";\n    }\n    if (name.includes(\":to\")) {\n      return \"to\";\n    }\n    return \"auto\";\n  }\n\n  private resolveBindConfig(element: Element, expr: string, scope: Scope, direction: BindDirection): {\n    direction: BindDirection;\n    seedFromScope: boolean;\n    syncToScope: boolean;\n    deferToScope: boolean;\n  } {\n    if (direction !== \"auto\") {\n      return {\n        direction,\n        seedFromScope: false,\n        syncToScope: direction === \"to\" || direction === \"both\",\n        deferToScope: false\n      };\n    }\n\n    if (this.isInEachScope(scope)) {\n      return { direction: \"both\", seedFromScope: false, syncToScope: false, deferToScope: false };\n    }\n\n    if (this.isFormControl(element)) {\n      if (this.hasScopeValue(scope, expr)) {\n        return { direction: \"both\", seedFromScope: true, syncToScope: false, deferToScope: false };\n      }\n      return { direction: \"both\", seedFromScope: false, syncToScope: false, deferToScope: true };\n    }\n\n    if (this.hasScopeValue(scope, expr)) {\n      return { direction: \"both\", seedFromScope: false, syncToScope: false, deferToScope: false };\n    }\n\n    if (this.hasElementValue(element)) {\n      return { direction: \"both\", seedFromScope: false, syncToScope: false, deferToScope: true };\n    }\n\n    return { direction: \"both\", seedFromScope: false, syncToScope: false, deferToScope: false };\n  }\n\n  private isFormControl(element: Element): boolean {\n    return element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement;\n  }\n\n  private hasScopeValue(scope: Scope, expr: string): boolean {\n    const key = expr.trim();\n    if (!key) {\n      return false;\n    }\n    const value = scope.get(key);\n    return value !== undefined && value !== null;\n  }\n\n  private hasElementValue(element: Element): boolean {\n    if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement) {\n      return element.value.length > 0;\n    }\n    return (element.textContent ?? \"\").trim().length > 0;\n  }\n\n  private coerceInt(value: any): any {\n    if (value == null || value === \"\") {\n      return value;\n    }\n    const num = typeof value === \"number\" ? value : Number.parseInt(String(value), 10);\n    return Number.isNaN(num) ? value : num;\n  }\n\n  private coerceFloat(value: any): any {\n    if (value == null || value === \"\") {\n      return value;\n    }\n    const num = typeof value === \"number\" ? value : Number.parseFloat(String(value));\n    return Number.isNaN(num) ? value : num;\n  }\n\n  private isInEachScope(scope: Scope): boolean {\n    let cursor: Scope | undefined = scope;\n    while (cursor) {\n      if (cursor.isEachItem) {\n        return true;\n      }\n      cursor = cursor.parent;\n    }\n    return false;\n  }\n\n  private flushAutoBindQueue(): void {\n    if (this.pendingAutoBindToScope.length === 0) {\n      return;\n    }\n    const pending = this.pendingAutoBindToScope;\n    this.pendingAutoBindToScope = [];\n    for (const entry of pending) {\n      if (!entry.element.isConnected) {\n        continue;\n      }\n      if (this.hasScopeValue(entry.scope, entry.expr)) {\n        continue;\n      }\n      if (!this.hasElementValue(entry.element)) {\n        continue;\n      }\n      applyBindToScope(entry.element, entry.expr, entry.scope);\n    }\n  }\n\n  private hasVsnAttributes(element: Element): boolean {\n    return element.getAttributeNames().some((name) => name.startsWith(\"vsn-\"));\n  }\n\n  private markInlineDeclaration(element: Element, key: string): void {\n    const set = this.inlineDeclarations.get(element) ?? new Set<string>();\n    set.add(key);\n    this.inlineDeclarations.set(element, set);\n  }\n\n  private isInlineDeclaration(element: Element, key: string): boolean {\n    const set = this.inlineDeclarations.get(element);\n    return set ? set.has(key) : false;\n  }\n\n  private findParentScope(element: Element): Scope | undefined {\n    let parent = element.parentElement;\n    while (parent) {\n      const scope = this.scopes.get(parent);\n      if (scope) {\n        return scope;\n      }\n      parent = parent.parentElement;\n    }\n    return undefined;\n  }\n\n  private watch(scope: Scope, expr: string, handler: () => void, element?: Element): void {\n    const key = expr.trim();\n    if (!key) {\n      return;\n    }\n    const root = key.split(\".\")[0];\n    if (!root) {\n      return;\n    }\n    let target: Scope | undefined = scope;\n    while (target && !target.hasKey(root)) {\n      target = target.parent;\n    }\n    if (target) {\n      target.on(key, handler);\n      if (element) {\n        this.trackScopeWatcher(element, target, \"path\", handler, key);\n      }\n      return;\n    }\n    let cursor: Scope | undefined = scope;\n    while (cursor) {\n      cursor.on(key, handler);\n      if (element) {\n        this.trackScopeWatcher(element, cursor, \"path\", handler, key);\n      }\n      cursor = cursor.parent;\n    }\n  }\n\n  private watchWithDebounce(\n    scope: Scope,\n    expr: string,\n    handler: () => void,\n    debounceMs?: number,\n    element?: Element\n  ): void {\n    const effectiveHandler = debounceMs ? debounce(handler, debounceMs) : handler;\n    this.watch(scope, expr, effectiveHandler, element);\n  }\n\n  private watchAllScopes(scope: Scope, handler: () => void, debounceMs?: number, element?: Element): void {\n    const effectiveHandler = debounceMs ? debounce(handler, debounceMs) : handler;\n    let cursor: Scope | undefined = scope;\n    while (cursor) {\n      cursor.onAny(effectiveHandler);\n      if (element) {\n        this.trackScopeWatcher(element, cursor, \"any\", effectiveHandler);\n      }\n      cursor = cursor.parent;\n    }\n  }\n\n  private trackScopeWatcher(\n    element: Element,\n    scope: Scope,\n    kind: \"path\" | \"any\",\n    handler: () => void,\n    key?: string\n  ): void {\n    const watchers = this.scopeWatchers.get(element) ?? [];\n    watchers.push({ scope, kind, handler, ...(key ? { key } : {}) });\n    this.scopeWatchers.set(element, watchers);\n  }\n\n  private cleanupScopeWatchers(element: Element): void {\n    const watchers = this.scopeWatchers.get(element);\n    if (!watchers) {\n      return;\n    }\n    for (const watcher of watchers) {\n      if (watcher.kind === \"any\") {\n        watcher.scope.offAny(watcher.handler);\n        continue;\n      }\n      if (watcher.key) {\n        watcher.scope.off(watcher.key, watcher.handler);\n      }\n    }\n    this.scopeWatchers.delete(element);\n  }\n\n  private cleanupBehaviorListeners(element: Element): void {\n    const listenerMap = this.behaviorListeners.get(element);\n    if (!listenerMap) {\n      return;\n    }\n    for (const listeners of listenerMap.values()) {\n      for (const listener of listeners) {\n        listener.target.removeEventListener(listener.event, listener.handler, listener.options);\n      }\n    }\n    listenerMap.clear();\n    this.behaviorListeners.delete(element);\n    this.behaviorBindings.delete(element);\n  }\n\n  private parseOnAttribute(name: string, value: string): OnConfig | null {\n    if (!name.startsWith(\"vsn-on:\")) {\n      return null;\n    }\n\n    const eventWithFlags = name.slice(\"vsn-on:\".length);\n    const [event, ...flags] = eventWithFlags.split(\"!\");\n    if (!event) {\n      return null;\n    }\n    if (event.includes(\".\")) {\n      throw new Error(\"vsn:on does not support dot modifiers; use !flags instead\");\n    }\n\n    const { flagMap, flagArgs } = this.parseInlineFlags(flags);\n\n    const config: OnConfig = {\n      event,\n      code: value,\n      flags: flagMap,\n      flagArgs\n    };\n    return config;\n  }\n\n  private parseInlineFlags(parts: string[]): { flagMap: DeclarationFlags; flagArgs: DeclarationFlagArgs } {\n    const flagMap: DeclarationFlags = {};\n    const flagArgs: DeclarationFlagArgs = {};\n    for (const raw of parts) {\n      const trimmed = raw.trim();\n      if (!trimmed) {\n        continue;\n      }\n      const match = trimmed.match(/^([a-zA-Z][\\w-]*)(?:\\((.+)\\))?$/);\n      if (!match) {\n        continue;\n      }\n      const name = match[1] ?? \"\";\n      if (!name) {\n        continue;\n      }\n      if (!this.flagHandlers.has(name)) {\n        throw new Error(`Unknown flag ${name}`);\n      }\n      flagMap[name] = true;\n      if (match[2] !== undefined) {\n        flagArgs[name] = this.parseInlineFlagArg(match[2]);\n      }\n    }\n    return { flagMap, flagArgs };\n  }\n\n  private parseInlineFlagArg(raw: string): any {\n    const trimmed = raw.trim();\n    if (trimmed === \"true\") {\n      return true;\n    }\n    if (trimmed === \"false\") {\n      return false;\n    }\n    if (/^-?\\d+(\\.\\d+)?$/.test(trimmed)) {\n      return Number(trimmed);\n    }\n    return trimmed;\n  }\n\n  private describeElement(element: Element): string {\n    const tag = element.tagName.toLowerCase();\n    const id = element.id ? `#${element.id}` : \"\";\n    const classes = element.classList.length > 0 ? `.${Array.from(element.classList).join(\".\")}` : \"\";\n    return `${tag}${id}${classes}`;\n  }\n\n  private logDiagnostic(type: \"bind\" | \"unbind\", element: Element, behavior: RegisteredBehavior): void {\n    if (!this.diagnostics || !this.logger.info) {\n      return;\n    }\n    this.logger.info(`vsn:${type}`, {\n      element: this.describeElement(element),\n      selector: behavior.selector,\n      behaviorId: behavior.id\n    });\n  }\n\n  private emitError(element: Element, error: unknown): void {\n    const selector = this.describeElement(element);\n    this.logger.warn?.(\"vsn:error\", { error, selector });\n    element.dispatchEvent(\n      new CustomEvent(\"vsn:error\", {\n        detail: { error, selector },\n        bubbles: true\n      })\n    );\n  }\n\n  private emitUseError(name: string, error: unknown): void {\n    const selector = `use:${name}`;\n    this.logger.warn?.(\"vsn:error\", { error, selector });\n    const target = (globalThis as any).document;\n    if (target && typeof target.dispatchEvent === \"function\") {\n      target.dispatchEvent(\n        new CustomEvent(\"vsn:error\", {\n          detail: { error, selector },\n          bubbles: true\n        })\n      );\n    }\n  }\n\n  private attachOnHandler(element: Element, config: OnConfig): void {\n    const { listenerTarget, options, debounceMs } = this.getEventBindingConfig(\n      element,\n      config.flags,\n      config.flagArgs\n    );\n    let effectiveHandler: (event?: Event) => void;\n    const handler = async (event?: Event) => {\n      if (!element.isConnected) {\n        listenerTarget.removeEventListener(config.event, effectiveHandler, options);\n        return;\n      }\n      const scope = this.getScope(element);\n      if (!this.applyEventFlagBefore(element, scope, config.flags, config.flagArgs, event)) {\n        return;\n      }\n      try {\n        await this.execute(config.code, scope, element);\n        this.evaluate(element);\n      } catch (error) {\n        this.emitError(element, error);\n      } finally {\n        this.applyEventFlagAfter(element, scope, config.flags, config.flagArgs, event);\n      }\n    };\n    effectiveHandler = debounceMs ? debounce(handler, debounceMs) : handler;\n    listenerTarget.addEventListener(config.event, effectiveHandler, options);\n  }\n\n  private attachBehaviorOnHandler(\n    element: Element,\n    event: string,\n    body: BlockNode,\n    flags: DeclarationFlags,\n    flagArgs: DeclarationFlagArgs,\n    args: string[] | undefined,\n    behaviorId: number,\n    rootScope?: Scope\n  ): void {\n    if (event.includes(\".\")) {\n      throw new Error(\"vsn:on does not support dot modifiers; use !flags instead\");\n    }\n    const { listenerTarget, options, debounceMs } = this.getEventBindingConfig(element, flags, flagArgs);\n    const handler = async (evt?: Event) => {\n      const scope = this.getScope(element);\n      if (!this.applyEventFlagBefore(element, scope, flags, flagArgs, evt)) {\n        return;\n      }\n      const previousValues = new Map<string, any>();\n      if (args && args.length > 0) {\n        const argName = args[0];\n        if (argName) {\n          previousValues.set(argName, scope.getPath(argName));\n          const [nextArg] = this.applyEventFlagArgTransforms(element, scope, flags, flagArgs, evt);\n          scope.setPath(argName, nextArg);\n        }\n      }\n      let failed = false;\n      try {\n        await this.executeBlock(body, scope, element, rootScope);\n      } catch (error) {\n        failed = true;\n        this.emitError(element, error);\n      } finally {\n        for (const [name, value] of previousValues.entries()) {\n          scope.setPath(name, value);\n        }\n        this.applyEventFlagAfter(element, scope, flags, flagArgs, evt);\n      }\n      if (!failed) {\n        this.evaluate(element);\n      }\n    };\n    const effectiveHandler = debounceMs ? debounce(handler, debounceMs) : handler;\n    listenerTarget.addEventListener(event, effectiveHandler, options);\n    const listenerMap = this.behaviorListeners.get(element) ?? new Map<number, BehaviorListener[]>();\n    const listeners = listenerMap.get(behaviorId) ?? [];\n    listeners.push({ target: listenerTarget, event, handler: effectiveHandler, options });\n    listenerMap.set(behaviorId, listeners);\n    this.behaviorListeners.set(element, listenerMap);\n  }\n\n  private attachGetHandler(element: Element, autoLoad = false): void {\n    const handler = async () => {\n      const config = this.getBindings.get(element);\n      if (!config) {\n        return;\n      }\n      try {\n        await applyGet(element, config, this.getScope(element), (target) => {\n          this.handleHtmlBehaviors(target);\n        });\n      } catch (error) {\n        console.warn(\"vsn:getError\", error);\n        element.dispatchEvent(new CustomEvent(\"vsn:getError\", { detail: { error }, bubbles: true }));\n      }\n    };\n\n    element.addEventListener(\"click\", (event) => {\n      if (event.target !== element) {\n        return;\n      }\n      void handler();\n    });\n    if (autoLoad) {\n      Promise.resolve().then(handler);\n    }\n  }\n\n  private getEventBindingConfig(\n    element: Element,\n    flags: DeclarationFlags,\n    flagArgs: DeclarationFlagArgs\n  ): { listenerTarget: EventTarget; options?: AddEventListenerOptions; debounceMs?: number } {\n    let listenerTarget: EventTarget = element;\n    let options: AddEventListenerOptions = {};\n    let debounceMs: number | undefined;\n    for (const name of Object.keys(flags)) {\n      const handler = this.flagHandlers.get(name);\n      if (!handler?.onEventBind) {\n        continue;\n      }\n      const patch = handler.onEventBind({\n        name,\n        args: flagArgs[name],\n        element,\n        scope: this.getScope(element),\n        rootScope: undefined,\n        event: undefined,\n        engine: this\n      });\n      if (!patch) {\n        continue;\n      }\n      if (patch.listenerTarget) {\n        listenerTarget = patch.listenerTarget;\n      }\n      if (patch.options) {\n        options = { ...options, ...patch.options };\n      }\n      if (patch.debounceMs !== undefined) {\n        debounceMs = patch.debounceMs;\n      }\n    }\n    return {\n      listenerTarget,\n      ...(Object.keys(options).length > 0 ? { options } : {}),\n      ...(debounceMs !== undefined ? { debounceMs } : {})\n    };\n  }\n\n  private applyEventFlagBefore(\n    element: Element,\n    scope: Scope,\n    flags: DeclarationFlags,\n    flagArgs: DeclarationFlagArgs,\n    event?: Event\n  ): boolean {\n    for (const name of Object.keys(flags)) {\n      const handler = this.flagHandlers.get(name);\n      if (!handler?.onEventBefore) {\n        continue;\n      }\n      const result = handler.onEventBefore({\n        name,\n        args: flagArgs[name],\n        element,\n        scope,\n        rootScope: undefined,\n        event,\n        engine: this\n      });\n      if (result === false) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private applyEventFlagAfter(\n    element: Element,\n    scope: Scope,\n    flags: DeclarationFlags,\n    flagArgs: DeclarationFlagArgs,\n    event?: Event\n  ): void {\n    for (const name of Object.keys(flags)) {\n      const handler = this.flagHandlers.get(name);\n      if (!handler?.onEventAfter) {\n        continue;\n      }\n      handler.onEventAfter({\n        name,\n        args: flagArgs[name],\n        element,\n        scope,\n        rootScope: undefined,\n        event,\n        engine: this\n      });\n    }\n  }\n\n  private applyEventFlagArgTransforms(\n    element: Element,\n    scope: Scope,\n    flags: DeclarationFlags,\n    flagArgs: DeclarationFlagArgs,\n    event?: Event\n  ): any[] {\n    let args: any[] = [event];\n    for (const name of Object.keys(flags)) {\n      const handler = this.flagHandlers.get(name);\n      if (!handler?.transformEventArgs) {\n        continue;\n      }\n      const nextArgs = handler.transformEventArgs(\n        {\n          name,\n          args: flagArgs[name],\n          element,\n          scope,\n          rootScope: undefined,\n          event,\n          engine: this\n        },\n        args\n      );\n      if (Array.isArray(nextArgs)) {\n        args = nextArgs;\n      }\n    }\n    return args;\n  }\n\n  private matchesKeyFlag(event: Event | undefined, flag: string): boolean {\n    if (!(event instanceof KeyboardEvent)) {\n      return false;\n    }\n    const modifierChecks: Record<string, boolean> = {\n      shift: event.shiftKey,\n      ctrl: event.ctrlKey,\n      alt: event.altKey,\n      meta: event.metaKey\n    };\n    if (flag in modifierChecks) {\n      return modifierChecks[flag] ?? false;\n    }\n    const keyAliases: Record<string, string> = {\n      escape: \"escape\",\n      esc: \"escape\",\n      enter: \"enter\",\n      tab: \"tab\",\n      space: \"space\",\n      spacebar: \"space\",\n      up: \"arrowup\",\n      down: \"arrowdown\",\n      left: \"arrowleft\",\n      right: \"arrowright\",\n      arrowup: \"arrowup\",\n      arrowdown: \"arrowdown\",\n      arrowleft: \"arrowleft\",\n      arrowright: \"arrowright\",\n      delete: \"delete\",\n      backspace: \"backspace\"\n    };\n    let key = event.key?.toLowerCase() ?? \"\";\n    if (key === \" \") {\n      key = \"space\";\n    }\n    const expectedKey = keyAliases[flag] ?? flag;\n    return key === expectedKey;\n  }\n\n  private async withExecutionElement(element: Element | undefined, fn: () => Promise<void>): Promise<void> {\n    if (!element) {\n      await fn();\n      return;\n    }\n    this.executionStack.push(element);\n    try {\n      await fn();\n    } finally {\n      this.executionStack.pop();\n    }\n  }\n\n  getCurrentElement(): Element | undefined {\n    return this.executionStack[this.executionStack.length - 1];\n  }\n\n  private async execute(code: string, scope: Scope, element?: Element, rootScope?: Scope): Promise<void> {\n    let block = this.codeCache.get(code);\n    if (!block) {\n      block = Parser.parseInline(code);\n      this.codeCache.set(code, block);\n    }\n    await this.withExecutionElement(element, async () => {\n      const context: ExecutionContext = {\n        scope,\n        rootScope,\n        globals: this.globals,\n        ...(element ? { element } : {})\n      };\n      await block.evaluate(context);\n    });\n  }\n\n  private async executeBlock(block: BlockNode, scope: Scope, element?: Element, rootScope?: Scope): Promise<void> {\n    await this.withExecutionElement(element, async () => {\n      const context: ExecutionContext = {\n        scope,\n        rootScope,\n        globals: this.globals,\n        ...(element ? { element } : {})\n      };\n      await block.evaluate(context);\n    });\n  }\n\n  private async safeExecute(code: string, scope: Scope, element?: Element, rootScope?: Scope): Promise<void> {\n    try {\n      await this.execute(code, scope, element, rootScope);\n    } catch (error) {\n      if (element) {\n        this.emitError(element, error);\n      }\n    }\n  }\n\n  private async safeExecuteBlock(\n    block: BlockNode,\n    scope: Scope,\n    element?: Element,\n    rootScope?: Scope\n  ): Promise<void> {\n    try {\n      await this.executeBlock(block, scope, element, rootScope);\n    } catch (error) {\n      if (element) {\n        this.emitError(element, error);\n      }\n    }\n  }\n\n  private collectBehavior(behavior: BehaviorNode, parentSelector?: string, rootSelectorOverride?: string): void {\n    const selector = parentSelector\n      ? `${parentSelector} ${behavior.selector.selectorText}`\n      : behavior.selector.selectorText;\n    const rootSelector = rootSelectorOverride ?? (parentSelector ?? behavior.selector.selectorText);\n    const behaviorHash = this.hashBehavior(behavior);\n    const hash = `${selector}::${rootSelector}::${behaviorHash}`;\n    if (this.behaviorRegistryHashes.has(hash)) {\n      return;\n    }\n    const cached = this.getCachedBehavior(behavior);\n    const entry: RegisteredBehavior = {\n      id: this.behaviorId += 1,\n      hash,\n      selector,\n      rootSelector,\n      specificity: this.computeSpecificity(selector),\n      order: this.behaviorRegistry.length,\n      flags: behavior.flags ?? {},\n      flagArgs: behavior.flagArgs ?? {},\n      ...cached,\n      ...(parentSelector ? { parentSelector } : {})\n    };\n    this.behaviorRegistry.push(entry);\n    this.behaviorRegistryHashes.add(hash);\n    this.collectNestedBehaviors(behavior.body, selector, rootSelector);\n  }\n\n  private collectNestedBehaviors(block: BlockNode, parentSelector: string, rootSelector: string): void {\n    for (const statement of block.statements) {\n      if (statement instanceof BehaviorNode) {\n        this.collectBehavior(statement, parentSelector, rootSelector);\n        continue;\n      }\n      if (statement instanceof OnBlockNode) {\n        this.collectNestedBehaviors(statement.body, parentSelector, rootSelector);\n        continue;\n      }\n      if (statement instanceof BlockNode) {\n        this.collectNestedBehaviors(statement, parentSelector, rootSelector);\n      }\n    }\n  }\n\n  private computeSpecificity(selector: string): number {\n    const idMatches = selector.match(/#[\\w-]+/g)?.length ?? 0;\n    const classMatches = selector.match(/\\.[\\w-]+/g)?.length ?? 0;\n    const attrMatches = selector.match(/\\[[^\\]]+\\]/g)?.length ?? 0;\n    const pseudoMatches = selector.match(/:[\\w-]+/g)?.length ?? 0;\n    const elementMatches = selector.match(/(^|[\\s>+~])([a-zA-Z][\\w-]*)/g)?.length ?? 0;\n    return idMatches * 100 + (classMatches + attrMatches + pseudoMatches) * 10 + elementMatches;\n  }\n\n  private getBehaviorRootScope(element: Element, behavior: RegisteredBehavior): Scope {\n    const rootElement = element.closest(behavior.rootSelector) ?? element;\n    return this.getScope(rootElement);\n  }\n\n\n  private getImportantKey(declaration: DeclarationNode): string | undefined {\n    if (declaration.target instanceof IdentifierExpression) {\n      return `state:${declaration.target.name}`;\n    }\n    if (declaration.target instanceof DirectiveExpression) {\n      return `${declaration.target.kind}:${declaration.target.name}`;\n    }\n    return undefined;\n  }\n\n  private isImportant(element: Element, key: string): boolean {\n    const set = this.importantFlags.get(element);\n    return set ? set.has(key) : false;\n  }\n\n  private markImportant(element: Element, key: string): void {\n    const set = this.importantFlags.get(element) ?? new Set<string>();\n    set.add(key);\n    this.importantFlags.set(element, set);\n  }\n\n  private extractLifecycle(body: BlockNode): { construct?: BlockNode; destruct?: BlockNode } {\n    let construct: BlockNode | undefined;\n    let destruct: BlockNode | undefined;\n    for (const statement of body.statements) {\n      if (!(statement instanceof BlockNode)) {\n        continue;\n      }\n      if (statement.type === \"Construct\") {\n        construct = statement;\n      } else if (statement.type === \"Destruct\") {\n        destruct = statement;\n      }\n    }\n    return {\n      ...(construct ? { construct } : {}),\n      ...(destruct ? { destruct } : {})\n    };\n  }\n\n  private extractOnBlocks(\n    body: BlockNode\n  ): { event: string; body: BlockNode; flags: DeclarationFlags; flagArgs: DeclarationFlagArgs; args: string[] }[] {\n    const blocks: { event: string; body: BlockNode; flags: DeclarationFlags; flagArgs: DeclarationFlagArgs; args: string[] }[] = [];\n    for (const statement of body.statements) {\n      if (statement instanceof OnBlockNode) {\n        blocks.push({\n          event: statement.eventName,\n          body: statement.body,\n          flags: statement.flags,\n          flagArgs: statement.flagArgs,\n          args: statement.args\n        });\n      }\n    }\n    return blocks;\n  }\n\n  private extractDeclarations(body: BlockNode): DeclarationNode[] {\n    const declarations: DeclarationNode[] = [];\n    for (const statement of body.statements) {\n      if (statement instanceof DeclarationNode) {\n        declarations.push(statement);\n      }\n    }\n    return declarations;\n  }\n\n  private extractFunctionDeclarations(body: BlockNode): FunctionBinding[] {\n    const functions: FunctionBinding[] = [];\n    for (const statement of body.statements) {\n      if (statement instanceof FunctionDeclarationNode) {\n        functions.push({ name: statement.name, params: statement.params, body: statement.body });\n        continue;\n      }\n      if (statement instanceof AssignmentNode) {\n        if (statement.target instanceof IdentifierExpression && statement.value instanceof FunctionExpression) {\n          functions.push({\n            name: statement.target.name,\n            params: statement.value.params,\n            body: statement.value.body\n          });\n        }\n      }\n    }\n    return functions;\n  }\n\n  private getCachedBehavior(behavior: BehaviorNode): CachedBehavior {\n    const hash = this.hashBehavior(behavior);\n    const cached = this.behaviorCache.get(hash);\n    if (cached) {\n      return cached;\n    }\n    const lifecycle = this.extractLifecycle(behavior.body);\n    const fresh: CachedBehavior = {\n      onBlocks: this.extractOnBlocks(behavior.body),\n      declarations: this.extractDeclarations(behavior.body),\n      functions: this.extractFunctionDeclarations(behavior.body),\n      ...lifecycle\n    };\n    this.behaviorCache.set(hash, fresh);\n    return fresh;\n  }\n\n  private hashBehavior(behavior: BehaviorNode): string {\n    const normalized = this.normalizeNode(behavior);\n    const json = JSON.stringify(normalized);\n    return this.hashString(json);\n  }\n\n  private normalizeNode(node: any): any {\n    if (!node || typeof node !== \"object\") {\n      return node;\n    }\n    const type = node.type ?? \"Unknown\";\n    if (type === \"Behavior\") {\n      return {\n        type,\n        selector: node.selector?.selectorText ?? \"\",\n        flags: node.flags ?? {},\n        flagArgs: node.flagArgs ?? {},\n        body: this.normalizeNode(node.body)\n      };\n    }\n    if (type === \"Selector\") {\n      return { type, selectorText: node.selectorText ?? \"\" };\n    }\n    if (type === \"Block\" || type === \"Construct\" || type === \"Destruct\") {\n      return {\n        type,\n        statements: Array.isArray(node.statements)\n          ? node.statements.map((statement: any) => this.normalizeNode(statement))\n          : []\n      };\n    }\n    if (type === \"OnBlock\") {\n      return {\n        type,\n        eventName: node.eventName ?? \"\",\n        args: Array.isArray(node.args) ? node.args : [],\n        flags: node.flags ?? {},\n        flagArgs: node.flagArgs ?? {},\n        body: this.normalizeNode(node.body)\n      };\n    }\n    if (type === \"Declaration\") {\n      return {\n        type,\n        target: this.normalizeNode(node.target),\n        operator: node.operator ?? \"\",\n        value: this.normalizeNode(node.value),\n        flags: node.flags ?? {},\n        flagArgs: node.flagArgs ?? {}\n      };\n    }\n    if (type === \"Assignment\") {\n      return {\n        type,\n        target: this.normalizeNode(node.target),\n        value: this.normalizeNode(node.value),\n        operator: node.operator ?? \"\",\n        prefix: Boolean(node.prefix)\n      };\n    }\n    if (type === \"FunctionDeclaration\") {\n      return {\n        type,\n        name: node.name ?? \"\",\n        params: Array.isArray(node.params)\n          ? node.params.map((param: any) => ({\n            name: param?.name ?? \"\",\n            rest: Boolean(param?.rest),\n            defaultValue: this.normalizeNode(param?.defaultValue ?? null)\n          }))\n          : [],\n        body: this.normalizeNode(node.body),\n        isAsync: Boolean(node.isAsync)\n      };\n    }\n    if (type === \"FunctionExpression\") {\n      return {\n        type,\n        params: Array.isArray(node.params)\n          ? node.params.map((param: any) => ({\n            name: param?.name ?? \"\",\n            rest: Boolean(param?.rest),\n            defaultValue: this.normalizeNode(param?.defaultValue ?? null)\n          }))\n          : [],\n        body: this.normalizeNode(node.body),\n        isAsync: Boolean(node.isAsync)\n      };\n    }\n    if (type === \"Return\") {\n      return {\n        type,\n        value: this.normalizeNode(node.value ?? null)\n      };\n    }\n    if (type === \"Assert\") {\n      return {\n        type,\n        test: this.normalizeNode(node.test)\n      };\n    }\n    if (type === \"Break\" || type === \"Continue\") {\n      return { type };\n    }\n    if (type === \"If\") {\n      return {\n        type,\n        test: this.normalizeNode(node.test),\n        consequent: this.normalizeNode(node.consequent),\n        alternate: this.normalizeNode(node.alternate ?? null)\n      };\n    }\n    if (type === \"While\") {\n      return {\n        type,\n        test: this.normalizeNode(node.test),\n        body: this.normalizeNode(node.body)\n      };\n    }\n    if (type === \"For\") {\n      return {\n        type,\n        init: this.normalizeNode(node.init ?? null),\n        test: this.normalizeNode(node.test ?? null),\n        update: this.normalizeNode(node.update ?? null),\n        body: this.normalizeNode(node.body)\n      };\n    }\n    if (type === \"ForEach\") {\n      return {\n        type,\n        kind: node.kind ?? \"of\",\n        target: this.normalizeNode(node.target),\n        iterable: this.normalizeNode(node.iterable),\n        body: this.normalizeNode(node.body)\n      };\n    }\n    if (type === \"Try\") {\n      return {\n        type,\n        errorName: node.errorName ?? \"\",\n        body: this.normalizeNode(node.body),\n        handler: this.normalizeNode(node.handler)\n      };\n    }\n    if (type === \"Identifier\") {\n      return { type, name: node.name ?? \"\" };\n    }\n    if (type === \"ElementRef\") {\n      return { type, id: node.id ?? \"\" };\n    }\n    if (type === \"Literal\") {\n      return { type, value: node.value };\n    }\n    if (type === \"TemplateExpression\") {\n      return {\n        type,\n        parts: Array.isArray(node.parts) ? node.parts.map((part: any) => this.normalizeNode(part)) : []\n      };\n    }\n    if (type === \"UnaryExpression\") {\n      return {\n        type,\n        operator: node.operator ?? \"\",\n        argument: this.normalizeNode(node.argument)\n      };\n    }\n    if (type === \"BinaryExpression\") {\n      return {\n        type,\n        operator: node.operator ?? \"\",\n        left: this.normalizeNode(node.left),\n        right: this.normalizeNode(node.right)\n      };\n    }\n    if (type === \"TernaryExpression\") {\n      return {\n        type,\n        test: this.normalizeNode(node.test),\n        consequent: this.normalizeNode(node.consequent),\n        alternate: this.normalizeNode(node.alternate)\n      };\n    }\n    if (type === \"MemberExpression\") {\n      return {\n        type,\n        target: this.normalizeNode(node.target),\n        property: node.property ?? \"\",\n        optional: Boolean(node.optional)\n      };\n    }\n    if (type === \"CallExpression\") {\n      return {\n        type,\n        callee: this.normalizeNode(node.callee),\n        args: Array.isArray(node.args) ? node.args.map((arg: any) => this.normalizeNode(arg)) : []\n      };\n    }\n    if (type === \"AwaitExpression\") {\n      return {\n        type,\n        argument: this.normalizeNode(node.argument)\n      };\n    }\n    if (type === \"Directive\") {\n      return { type, kind: node.kind ?? \"\", name: node.name ?? \"\" };\n    }\n    if (type === \"ElementDirective\") {\n      return {\n        type,\n        element: this.normalizeNode(node.element),\n        directive: this.normalizeNode(node.directive)\n      };\n    }\n    if (type === \"ElementProperty\") {\n      return {\n        type,\n        element: this.normalizeNode(node.element),\n        property: node.property ?? \"\"\n      };\n    }\n    if (type === \"Query\") {\n      return { type, direction: node.direction ?? \"\", selector: node.selector ?? \"\" };\n    }\n    if (type === \"ArrayExpression\") {\n      return {\n        type,\n        elements: Array.isArray(node.elements)\n          ? node.elements.map((element: any) => this.normalizeNode(element))\n          : []\n      };\n    }\n    if (type === \"ObjectExpression\") {\n      return {\n        type,\n        entries: Array.isArray(node.entries)\n          ? node.entries.map((entry: any) => ({\n              key: entry?.key ?? \"\",\n              computed: Boolean(entry?.computed),\n              keyExpr: entry?.keyExpr ? this.normalizeNode(entry.keyExpr) : null,\n              value: this.normalizeNode(entry?.value)\n            }))\n          : []\n      };\n    }\n    if (type === \"IndexExpression\") {\n      return {\n        type,\n        target: this.normalizeNode(node.target),\n        index: this.normalizeNode(node.index)\n      };\n    }\n    return { type };\n  }\n\n  private hashString(value: string): string {\n    let hash = 5381;\n    for (let i = 0; i < value.length; i += 1) {\n      hash = ((hash << 5) + hash) + value.charCodeAt(i);\n      hash |= 0;\n    }\n    return (hash >>> 0).toString(16);\n  }\n\n  private applyBehaviorFunctions(\n    element: Element,\n    scope: Scope,\n    functions: FunctionBinding[],\n    rootScope?: Scope\n  ): void {\n    for (const declaration of functions) {\n      this.applyBehaviorFunction(element, scope, declaration, rootScope);\n    }\n  }\n\n  private applyBehaviorFunction(\n    element: Element,\n    scope: Scope,\n    declaration: FunctionBinding,\n    rootScope?: Scope\n  ): void {\n    const existing = scope.getPath(declaration.name);\n    if (existing !== undefined && typeof existing !== \"function\") {\n      throw new Error(`Cannot override non-function '${declaration.name}' with a function`);\n    }\n    const fn = async (...args: any[]) => {\n      const callScope = scope.createChild ? scope.createChild() : scope;\n      const context: ExecutionContext = {\n        scope: callScope,\n        rootScope: rootScope ?? callScope,\n        globals: this.globals,\n        element,\n        returnValue: undefined,\n        returning: false,\n        breaking: false,\n        continuing: false\n      };\n      const previousValues = new Map<string, any>();\n      await this.applyFunctionParams(callScope, declaration.params, previousValues, context, args);\n      await declaration.body.evaluate(context);\n      if (callScope === scope) {\n        this.restoreFunctionParams(callScope, declaration.params, previousValues);\n      }\n      return context.returnValue;\n    };\n    scope.setPath(declaration.name, fn);\n  }\n\n  private async applyFunctionParams(\n    scope: Scope,\n    params: FunctionParam[],\n    previousValues: Map<string, any>,\n    context: ExecutionContext,\n    args: any[]\n  ): Promise<void> {\n    let argIndex = 0;\n    for (const param of params) {\n      const name = param.name;\n      if (!name) {\n        continue;\n      }\n      previousValues.set(name, scope.getPath(name));\n      if (param.rest) {\n        scope.setPath(`self.${name}`, args.slice(argIndex));\n        argIndex = args.length;\n        continue;\n      }\n      let value = args[argIndex];\n      if (value === undefined && param.defaultValue) {\n        value = await param.defaultValue.evaluate(context);\n      }\n      scope.setPath(`self.${name}`, value);\n      argIndex += 1;\n    }\n  }\n\n  private restoreFunctionParams(\n    scope: Scope,\n    params: FunctionParam[],\n    previousValues: Map<string, any>\n  ): void {\n    for (const param of params) {\n      const name = param.name;\n      if (!name) {\n        continue;\n      }\n      scope.setPath(name, previousValues.get(name));\n    }\n  }\n\n  private async applyBehaviorDeclarations(\n    element: Element,\n    scope: Scope,\n    declarations: DeclarationNode[],\n    rootScope?: Scope\n  ): Promise<void> {\n    for (const declaration of declarations) {\n      await this.applyBehaviorDeclaration(element, scope, declaration, rootScope);\n    }\n  }\n\n  private async applyBehaviorDeclaration(\n    element: Element,\n    scope: Scope,\n    declaration: DeclarationNode,\n    rootScope?: Scope\n  ): Promise<void> {\n    const context: ExecutionContext = { scope, rootScope, element };\n    const operator = declaration.operator;\n    const debounceMs = declaration.flags.debounce\n      ? declaration.flagArgs.debounce ?? 200\n      : undefined;\n    const transform = (value: any) => this.applyCustomFlagTransforms(value, element, scope, declaration);\n    const importantKey = this.getImportantKey(declaration);\n    if (!declaration.flags.important && importantKey && this.isImportant(element, importantKey)) {\n      return;\n    }\n    if (importantKey && this.isInlineDeclaration(element, importantKey)) {\n      return;\n    }\n    this.applyCustomFlags(element, scope, declaration);\n\n    if (declaration.target instanceof IdentifierExpression) {\n      const value = await declaration.value.evaluate(context);\n      const transformed = this.applyCustomFlagTransforms(value, element, scope, declaration);\n      scope.setPath(declaration.target.name, transformed);\n      if (declaration.flags.important && importantKey) {\n        this.markImportant(element, importantKey);\n      }\n      return;\n    }\n\n    if (!(declaration.target instanceof DirectiveExpression)) {\n      return;\n    }\n\n    const target = declaration.target;\n    const exprIdentifier =\n      declaration.value instanceof IdentifierExpression ? declaration.value.name : undefined;\n\n    if (operator === \":>\") {\n      if (exprIdentifier) {\n        this.applyDirectiveToScope(element, target, exprIdentifier, scope, debounceMs, rootScope, transform);\n      }\n      if (declaration.flags.important && importantKey) {\n        this.markImportant(element, importantKey);\n      }\n      return;\n    }\n\n    if (operator === \":=\" && exprIdentifier) {\n      this.applyDirectiveToScope(element, target, exprIdentifier, scope, debounceMs, rootScope, transform);\n    }\n\n    if (!exprIdentifier) {\n      const value = await declaration.value.evaluate(context);\n      const transformed = this.applyCustomFlagTransforms(value, element, scope, declaration);\n      this.setDirectiveValue(element, target, transformed);\n      const shouldWatch = operator === \":<\" || operator === \":=\";\n      if (shouldWatch) {\n        this.applyDirectiveFromExpression(\n          element,\n          target,\n          declaration.value,\n          scope,\n          debounceMs,\n          rootScope\n        );\n      }\n      if (declaration.flags.important && importantKey) {\n        this.markImportant(element, importantKey);\n      }\n      return;\n    }\n\n    const shouldWatch = operator === \":<\" || operator === \":=\";\n    this.applyDirectiveFromScope(\n      element,\n      target,\n      exprIdentifier,\n      scope,\n      debounceMs,\n      shouldWatch,\n      rootScope\n    );\n    if (declaration.flags.important && importantKey) {\n      this.markImportant(element, importantKey);\n    }\n  }\n\n  private applyCustomFlags(element: Element, scope: Scope, declaration: DeclarationNode): void {\n    if (this.flagHandlers.size === 0) {\n      return;\n    }\n    for (const [name, handler] of this.flagHandlers) {\n      if (!declaration.flags[name]) {\n        continue;\n      }\n      handler.onApply?.({\n        name,\n        args: declaration.flagArgs[name],\n        element,\n        scope,\n        declaration\n      });\n    }\n  }\n\n  private applyCustomFlagTransforms(\n    value: any,\n    element: Element,\n    scope: Scope,\n    declaration: DeclarationNode\n  ): any {\n    if (this.flagHandlers.size === 0) {\n      return value;\n    }\n    let nextValue = value;\n    for (const [name, handler] of this.flagHandlers) {\n      if (!declaration.flags[name] || !handler.transformValue) {\n        continue;\n      }\n      nextValue = handler.transformValue(\n        {\n          name,\n          args: declaration.flagArgs[name],\n          element,\n          scope,\n          declaration\n        },\n        nextValue\n      );\n    }\n    return nextValue;\n  }\n\n  private async applyBehaviorModifierHook(\n    hook: keyof BehaviorModifierHandler,\n    behavior: RegisteredBehavior,\n    element: Element,\n    scope: Scope,\n    rootScope?: Scope\n  ): Promise<void> {\n    if (this.behaviorModifiers.size === 0) {\n      return;\n    }\n    for (const [name, handler] of this.behaviorModifiers) {\n      if (!behavior.flags?.[name]) {\n        continue;\n      }\n      const callback = handler[hook];\n      if (!callback) {\n        continue;\n      }\n      await callback({\n        name,\n        args: behavior.flagArgs?.[name],\n        element,\n        scope,\n        rootScope,\n        behavior,\n        engine: this\n      });\n    }\n  }\n\n  private behaviorHasModifierHooks(behavior: RegisteredBehavior): boolean {\n    if (this.behaviorModifiers.size === 0) {\n      return false;\n    }\n    const flags = behavior.flags ?? {};\n    for (const name of Object.keys(flags)) {\n      if (flags[name] && this.behaviorModifiers.has(name)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private applyDirectiveFromScope(\n    element: Element,\n    target: DirectiveExpression,\n    expr: string,\n    scope: Scope,\n    debounceMs?: number,\n    watch = true,\n    rootScope?: Scope\n  ): void {\n    if (target.kind === \"attr\" && target.name === \"html\" && element instanceof HTMLElement) {\n      const handler = () => {\n        const useRoot = expr.startsWith(\"root.\") && rootScope;\n        const sourceScope = useRoot ? rootScope : scope;\n        const localExpr = useRoot ? `self.${expr.slice(\"root.\".length)}` : expr;\n        applyHtml(element, localExpr, sourceScope);\n      };\n      handler();\n      this.handleHtmlBehaviors(element);\n      if (watch) {\n        const useRoot = expr.startsWith(\"root.\") && rootScope;\n        const sourceScope = useRoot ? rootScope : scope;\n        const watchExpr = useRoot ? expr.slice(\"root.\".length) : expr;\n        this.watchWithDebounce(sourceScope, watchExpr, handler, debounceMs, element);\n      }\n      return;\n    }\n    const handler = () => {\n      const useRoot = expr.startsWith(\"root.\") && rootScope;\n      const sourceScope = useRoot ? rootScope : scope;\n      const localExpr = useRoot ? `self.${expr.slice(\"root.\".length)}` : expr;\n      const value = sourceScope.get(localExpr);\n      if (value == null) {\n        return;\n      }\n      this.setDirectiveValue(element, target, value);\n    };\n    handler();\n    if (watch) {\n      const useRoot = expr.startsWith(\"root.\") && rootScope;\n      const sourceScope = useRoot ? rootScope : scope;\n      const watchExpr = useRoot ? expr.slice(\"root.\".length) : expr;\n      this.watchWithDebounce(sourceScope, watchExpr, handler, debounceMs, element);\n    }\n  }\n\n  private applyDirectiveFromExpression(\n    element: Element,\n    target: DirectiveExpression,\n    expr: ExpressionNode,\n    scope: Scope,\n    debounceMs?: number,\n    rootScope?: Scope\n  ): void {\n    const handler = async () => {\n      const context: ExecutionContext = { scope, rootScope, element };\n      const value = await expr.evaluate(context);\n      this.setDirectiveValue(element, target, value);\n    };\n    void handler();\n    this.watchAllScopes(scope, () => {\n      void handler();\n    }, debounceMs, element);\n  }\n\n  private applyDirectiveToScope(\n    element: Element,\n    target: DirectiveExpression,\n    expr: string,\n    scope: Scope,\n    debounceMs?: number,\n    rootScope?: Scope,\n    transform?: (value: any) => any\n  ): void {\n    const useRoot = expr.startsWith(\"root.\") && rootScope;\n    const targetScope = useRoot ? rootScope : scope;\n    const targetExpr = useRoot ? `self.${expr.slice(\"root.\".length)}` : expr;\n    if (target.kind === \"attr\" && target.name === \"value\") {\n      this.applyValueBindingToScope(element, targetExpr, debounceMs, targetScope, transform);\n      return;\n    }\n    if (target.kind === \"attr\" && target.name === \"checked\") {\n      this.applyCheckedBindingToScope(element, targetExpr, debounceMs, targetScope, transform);\n      return;\n    }\n    const value = this.getDirectiveValue(element, target);\n    if (value != null) {\n      const nextValue = transform ? transform(value) : value;\n      targetScope.set(targetExpr, nextValue);\n    }\n  }\n\n  private applyCheckedBindingToScope(\n    element: Element,\n    expr: string,\n    debounceMs?: number,\n    scope?: Scope,\n    transform?: (value: any) => any\n  ): void {\n    if (!(element instanceof HTMLInputElement)) {\n      return;\n    }\n    const handler = () => {\n      const targetScope = scope ?? this.getScope(element);\n      const value = transform ? transform(element.checked) : element.checked;\n      targetScope.set(expr, value);\n    };\n    const effectiveHandler = debounceMs ? debounce(handler, debounceMs) : handler;\n    effectiveHandler();\n    element.addEventListener(\"change\", effectiveHandler);\n    element.addEventListener(\"input\", effectiveHandler);\n  }\n\n  private applyValueBindingToScope(\n    element: Element,\n    expr: string,\n    debounceMs?: number,\n    scope?: Scope,\n    transform?: (value: any) => any\n  ): void {\n    if (!(element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement)) {\n      return;\n    }\n    const handler = () => {\n      const targetScope = scope ?? this.getScope(element);\n      const value = element.value;\n      const nextValue = transform ? transform(value) : value;\n      targetScope.set(expr, nextValue);\n    };\n    const effectiveHandler = debounceMs ? debounce(handler, debounceMs) : handler;\n    effectiveHandler();\n    element.addEventListener(\"input\", effectiveHandler);\n    element.addEventListener(\"change\", effectiveHandler);\n  }\n\n  private setDirectiveValue(\n    element: Element,\n    target: DirectiveExpression,\n    value: unknown\n  ): void {\n    if (target.kind === \"attr\" && target.name === \"html\" && element instanceof HTMLElement) {\n      const html = value == null ? \"\" : String(value);\n      element.innerHTML = html;\n      this.handleHtmlBehaviors(element);\n      return;\n    }\n    if (target.kind === \"attr\") {\n      if (target.name === \"text\" && element instanceof HTMLElement) {\n        element.innerText = value == null ? \"\" : String(value);\n        return;\n      }\n      if (target.name === \"content\" && element instanceof HTMLElement) {\n        element.textContent = value == null ? \"\" : String(value);\n        return;\n      }\n      if (target.name === \"value\") {\n        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n          element.value = value == null ? \"\" : String(value);\n          element.setAttribute(\"value\", element.value);\n          return;\n        }\n        if (element instanceof HTMLSelectElement) {\n          element.value = value == null ? \"\" : String(value);\n          return;\n        }\n      }\n      if (target.name === \"checked\" && element instanceof HTMLInputElement) {\n        const checked = value === true || value === \"true\" || value === 1 || value === \"1\";\n        element.checked = checked;\n        if (checked) {\n          element.setAttribute(\"checked\", \"\");\n        } else {\n          element.removeAttribute(\"checked\");\n        }\n        return;\n      }\n      element.setAttribute(target.name, value == null ? \"\" : String(value));\n      return;\n    }\n    if (target.kind === \"style\" && element instanceof HTMLElement) {\n      element.style.setProperty(target.name, value == null ? \"\" : String(value));\n    }\n  }\n\n  private getDirectiveValue(element: Element, target: DirectiveExpression): unknown {\n    if (target.kind === \"attr\") {\n      if (target.name === \"text\" && element instanceof HTMLElement) {\n        return element.innerText;\n      }\n      if (target.name === \"content\" && element instanceof HTMLElement) {\n        return element.textContent ?? \"\";\n      }\n      if (target.name === \"value\") {\n        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n          return element.value;\n        }\n        if (element instanceof HTMLSelectElement) {\n          return element.value;\n        }\n      }\n      if (target.name === \"checked\" && element instanceof HTMLInputElement) {\n        return element.checked;\n      }\n      return element.getAttribute(target.name) ?? undefined;\n    }\n    if (target.kind === \"style\" && element instanceof HTMLElement) {\n      return element.style.getPropertyValue(target.name) ?? undefined;\n    }\n    return undefined;\n  }\n\n  private handleHtmlBehaviors(root: Element): void {\n    const scripts = Array.from(root.querySelectorAll('script[type=\"text/vsn\"]'));\n    if (scripts.length === 0) {\n      return;\n    }\n    const source = scripts.map((script) => script.textContent ?? \"\").join(\"\\n\");\n    if (!source.trim()) {\n      return;\n    }\n    this.registerBehaviors(source);\n    void this.applyBehaviors(root);\n  }\n\n  private registerDefaultAttributeHandlers(): void {\n    this.registerAttributeHandler({\n      id: \"vsn-bind\",\n      match: (name) => name.startsWith(\"vsn-bind\"),\n      handle: (element, name, value, scope) => {\n        const parsedDirection = this.parseBindDirection(name);\n        const config = this.resolveBindConfig(element, value, scope, parsedDirection);\n        const direction = config.direction;\n        const auto = parsedDirection === \"auto\";\n        this.bindBindings.set(element, { expr: value, direction, auto });\n        if (!auto && (direction === \"to\" || direction === \"both\")) {\n          this.markInlineDeclaration(element, `state:${value}`);\n        }\n        if (config.seedFromScope) {\n          applyBindToElement(element, value, scope);\n        }\n        if (config.deferToScope) {\n          this.pendingAutoBindToScope.push({ element, expr: value, scope });\n        } else if (config.syncToScope) {\n          applyBindToScope(element, value, scope);\n        }\n        if (direction === \"to\" || direction === \"both\") {\n          this.attachBindInputHandler(element, value);\n        }\n        if (direction === \"from\" || direction === \"both\") {\n          this.watch(scope, value, () => applyBindToElement(element, value, scope), element);\n        }\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-if\",\n      match: (name) => name === \"vsn-if\",\n      handle: (element, _name, value, scope) => {\n        this.ifBindings.set(element, value);\n        if (element instanceof HTMLElement) {\n          applyIf(element, value, scope);\n        }\n        this.watch(scope, value, () => this.evaluate(element), element);\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-show\",\n      match: (name) => name === \"vsn-show\",\n      handle: (element, _name, value, scope) => {\n        this.showBindings.set(element, value);\n        if (element instanceof HTMLElement) {\n          applyShow(element, value, scope);\n        }\n        this.watch(scope, value, () => this.evaluate(element), element);\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-html\",\n      match: (name) => name.startsWith(\"vsn-html\"),\n      handle: (element, _name, value, scope) => {\n        this.htmlBindings.set(element, { expr: value });\n        this.markInlineDeclaration(element, \"attr:html\");\n        if (element instanceof HTMLElement) {\n          applyHtml(element, value, scope);\n          this.handleHtmlBehaviors(element);\n        }\n        this.watch(scope, value, () => this.evaluate(element), element);\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-each\",\n      match: (name) => name === \"vsn-each\",\n      handle: (element, _name, value, scope) => {\n        const config = this.parseEachExpression(value);\n        if (!config) {\n          return;\n        }\n        this.eachBindings.set(element, { ...config, rendered: [] });\n        this.renderEach(element);\n        this.watch(scope, config.listExpr, () => this.renderEach(element), element);\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-get\",\n      match: (name) => name.startsWith(\"vsn-get\"),\n      handle: (element, name) => {\n        const autoLoad = name.includes(\"!load\");\n        const url = element.getAttribute(name) ?? \"\";\n        const target = element.getAttribute(\"vsn-target\") ?? undefined;\n        const swap = (element.getAttribute(\"vsn-swap\") as \"inner\" | \"outer\" | null) ?? \"inner\";\n        const config: GetConfig = {\n          url,\n          swap,\n          ...(target ? { targetSelector: target } : {})\n        };\n        this.getBindings.set(element, config);\n        this.attachGetHandler(element, autoLoad);\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-construct\",\n      match: (name) => name === \"vsn-construct\",\n      handle: (element, _name, value) => {\n        this.setLifecycle(element, { construct: value });\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-destruct\",\n      match: (name) => name === \"vsn-destruct\",\n      handle: (element, _name, value) => {\n        this.setLifecycle(element, { destruct: value });\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-on\",\n      match: (name) => name.startsWith(\"vsn-on:\"),\n      handle: (element, name, value) => {\n        const onConfig = this.parseOnAttribute(name, value);\n        if (onConfig) {\n          this.attachOnHandler(element, onConfig);\n        }\n      }\n    });\n  }\n}\n","export const VERSION = \"0.1.0\";\n\nexport { Lexer } from \"./parser/lexer\";\nimport { Parser } from \"./parser/parser\";\nimport { Engine } from \"./runtime/engine\";\nexport { Parser };\nexport { TokenType } from \"./parser/token\";\nexport * from \"./ast/nodes\";\nexport { Engine } from \"./runtime/engine\";\n\nexport function parseCFS(source: string) {\n  const parser = new Parser(source);\n  return parser.parseProgram();\n}\n\nif (typeof window !== \"undefined\") {\n  (window as any)[\"parseCFS\"] = parseCFS;\n}\n\nexport function autoMount(root: HTMLElement | Document = document): Engine | null {\n  if (typeof document === \"undefined\") {\n    return null;\n  }\n  const engine = new Engine();\n  (globalThis as any).VSNEngine = engine;\n  const startTime = typeof performance !== \"undefined\" && performance.now ? performance.now() : Date.now();\n  const mount = () => {\n    const target = root instanceof Document ? root.body : root;\n    if (target) {\n      const plugins = (globalThis as any).VSNPlugins;\n      if (plugins && typeof plugins === \"object\") {\n        for (const plugin of Object.values(plugins)) {\n          if (typeof plugin === \"function\") {\n            plugin(engine);\n          }\n        }\n      }\n      const sources = Array.from(document.querySelectorAll('script[type=\"text/vsn\"]'))\n        .map((script) => script.textContent ?? \"\")\n        .join(\"\\n\");\n      if (sources.trim()) {\n        engine.registerBehaviors(sources);\n      }\n      engine.mount(target);\n      const endTime = typeof performance !== \"undefined\" && performance.now ? performance.now() : Date.now();\n      const elapsedMs = Math.round(endTime - startTime);\n      console.log(`Took ${elapsedMs}ms to start up VSN.js. https://www.vsnjs.com/ v${VERSION}`);\n    }\n  };\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", () => setTimeout(mount, 0), { once: true });\n  } else {\n    setTimeout(mount, 0);\n  }\n  return engine;\n}\n\nif (typeof document !== \"undefined\") {\n  const scriptTag = document.querySelector(\"script[auto-mount]\");\n  if (scriptTag) {\n    autoMount();\n  }\n}\n"],"mappings":"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","names":["TokenType","KEYWORDS","Lexer","input","tokens","pending","chunk","ch","punct","start","value","keywordType","quote","escaped","dollarStart","braceStart","next","type","token","offset","BaseNode","type","_context","isPromiseLike","value","resolveMaybe","next","evaluateWithChildScope","context","block","scope","previousScope","ProgramNode","behaviors","uses","UseNode","name","alias","flags","flagArgs","BlockNode","statements","index","run","statement","result","SelectorNode","selectorText","BehaviorNode","selector","body","OnBlockNode","eventName","args","AssignmentNode","target","operator","prefix","DirectiveExpression","resolvedValue","ElementDirectiveExpression","elementValue","resolvedElement","element","resolveElementFromReference","IdentifierExpression","path","MemberExpression","IndexExpression","resolved","resolvedTarget","current","numeric","delta","isRoot","rawPath","resolvedPath","targetExpr","basePath","resolvedBase","expr","base","indexValue","resolvedIndex","ElementPropertyExpression","ArrayPattern","source","RestElement","ObjectPattern","usedKeys","entry","rest","key","classes","normalizeClassList","checked","ReturnNode","nextValue","BreakNode","ContinueNode","AssertError","message","AssertNode","test","IfNode","consequent","alternate","condition","WhileNode","bodyResult","ForEachNode","iterable","kind","iterableValue","entries","bodyScope","loop","ForNode","init","update","initResult","testResult","passed","updateResult","TryNode","errorName","handler","handleError","error","handlerScope","previous","handlerResult","FunctionDeclarationNode","params","isAsync","FunctionExpression","globals","activeScope","inner","previousValues","applyResult","finalResult","setPath","applyAt","paramIndex","argIndex","i","param","defaultValue","resolvedDefault","DeclarationNode","root","ElementRefExpression","id","doc","engine","SpreadElement","elements","LiteralExpression","TemplateExpression","parts","part","UnaryExpression","argument","BinaryExpression","left","right","leftValue","resolvedLeft","rightValue","resolvedRight","TernaryExpression","_MemberExpression","property","optional","resolvedGlobal","targetPath","localPath","parent","CallExpression","callee","resolvedCallee","fnValue","resolvedFn","values","evalArgs","argValue","resolvedArg","parentPath","methodName","parentValue","ArrayExpression","pushElements","evalAt","spreadValue","resolvedSpread","ObjectExpression","keyValue","resolvedKey","entryValue","directive","nextContext","candidate","AwaitExpression","QueryExpression","direction","results","cursor","TokenStream","tokens","offset","token","type","count","i","openType","closeType","first","index","depth","Parser","_Parser","input","options","lexer","Lexer","TokenStream","code","behaviors","uses","next","ProgramNode","selector","flags","flagArgs","body","BehaviorNode","selectorText","sawNonWhitespace","token","SelectorNode","result","name","alias","UseNode","timeoutToken","timeoutMs","intervalMs","intervalToken","fn","error","message","line","column","snippet","content","caret","allowDeclarations","allowReturn","statements","declarationsOpen","sawConstruct","sawFunctionOrOn","sawNestedBehavior","BlockNode","allowBlocks","event","args","OnBlockNode","target","operator","value","AssignmentNode","expr","awaitStage","stage","call","AwaitExpression","CallExpression","IdentifierExpression","MemberExpression","test","consequent","alternate","TernaryExpression","right","BinaryExpression","left","op","argument","UnaryExpression","prefix","IndexExpression","DirectiveExpression","ElementDirectiveExpression","LiteralExpression","argToken","chained","directive","ElementRefExpression","ElementPropertyExpression","index","kind","id","elements","SpreadElement","ArrayExpression","parts","literal","TemplateExpression","entries","entry","keyExpr","key","ObjectExpression","allowAwait","expression","ReturnNode","sawRest","RestElement","ArrayPattern","rest","valueToken","patternEntries","ObjectPattern","DeclarationNode","allowed","errorLabel","customArg","items","obj","first","second","third","indexAfter","stack","indexAfterParams","nested","IfNode","statement","WhileNode","eachKind","keyword","iterable","ForEachNode","init","update","ForNode","offset","depth","errorName","handler","TryNode","direction","QueryExpression","isAsync","params","FunctionDeclarationNode","AssertNode","BreakNode","ContinueNode","FunctionExpression","defaultValue","terminator","part","Scope","_Scope","parent","key","value","path","root","explicit","targetScope","targetPath","localValue","cursor","scopeForSet","parts","obj","i","lastKey","handler","set","fn","rootKey","scope","start","getElementValue","element","setElementValue","value","applyBindToScope","expression","scope","key","applyBindToElement","readCondition","expression","scope","key","applyIf","element","applyShow","applyHtml","element","expression","scope","key","value","html","applyGet","element","config","scope","onHtmlApplied","response","html","target","resolveTarget","wrapper","applyHtml","replacement","selector","debounce","fn","waitMs","timer","args","Engine","_Engine","options","args","event","element","target","items","fn","results","initial","hasInitial","acc","start","i","_context","value","scope","rootScope","behavior","key","targetScope","existing","list","proxy","next","entry","parentElement","cached","_target","prop","root","documentRoot","active","elements","parentScope","source","program","Parser","use","name","values","handler","parts","part","pending","config","timeoutMs","initialDelayMs","maxDelayMs","resolve","elapsedMs","delayMs","check","scheduledDelay","Scope","bindConfig","applyBindToElement","ifExpr","applyIf","showExpr","applyShow","htmlBinding","applyHtml","debounce","mutations","mutation","node","removed","updated","added","child","bound","matched","a","b","matchedIds","onBlock","listenerMap","listeners","listener","patch","current","listPart","rest","listExpr","names","itemName","indexName","binding","parent","rendered","item","index","fragment","roots","itemScope","expr","applyBindToScope","direction","num","cursor","set","debounceMs","effectiveHandler","kind","watchers","watcher","eventWithFlags","flags","flagMap","flagArgs","raw","trimmed","match","tag","id","classes","type","error","selector","listenerTarget","body","behaviorId","evt","previousValues","argName","nextArg","failed","autoLoad","applyGet","nextArgs","flag","modifierChecks","keyAliases","expectedKey","code","block","context","parentSelector","rootSelectorOverride","rootSelector","behaviorHash","hash","statement","BehaviorNode","OnBlockNode","BlockNode","idMatches","classMatches","attrMatches","pseudoMatches","elementMatches","rootElement","declaration","IdentifierExpression","DirectiveExpression","construct","destruct","blocks","declarations","DeclarationNode","functions","FunctionDeclarationNode","AssignmentNode","FunctionExpression","lifecycle","fresh","normalized","json","param","arg","callScope","params","argIndex","operator","transform","importantKey","transformed","exprIdentifier","shouldWatch","nextValue","hook","callback","watch","useRoot","sourceScope","localExpr","watchExpr","targetExpr","html","checked","scripts","script","parsedDirection","auto","_name","url","swap","onConfig","VERSION","parseCFS","source","Parser","autoMount","root","engine","Engine","startTime","mount","target","plugins","plugin","sources","script","endTime","elapsedMs","VERSION"]}