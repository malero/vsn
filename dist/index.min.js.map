{"version":3,"sources":["../src/parser/token.ts","../src/parser/lexer.ts","../src/ast/nodes.ts","../src/parser/token-stream.ts","../src/parser/parser.ts","../src/runtime/scope.ts","../src/runtime/bindings.ts","../src/runtime/conditionals.ts","../src/runtime/html.ts","../src/runtime/http.ts","../src/runtime/debounce.ts","../src/runtime/engine.ts","../src/index.ts"],"sourcesContent":["export enum TokenType {\n  Whitespace = \"Whitespace\",\n  Identifier = \"Identifier\",\n  Number = \"Number\",\n  String = \"String\",\n  Boolean = \"Boolean\",\n  Null = \"Null\",\n\n  Behavior = \"Behavior\",\n  Use = \"Use\",\n  State = \"State\",\n  On = \"On\",\n  Construct = \"Construct\",\n  Destruct = \"Destruct\",\n  Return = \"Return\",\n\n  LBrace = \"LBrace\",\n  RBrace = \"RBrace\",\n  LParen = \"LParen\",\n  RParen = \"RParen\",\n  LBracket = \"LBracket\",\n  RBracket = \"RBracket\",\n\n  Colon = \"Colon\",\n  Semicolon = \"Semicolon\",\n  Comma = \"Comma\",\n\n  Dot = \"Dot\",\n  Hash = \"Hash\",\n  Greater = \"Greater\",\n  Less = \"Less\",\n  Plus = \"Plus\",\n  Minus = \"Minus\",\n  Tilde = \"Tilde\",\n  Star = \"Star\",\n\n  Equals = \"Equals\",\n  Arrow = \"Arrow\",\n  DoubleEquals = \"DoubleEquals\",\n  NotEquals = \"NotEquals\",\n  LessEqual = \"LessEqual\",\n  GreaterEqual = \"GreaterEqual\",\n  And = \"And\",\n  Or = \"Or\",\n  Bang = \"Bang\",\n\n  At = \"At\",\n  Dollar = \"Dollar\",\n  Question = \"Question\"\n}\n\nexport interface Position {\n  index: number;\n  line: number;\n  column: number;\n}\n\nexport interface Token {\n  type: TokenType;\n  value: string;\n  start: Position;\n  end: Position;\n}\n","import { Token, TokenType } from \"./token\";\n\nconst KEYWORDS: Record<string, TokenType> = {\n  behavior: TokenType.Behavior,\n  use: TokenType.Use,\n  state: TokenType.State,\n  on: TokenType.On,\n  construct: TokenType.Construct,\n  destruct: TokenType.Destruct,\n  return: TokenType.Return,\n  true: TokenType.Boolean,\n  false: TokenType.Boolean,\n  null: TokenType.Null\n};\n\nexport class Lexer {\n  private index = 0;\n  private line = 1;\n  private column = 1;\n\n  constructor(private input: string) {}\n\n  tokenize(): Token[] {\n    const tokens: Token[] = [];\n\n    while (!this.eof()) {\n      const ch = this.peek();\n\n      if (this.isWhitespace(ch)) {\n        tokens.push(this.readWhitespace());\n        continue;\n      }\n\n      if (ch === \"/\" && this.peek(1) === \"/\") {\n        this.readLineComment();\n        continue;\n      }\n\n      if (ch === \"/\" && this.peek(1) === \"*\") {\n        this.readBlockComment();\n        continue;\n      }\n\n      if (this.isAlpha(ch) || ch === \"_\") {\n        tokens.push(this.readIdentifier());\n        continue;\n      }\n\n      if (this.isDigit(ch) || (ch === \"-\" && this.isDigit(this.peek(1)))) {\n        tokens.push(this.readNumber());\n        continue;\n      }\n\n      if (ch === \"\\\"\" || ch === \"'\") {\n        tokens.push(this.readString());\n        continue;\n      }\n\n      const punct = this.readPunctuator();\n      if (punct) {\n        tokens.push(punct);\n        continue;\n      }\n\n      throw new Error(`Unexpected character '${ch}' at ${this.line}:${this.column}`);\n    }\n\n    return tokens;\n  }\n\n  private readWhitespace(): Token {\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof() && this.isWhitespace(this.peek())) {\n      value += this.next();\n    }\n    return this.token(TokenType.Whitespace, value, start);\n  }\n\n  private readLineComment(): void {\n    this.next();\n    this.next();\n    while (!this.eof() && this.peek() !== \"\\n\") {\n      this.next();\n    }\n  }\n\n  private readBlockComment(): void {\n    this.next();\n    this.next();\n    while (!this.eof()) {\n      if (this.peek() === \"*\" && this.peek(1) === \"/\") {\n        this.next();\n        this.next();\n        return;\n      }\n      this.next();\n    }\n  }\n\n  private readIdentifier(): Token {\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof() && (this.isAlphaNumeric(this.peek()) || this.peek() === \"_\" || this.peek() === \"-\")) {\n      value += this.next();\n    }\n\n    const keywordType = KEYWORDS[value];\n    if (keywordType) {\n      return this.token(keywordType, value, start);\n    }\n\n    return this.token(TokenType.Identifier, value, start);\n  }\n\n  private readNumber(): Token {\n    const start = this.position();\n    let value = \"\";\n    if (this.peek() === \"-\") {\n      value += this.next();\n    }\n    while (!this.eof() && this.isDigit(this.peek())) {\n      value += this.next();\n    }\n    if (this.peek() === \".\") {\n      value += this.next();\n      while (!this.eof() && this.isDigit(this.peek())) {\n        value += this.next();\n      }\n    }\n    return this.token(TokenType.Number, value, start);\n  }\n\n  private readString(): Token {\n    const quote = this.next();\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof()) {\n      const ch = this.next();\n      if (ch === \"\\\\\") {\n        const escaped = this.next();\n        value += escaped;\n        continue;\n      }\n      if (ch === quote) {\n        return this.token(TokenType.String, value, start);\n      }\n      value += ch;\n    }\n    throw new Error(`Unterminated string at ${start.line}:${start.column}`);\n  }\n\n  private readPunctuator(): Token | null {\n    const start = this.position();\n    const ch = this.peek();\n    const next = this.peek(1);\n\n    if (ch === \"=\" && next === \"=\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.DoubleEquals, \"==\", start);\n    }\n    if (ch === \"=\" && next === \">\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.Arrow, \"=>\", start);\n    }\n    if (ch === \"!\" && next === \"=\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.NotEquals, \"!=\", start);\n    }\n    if (ch === \"<\" && next === \"=\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.LessEqual, \"<=\", start);\n    }\n    if (ch === \">\" && next === \"=\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.GreaterEqual, \">=\", start);\n    }\n    if (ch === \"&\" && next === \"&\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.And, \"&&\", start);\n    }\n    if (ch === \"|\" && next === \"|\") {\n      this.next();\n      this.next();\n      return this.token(TokenType.Or, \"||\", start);\n    }\n    const punctMap: Record<string, TokenType> = {\n      \"{\": TokenType.LBrace,\n      \"}\": TokenType.RBrace,\n      \"(\": TokenType.LParen,\n      \")\": TokenType.RParen,\n      \"[\": TokenType.LBracket,\n      \"]\": TokenType.RBracket,\n      \":\": TokenType.Colon,\n      \";\": TokenType.Semicolon,\n      \",\": TokenType.Comma,\n      \".\": TokenType.Dot,\n      \"#\": TokenType.Hash,\n      \">\": TokenType.Greater,\n      \"<\": TokenType.Less,\n      \"+\": TokenType.Plus,\n      \"-\": TokenType.Minus,\n      \"~\": TokenType.Tilde,\n      \"*\": TokenType.Star,\n      \"=\": TokenType.Equals,\n      \"!\": TokenType.Bang,\n      \"@\": TokenType.At,\n      \"$\": TokenType.Dollar,\n      \"?\": TokenType.Question\n    };\n\n    const type = punctMap[ch];\n    if (!type) {\n      return null;\n    }\n\n    this.next();\n    return this.token(type, ch, start);\n  }\n\n  private token(type: TokenType, value: string, start: { index: number; line: number; column: number }): Token {\n    return {\n      type,\n      value,\n      start,\n      end: this.position()\n    };\n  }\n\n  private position() {\n    return { index: this.index, line: this.line, column: this.column };\n  }\n\n  private peek(offset = 0): string {\n    return this.input[this.index + offset] ?? \"\";\n  }\n\n  private next(): string {\n    const ch = this.input[this.index++] ?? \"\";\n    if (ch === \"\\n\") {\n      this.line += 1;\n      this.column = 1;\n    } else {\n      this.column += 1;\n    }\n    return ch;\n  }\n\n  private eof(): boolean {\n    return this.index >= this.input.length;\n  }\n\n  private isWhitespace(ch: string): boolean {\n    return ch === \" \" || ch === \"\\t\" || ch === \"\\n\" || ch === \"\\r\";\n  }\n\n  private isAlpha(ch: string): boolean {\n    return (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\");\n  }\n\n  private isDigit(ch: string): boolean {\n    return ch >= \"0\" && ch <= \"9\";\n  }\n\n  private isAlphaNumeric(ch: string): boolean {\n    return this.isAlpha(ch) || this.isDigit(ch);\n  }\n}\n","export interface ExecutionContext {\n  scope?: {\n    getPath(key: string): any;\n    setPath?(key: string, value: any): void;\n  };\n  globals?: Record<string, any>;\n  element?: Element;\n  returnValue?: any;\n  returning?: boolean;\n}\n\nexport interface CFSNode {\n  type: string;\n  prepare(context: ExecutionContext): Promise<void>;\n  evaluate(context: ExecutionContext): Promise<any>;\n}\n\nexport abstract class BaseNode implements CFSNode {\n  constructor(public type: string) {}\n\n  async prepare(_context: ExecutionContext): Promise<void> {\n    return;\n  }\n\n  async evaluate(_context: ExecutionContext): Promise<any> {\n    return undefined;\n  }\n}\n\nexport class ProgramNode extends BaseNode {\n  constructor(public behaviors: BehaviorNode[], public uses: UseNode[] = []) {\n    super(\"Program\");\n  }\n}\n\nexport class UseNode extends BaseNode {\n  constructor(public name: string, public alias: string) {\n    super(\"Use\");\n  }\n}\n\nexport class BlockNode extends BaseNode {\n  constructor(public statements: CFSNode[]) {\n    super(\"Block\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    for (const statement of this.statements) {\n      if (context.returning) {\n        break;\n      }\n      if (statement && typeof statement.evaluate === \"function\") {\n        await statement.evaluate(context);\n      }\n    }\n  }\n}\n\nexport class SelectorNode extends BaseNode {\n  constructor(public selectorText: string) {\n    super(\"Selector\");\n  }\n}\n\nexport class BehaviorNode extends BaseNode {\n  constructor(public selector: SelectorNode, public body: BlockNode) {\n    super(\"Behavior\");\n  }\n}\n\nexport class StateEntryNode extends BaseNode {\n  constructor(\n    public name: string,\n    public value: ExpressionNode,\n    public important: boolean\n  ) {\n    super(\"StateEntry\");\n  }\n}\n\nexport class StateBlockNode extends BaseNode {\n  constructor(public entries: StateEntryNode[]) {\n    super(\"StateBlock\");\n  }\n}\n\nexport class OnBlockNode extends BaseNode {\n  constructor(\n    public eventName: string,\n    public args: string[],\n    public body: BlockNode,\n    public modifiers: string[] = []\n  ) {\n    super(\"OnBlock\");\n  }\n}\n\nexport class AssignmentNode extends BaseNode {\n  constructor(public target: AssignmentTarget, public value: ExpressionNode) {\n    super(\"Assignment\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    if (!context.scope || !context.scope.setPath) {\n      return undefined;\n    }\n    let targetPath: string | undefined;\n    if (this.target instanceof IdentifierExpression) {\n      targetPath = this.target.name;\n    }\n    if (!targetPath) {\n      return undefined;\n    }\n    const value = await this.value.evaluate(context);\n    context.scope.setPath(targetPath, value);\n    return value;\n  }\n}\n\nexport class ReturnNode extends BaseNode {\n  constructor(public value?: ExpressionNode) {\n    super(\"Return\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    if (context.returning) {\n      return context.returnValue;\n    }\n    context.returnValue = this.value ? await this.value.evaluate(context) : undefined;\n    context.returning = true;\n    return context.returnValue;\n  }\n}\n\nexport class FunctionDeclarationNode extends BaseNode {\n  constructor(public name: string, public params: string[], public body: BlockNode) {\n    super(\"FunctionDeclaration\");\n  }\n}\n\nexport class FunctionExpression extends BaseNode {\n  constructor(public params: string[], public body: BlockNode) {\n    super(\"FunctionExpression\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    const scope = context.scope;\n    const globals = context.globals;\n    const element = context.element;\n    return async (...args: any[]) => {\n      const inner: ExecutionContext = {\n        ...(scope ? { scope } : {}),\n        ...(globals ? { globals } : {}),\n        ...(element ? { element } : {}),\n        returnValue: undefined,\n        returning: false\n      };\n      if (scope) {\n        const previousValues = new Map<string, any>();\n        for (let i = 0; i < this.params.length; i += 1) {\n          const name = this.params[i];\n          if (!name) {\n            continue;\n          }\n          previousValues.set(name, scope.getPath(name));\n          if (scope.setPath) {\n            scope.setPath(name, args[i]);\n          }\n        }\n        await this.body.evaluate(inner);\n        for (const name of this.params) {\n          if (!name || !scope.setPath) {\n            continue;\n          }\n          scope.setPath(name, previousValues.get(name));\n        }\n      } else {\n        await this.body.evaluate(inner);\n      }\n      return inner.returnValue;\n    };\n  }\n}\n\nexport interface DeclarationFlags {\n  important?: boolean;\n  trusted?: boolean;\n  debounce?: boolean;\n  [key: string]: boolean | undefined;\n}\n\nexport interface DeclarationFlagArgs {\n  debounce?: number;\n  [key: string]: any;\n}\n\nexport class DeclarationNode extends BaseNode {\n  constructor(\n    public target: DeclarationTarget,\n    public operator: \":\" | \":=\" | \":<\" | \":>\",\n    public value: ExpressionNode,\n    public flags: DeclarationFlags,\n    public flagArgs: DeclarationFlagArgs\n  ) {\n    super(\"Declaration\");\n  }\n}\n\nexport type ExpressionNode =\n  | IdentifierExpression\n  | LiteralExpression\n  | UnaryExpression\n  | BinaryExpression\n  | CallExpression\n  | ArrayExpression\n  | IndexExpression\n  | FunctionExpression\n  | TernaryExpression\n  | DirectiveExpression\n  | QueryExpression;\n\nexport type DeclarationTarget = IdentifierExpression | DirectiveExpression;\nexport type AssignmentTarget = IdentifierExpression | DirectiveExpression;\n\nexport class IdentifierExpression extends BaseNode {\n  constructor(public name: string) {\n    super(\"Identifier\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    if (!context.scope) {\n      return undefined;\n    }\n    return context.scope.getPath(this.name);\n  }\n}\n\nexport class LiteralExpression extends BaseNode {\n  constructor(public value: string | number | boolean | null) {\n    super(\"Literal\");\n  }\n\n  async evaluate(): Promise<any> {\n    return this.value;\n  }\n}\n\nexport class UnaryExpression extends BaseNode {\n  constructor(public operator: string, public argument: ExpressionNode) {\n    super(\"UnaryExpression\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    const value = await this.argument.evaluate(context);\n    if (this.operator === \"!\") {\n      return !value;\n    }\n    if (this.operator === \"-\") {\n      return -(value as any);\n    }\n    return value;\n  }\n}\n\nexport class BinaryExpression extends BaseNode {\n  constructor(\n    public operator: string,\n    public left: ExpressionNode,\n    public right: ExpressionNode\n  ) {\n    super(\"BinaryExpression\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    if (this.operator === \"&&\") {\n      const leftValue = await this.left.evaluate(context);\n      return leftValue && (await this.right.evaluate(context));\n    }\n    if (this.operator === \"||\") {\n      const leftValue = await this.left.evaluate(context);\n      return leftValue || (await this.right.evaluate(context));\n    }\n    const left = await this.left.evaluate(context);\n    const right = await this.right.evaluate(context);\n    if (this.operator === \"+\") {\n      return (left as any) + (right as any);\n    }\n    if (this.operator === \"-\") {\n      return (left as any) - (right as any);\n    }\n    if (this.operator === \"==\") {\n      return left == right;\n    }\n    if (this.operator === \"!=\") {\n      return left != right;\n    }\n    if (this.operator === \"<\") {\n      return (left as any) < (right as any);\n    }\n    if (this.operator === \">\") {\n      return (left as any) > (right as any);\n    }\n    if (this.operator === \"<=\") {\n      return (left as any) <= (right as any);\n    }\n    if (this.operator === \">=\") {\n      return (left as any) >= (right as any);\n    }\n    return undefined;\n  }\n}\n\nexport class TernaryExpression extends BaseNode {\n  constructor(\n    public test: ExpressionNode,\n    public consequent: ExpressionNode,\n    public alternate: ExpressionNode\n  ) {\n    super(\"TernaryExpression\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    const condition = await this.test.evaluate(context);\n    if (condition) {\n      return this.consequent.evaluate(context);\n    }\n    return this.alternate.evaluate(context);\n  }\n}\n\nexport class CallExpression extends BaseNode {\n  constructor(public callee: ExpressionNode, public args: ExpressionNode[]) {\n    super(\"CallExpression\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    const resolved = this.resolveCallee(context);\n    const fn = resolved?.fn ?? (await this.callee.evaluate(context));\n    if (typeof fn !== \"function\") {\n      return undefined;\n    }\n    const values = [];\n    for (const arg of this.args) {\n      values.push(await arg.evaluate(context));\n    }\n    return fn.apply(resolved?.thisArg, values);\n  }\n\n  private resolveCallee(\n    context: ExecutionContext\n  ): { fn: any; thisArg?: any } | undefined {\n    if (!(this.callee instanceof IdentifierExpression)) {\n      return undefined;\n    }\n    const name = this.callee.name;\n    const globals = context.globals ?? {};\n    const parts = name.split(\".\");\n    const root = parts[0];\n    if (!root || !(root in globals)) {\n      if (parts.length > 1 && context.scope) {\n        const parentPath = parts.slice(0, -1).join(\".\");\n        const methodName = parts[parts.length - 1];\n        if (!methodName) {\n          return undefined;\n        }\n        const parentValue = context.scope.getPath(parentPath);\n        if (parentValue == null) {\n          return undefined;\n        }\n        return { fn: parentValue?.[methodName], thisArg: parentValue };\n      }\n      return undefined;\n    }\n    let value = globals[root];\n    let parent: any = undefined;\n    for (let i = 1; i < parts.length; i += 1) {\n      parent = value;\n      const part = parts[i];\n      if (!part) {\n        return undefined;\n      }\n      value = value?.[part];\n    }\n    return { fn: value, thisArg: parent };\n  }\n}\n\nexport class ArrayExpression extends BaseNode {\n  constructor(public elements: ExpressionNode[]) {\n    super(\"ArrayExpression\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    const values: any[] = [];\n    for (const element of this.elements) {\n      values.push(await element.evaluate(context));\n    }\n    return values;\n  }\n}\n\nexport class IndexExpression extends BaseNode {\n  constructor(public target: ExpressionNode, public index: ExpressionNode) {\n    super(\"IndexExpression\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    const target = await this.target.evaluate(context);\n    if (target == null) {\n      return undefined;\n    }\n    const index = await this.index.evaluate(context);\n    if (index == null) {\n      return undefined;\n    }\n    return (target as any)[index as any];\n  }\n}\n\nexport class DirectiveExpression extends BaseNode {\n  constructor(public kind: \"attr\" | \"style\", public name: string) {\n    super(\"Directive\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    const element = context.element;\n    if (!element) {\n      return `${this.kind}:${this.name}`;\n    }\n    if (this.kind === \"attr\") {\n      if (this.name === \"value\") {\n        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n          return element.value;\n        }\n        if (element instanceof HTMLSelectElement) {\n          return element.value;\n        }\n      }\n      if (this.name === \"checked\" && element instanceof HTMLInputElement) {\n        return element.checked;\n      }\n      if (this.name === \"html\" && element instanceof HTMLElement) {\n        return element.innerHTML;\n      }\n      return element.getAttribute(this.name) ?? undefined;\n    }\n    if (this.kind === \"style\" && element instanceof HTMLElement) {\n      return element.style.getPropertyValue(this.name) ?? undefined;\n    }\n    return undefined;\n  }\n}\n\nexport class QueryExpression extends BaseNode {\n  constructor(public direction: \"self\" | \"descendant\" | \"ancestor\", public selector: string) {\n    super(\"Query\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    const selector = this.selector.trim();\n    if (!selector) {\n      return [];\n    }\n    if (this.direction === \"ancestor\") {\n      const results: Element[] = [];\n      let cursor = context.element?.parentElement;\n      while (cursor) {\n        if (cursor.matches(selector)) {\n          results.push(cursor);\n        }\n        cursor = cursor.parentElement;\n      }\n      return results;\n    }\n    const root = this.direction === \"descendant\"\n      ? context.element ?? (typeof document !== \"undefined\" ? document : undefined)\n      : (typeof document !== \"undefined\" ? document : undefined);\n    if (!root || !(\"querySelectorAll\" in root)) {\n      return [];\n    }\n    return Array.from((root as ParentNode).querySelectorAll(selector));\n  }\n}\n","import { Token, TokenType } from \"./token\";\n\nexport class TokenStream {\n  private index = 0;\n\n  constructor(private tokens: Token[]) {}\n\n  peek(offset = 0): Token | null {\n    return this.tokens[this.index + offset] ?? null;\n  }\n\n  next(): Token {\n    const token = this.tokens[this.index++];\n    if (!token) {\n      throw new Error(\"Unexpected end of input\");\n    }\n    return token;\n  }\n\n  eof(): boolean {\n    return this.index >= this.tokens.length;\n  }\n\n  match(type: TokenType): boolean {\n    if (this.peek()?.type === type) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n\n  expect(type: TokenType): Token {\n    const token = this.next();\n    if (token.type !== type) {\n      throw new Error(`Expected ${type} but got ${token.type}`);\n    }\n    return token;\n  }\n\n  skipWhitespace(): void {\n    while (this.peek()?.type === TokenType.Whitespace) {\n      this.next();\n    }\n  }\n\n  peekNonWhitespace(offset = 0): Token | null {\n    let count = 0;\n    for (let i = this.index; i < this.tokens.length; i++) {\n      const token = this.tokens[i];\n      if (token.type === TokenType.Whitespace) {\n        continue;\n      }\n      if (count === offset) {\n        return token;\n      }\n      count += 1;\n    }\n    return null;\n  }\n}\n","import {\n  AssignmentNode,\n  ArrayExpression,\n  BehaviorNode,\n  BinaryExpression,\n  BlockNode,\n  AssignmentTarget,\n  CallExpression,\n  DeclarationNode,\n  DeclarationTarget,\n  DeclarationFlags,\n  DeclarationFlagArgs,\n  DirectiveExpression,\n  FunctionDeclarationNode,\n  FunctionExpression,\n  IdentifierExpression,\n  LiteralExpression,\n  OnBlockNode,\n  ProgramNode,\n  QueryExpression,\n  ReturnNode,\n  SelectorNode,\n  StateBlockNode,\n  StateEntryNode,\n  TernaryExpression,\n  UnaryExpression,\n  UseNode,\n  IndexExpression,\n  ExpressionNode\n} from \"../ast/nodes\";\nimport { Lexer } from \"./lexer\";\nimport { TokenStream } from \"./token-stream\";\nimport { TokenType } from \"./token\";\n\nexport class Parser {\n  private stream: TokenStream;\n  private source: string;\n  private customFlags: Set<string>;\n  private allowImplicitSemicolon = false;\n\n  constructor(input: string, options?: { customFlags?: Set<string> }) {\n    this.source = input;\n    this.customFlags = options?.customFlags ?? new Set<string>();\n    const lexer = new Lexer(input);\n    this.stream = new TokenStream(lexer.tokenize());\n  }\n\n  static parseInline(code: string): BlockNode {\n    const parser = new Parser(`{${code}}`);\n    return parser.parseInlineBlock();\n  }\n\n  parseProgram(): ProgramNode {\n    return this.wrapErrors(() => {\n      const behaviors: BehaviorNode[] = [];\n      const uses: UseNode[] = [];\n      this.stream.skipWhitespace();\n      while (!this.stream.eof()) {\n        const next = this.stream.peek();\n        if (!next) {\n          break;\n        }\n        if (next.type === TokenType.Use) {\n          uses.push(this.parseUseStatement());\n        } else {\n          behaviors.push(this.parseBehavior());\n        }\n        this.stream.skipWhitespace();\n      }\n      return new ProgramNode(behaviors, uses);\n    });\n  }\n\n  parseInlineBlock(): BlockNode {\n    return this.wrapErrors(() => {\n      this.stream.skipWhitespace();\n      this.allowImplicitSemicolon = true;\n      return this.parseBlock({ allowDeclarations: false });\n    });\n  }\n\n  private parseBehavior(): BehaviorNode {\n    return this.wrapErrors(() => {\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Behavior);\n      const selector = this.parseSelector();\n      const body = this.parseBlock({ allowDeclarations: true });\n      return new BehaviorNode(selector, body);\n    });\n  }\n\n  private parseSelector(): SelectorNode {\n    let selectorText = \"\";\n    let sawNonWhitespace = false;\n\n    while (true) {\n      const token = this.stream.peek();\n      if (!token) {\n        break;\n      }\n\n      if (token.type === TokenType.LBrace) {\n        break;\n      }\n\n      if (token.type === TokenType.Whitespace) {\n        this.stream.next();\n        if (sawNonWhitespace && selectorText[selectorText.length - 1] !== \" \") {\n          selectorText += \" \";\n        }\n        continue;\n      }\n\n      sawNonWhitespace = true;\n      selectorText += this.stream.next().value;\n    }\n\n    if (!selectorText.trim()) {\n      throw new Error(\"Behavior selector is required\");\n    }\n\n    return new SelectorNode(selectorText.trim());\n  }\n\n  private parseUseStatement(): UseNode {\n    return this.wrapErrors(() => {\n      this.stream.expect(TokenType.Use);\n      this.stream.skipWhitespace();\n      const name = this.parseIdentifierPath();\n      this.stream.skipWhitespace();\n      let alias = name;\n      const next = this.stream.peek();\n      if (next?.type === TokenType.Identifier && next.value === \"as\") {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        alias = this.stream.expect(TokenType.Identifier).value;\n      }\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Semicolon);\n      return new UseNode(name, alias);\n    });\n  }\n\n  private wrapErrors<T>(fn: () => T): T {\n    try {\n      return fn();\n    } catch (error) {\n      if (error instanceof Error && !/\\(line\\s+\\d+, column\\s+\\d+\\)/i.test(error.message)) {\n        throw new Error(this.formatError(error.message));\n      }\n      throw error;\n    }\n  }\n\n  private formatError(message: string): string {\n    const token = this.stream.peek() ?? this.stream.peekNonWhitespace(0);\n    if (!token) {\n      return `Parse error: ${message}`;\n    }\n    const line = token.start.line;\n    const column = token.start.column;\n    const snippet = this.getLineSnippet(line, column);\n    return `Parse error (line ${line}, column ${column}): ${message}\\n${snippet}`;\n  }\n\n  private getLineSnippet(line: number, column: number): string {\n    const lines = this.source.split(/\\r?\\n/);\n    const content = lines[line - 1] ?? \"\";\n    const caret = `${\" \".repeat(Math.max(column - 1, 0))}^`;\n    return `${content}\\n${caret}`;\n  }\n\n  private parseBlock(options?: { allowDeclarations?: boolean }): BlockNode {\n    const allowDeclarations = options?.allowDeclarations ?? false;\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LBrace);\n    const statements = [];\n    let declarationsOpen = allowDeclarations;\n    let sawConstruct = false;\n    let sawFunctionOrOn = false;\n\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated block\");\n      }\n      if (next.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n\n      const isFunctionDeclaration = allowDeclarations && this.isFunctionDeclarationStart();\n      if (isFunctionDeclaration) {\n        if (!sawConstruct) {\n          sawFunctionOrOn = true;\n        }\n        statements.push(this.parseFunctionDeclaration());\n        continue;\n      }\n      const isFunctionExpressionAssignment = allowDeclarations && this.isFunctionExpressionAssignmentStart();\n      if (isFunctionExpressionAssignment) {\n        if (!declarationsOpen) {\n          throw new Error(\"Declarations must appear before blocks\");\n        }\n        statements.push(this.parseAssignment());\n        continue;\n      }\n      const isDeclaration = this.isDeclarationStart();\n      if (isDeclaration) {\n        if (!allowDeclarations) {\n          throw new Error(\"Declarations are only allowed at the behavior root\");\n        }\n        if (!declarationsOpen) {\n          throw new Error(\"Declarations must appear before blocks\");\n        }\n        statements.push(this.parseDeclaration());\n      } else {\n        if (declarationsOpen) {\n          declarationsOpen = false;\n        }\n        if (allowDeclarations && next.type === TokenType.On && !sawConstruct) {\n          sawFunctionOrOn = true;\n        }\n        if (allowDeclarations && next.type === TokenType.Construct) {\n          if (sawFunctionOrOn) {\n            throw new Error(\"Construct blocks must appear before functions and on blocks\");\n          }\n          sawConstruct = true;\n        }\n        statements.push(this.parseStatement());\n      }\n    }\n\n    return new BlockNode(statements);\n  }\n\n  private parseStatement(options?: { allowBlocks?: boolean; allowReturn?: boolean }) {\n    this.stream.skipWhitespace();\n    const next = this.stream.peek();\n    if (!next) {\n      throw new Error(\"Unexpected end of input\");\n    }\n\n    const allowBlocks = options?.allowBlocks ?? true;\n    const allowReturn = options?.allowReturn ?? false;\n\n    if (next.type === TokenType.Return) {\n      if (!allowReturn) {\n        throw new Error(\"Return is only allowed inside functions\");\n      }\n      return this.parseReturnStatement();\n    }\n\n    if (allowBlocks && next.type === TokenType.On) {\n      return this.parseOnBlock();\n    }\n\n    if (allowBlocks && next.type === TokenType.Construct) {\n      return this.parseConstructBlock();\n    }\n\n    if (allowBlocks && next.type === TokenType.Destruct) {\n      return this.parseDestructBlock();\n    }\n\n    if (allowBlocks && next.type === TokenType.Behavior) {\n      return this.parseBehavior();\n    }\n\n    if (this.isCallStart()) {\n      return this.parseExpressionStatement();\n    }\n\n    if (this.isAssignmentStart()) {\n      return this.parseAssignment();\n    }\n\n    throw new Error(`Unexpected token ${next.type}`);\n  }\n\n  private parseStateBlock(): StateBlockNode {\n    this.stream.expect(TokenType.State);\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LBrace);\n\n    const entries: StateEntryNode[] = [];\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated state block\");\n      }\n      if (next.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n\n      const nameToken = this.stream.expect(TokenType.Identifier);\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Colon);\n      this.stream.skipWhitespace();\n      const value = this.parseExpression();\n      this.stream.skipWhitespace();\n\n      let important = false;\n      if (this.stream.peek()?.type === TokenType.Bang) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const importantToken = this.stream.next();\n        if (importantToken.type === TokenType.Identifier && importantToken.value === \"important\") {\n          important = true;\n        } else {\n          throw new Error(\"Expected 'important' after '!'\");\n        }\n      }\n\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Semicolon);\n      entries.push(new StateEntryNode(nameToken.value, value, important));\n    }\n\n    return new StateBlockNode(entries);\n  }\n\n  private parseOnBlock(): OnBlockNode {\n    this.stream.expect(TokenType.On);\n    this.stream.skipWhitespace();\n    const event = this.stream.expect(TokenType.Identifier);\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    const args: string[] = [];\n\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated on() arguments\");\n      }\n      if (next.type === TokenType.RParen) {\n        this.stream.next();\n        break;\n      }\n      if (next.type === TokenType.Identifier) {\n        args.push(this.stream.next().value);\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.Comma) {\n          this.stream.next();\n        }\n        continue;\n      }\n      throw new Error(`Unexpected token in on() args: ${next.type}`);\n    }\n\n    const modifiers = this.parseOnModifiers();\n    const body = this.parseBlock({ allowDeclarations: false });\n    return new OnBlockNode(event.value, args, body, modifiers);\n  }\n\n  private parseOnModifiers(): string[] {\n    const modifiers: string[] = [];\n    while (true) {\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type !== TokenType.Bang) {\n        break;\n      }\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier).value;\n      modifiers.push(name);\n    }\n    return modifiers;\n  }\n\n  private parseAssignment(): AssignmentNode {\n    const target = this.parseAssignmentTarget();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Equals);\n    this.stream.skipWhitespace();\n    const value = this.parseExpression();\n    this.consumeStatementTerminator();\n    return new AssignmentNode(target, value);\n  }\n\n  private parseExpression(): ExpressionNode {\n    return this.parseTernaryExpression();\n  }\n\n  private parseTernaryExpression(): ExpressionNode {\n    let test = this.parseLogicalOrExpression();\n    this.stream.skipWhitespace();\n    if (this.stream.peek()?.type !== TokenType.Question) {\n      return test;\n    }\n    this.stream.next();\n    this.stream.skipWhitespace();\n    const consequent = this.parseExpression();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Colon);\n    this.stream.skipWhitespace();\n    const alternate = this.parseExpression();\n    return new TernaryExpression(test, consequent, alternate);\n  }\n\n  private parseLogicalOrExpression(): ExpressionNode {\n    let left = this.parseLogicalAndExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next || next.type !== TokenType.Or) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseLogicalAndExpression();\n      this.stream.skipWhitespace();\n      left = new BinaryExpression(\"||\", left, right);\n    }\n    return left;\n  }\n\n  private parseLogicalAndExpression(): ExpressionNode {\n    let left = this.parseEqualityExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next || next.type !== TokenType.And) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseEqualityExpression();\n      this.stream.skipWhitespace();\n      left = new BinaryExpression(\"&&\", left, right);\n    }\n    return left;\n  }\n\n  private parseEqualityExpression(): ExpressionNode {\n    let left = this.parseComparisonExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next || (next.type !== TokenType.DoubleEquals && next.type !== TokenType.NotEquals)) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      const op = this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseComparisonExpression();\n      this.stream.skipWhitespace();\n      left = new BinaryExpression(op.type === TokenType.DoubleEquals ? \"==\" : \"!=\", left, right);\n    }\n    return left;\n  }\n\n  private parseComparisonExpression(): ExpressionNode {\n    let left = this.parseAdditiveExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next) {\n        break;\n      }\n      if (next.type !== TokenType.Less &&\n          next.type !== TokenType.Greater &&\n          next.type !== TokenType.LessEqual &&\n          next.type !== TokenType.GreaterEqual) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      const op = this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseAdditiveExpression();\n      this.stream.skipWhitespace();\n      let operator = \"<\";\n      if (op.type === TokenType.Greater) {\n        operator = \">\";\n      } else if (op.type === TokenType.LessEqual) {\n        operator = \"<=\";\n      } else if (op.type === TokenType.GreaterEqual) {\n        operator = \">=\";\n      }\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n\n  private parseAdditiveExpression(): ExpressionNode {\n    let left = this.parseUnaryExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next || (next.type !== TokenType.Plus && next.type !== TokenType.Minus)) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      const op = this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseUnaryExpression();\n      this.stream.skipWhitespace();\n      left = new BinaryExpression(op.type === TokenType.Plus ? \"+\" : \"-\", left, right);\n    }\n    return left;\n  }\n\n  private parseUnaryExpression(): ExpressionNode {\n    this.stream.skipWhitespace();\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected expression\");\n    }\n    if (token.type === TokenType.Bang) {\n      this.stream.next();\n      const argument = this.parseUnaryExpression();\n      return new UnaryExpression(\"!\", argument);\n    }\n    if (token.type === TokenType.Minus) {\n      this.stream.next();\n      const argument = this.parseUnaryExpression();\n      return new UnaryExpression(\"-\", argument);\n    }\n    return this.parseCallExpression();\n  }\n\n  private parseCallExpression(): ExpressionNode {\n    let expr = this.parsePrimaryExpression();\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        break;\n      }\n      if (next.type === TokenType.LParen) {\n        this.stream.next();\n        const args: ExpressionNode[] = [];\n        while (true) {\n          this.stream.skipWhitespace();\n          const argToken = this.stream.peek();\n          if (!argToken) {\n            throw new Error(\"Unterminated call expression\");\n          }\n          if (argToken.type === TokenType.RParen) {\n            this.stream.next();\n            break;\n          }\n          args.push(this.parseExpression());\n          this.stream.skipWhitespace();\n          if (this.stream.peek()?.type === TokenType.Comma) {\n            this.stream.next();\n            continue;\n          }\n          if (this.stream.peek()?.type === TokenType.RParen) {\n            this.stream.next();\n            break;\n          }\n          throw new Error(\"Expected ',' or ')' in call arguments\");\n        }\n        expr = new CallExpression(expr, args);\n        continue;\n      }\n      if (next.type === TokenType.LBracket) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const index = this.parseExpression();\n        this.stream.skipWhitespace();\n        this.stream.expect(TokenType.RBracket);\n        expr = new IndexExpression(expr, index);\n        continue;\n      }\n      break;\n    }\n    return expr;\n  }\n\n  private parsePrimaryExpression(): ExpressionNode {\n    this.stream.skipWhitespace();\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected expression\");\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier);\n      return new DirectiveExpression(kind, name.value);\n    }\n\n    if (token.type === TokenType.Question) {\n      return this.parseQueryExpression();\n    }\n\n    if (token.type === TokenType.LBracket) {\n      return this.parseArrayExpression();\n    }\n\n    if (token.type === TokenType.LParen) {\n      if (this.isArrowFunctionStart()) {\n        return this.parseArrowFunctionExpression();\n      }\n      this.stream.next();\n      const value = this.parseExpression();\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.RParen);\n      return value;\n    }\n\n    if (token.type === TokenType.Identifier) {\n      const name = this.parseIdentifierPath();\n      return new IdentifierExpression(name);\n    }\n\n    if (token.type === TokenType.Boolean) {\n      return new LiteralExpression(this.stream.next().value === \"true\");\n    }\n\n    if (token.type === TokenType.Null) {\n      this.stream.next();\n      return new LiteralExpression(null);\n    }\n\n    if (token.type === TokenType.Number) {\n      return new LiteralExpression(Number(this.stream.next().value));\n    }\n\n    if (token.type === TokenType.String) {\n      return new LiteralExpression(this.stream.next().value);\n    }\n\n    throw new Error(`Unsupported expression token ${token.type}`);\n  }\n\n  private parseArrayExpression(): ExpressionNode {\n    this.stream.expect(TokenType.LBracket);\n    const elements: ExpressionNode[] = [];\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated array literal\");\n      }\n      if (next.type === TokenType.RBracket) {\n        this.stream.next();\n        break;\n      }\n      elements.push(this.parseExpression());\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.Comma) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.RBracket) {\n          this.stream.next();\n          break;\n        }\n        continue;\n      }\n      if (this.stream.peek()?.type === TokenType.RBracket) {\n        this.stream.next();\n        break;\n      }\n      throw new Error(\"Expected ',' or ']' in array literal\");\n    }\n    return new ArrayExpression(elements);\n  }\n\n  private consumeStatementTerminator(): void {\n    this.stream.skipWhitespace();\n    const next = this.stream.peek();\n    if (next?.type === TokenType.Semicolon) {\n      this.stream.next();\n      return;\n    }\n    if (this.allowImplicitSemicolon && next?.type === TokenType.RBrace) {\n      return;\n    }\n    this.stream.expect(TokenType.Semicolon);\n  }\n\n  private parseAssignmentTarget(): AssignmentTarget {\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected assignment target\");\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier);\n      return new DirectiveExpression(kind, name.value);\n    }\n\n    if (token.type === TokenType.Identifier) {\n      return new IdentifierExpression(this.parseIdentifierPath());\n    }\n\n    throw new Error(`Invalid assignment target ${token.type}`);\n  }\n\n  private parseDeclaration(): DeclarationNode {\n    const target = this.parseDeclarationTarget();\n    this.stream.skipWhitespace();\n    const operator = this.parseDeclarationOperator();\n    this.stream.skipWhitespace();\n    const value = this.parseExpression();\n    const { flags, flagArgs } = this.parseFlags();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Semicolon);\n    return new DeclarationNode(target, operator, value, flags, flagArgs);\n  }\n\n  private parseDeclarationTarget(): DeclarationTarget {\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected declaration target\");\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier);\n      return new DirectiveExpression(kind, name.value);\n    }\n\n    if (token.type === TokenType.Identifier) {\n      return new IdentifierExpression(this.stream.next().value);\n    }\n\n    throw new Error(`Invalid declaration target ${token.type}`);\n  }\n\n  private parseDeclarationOperator(): \":\" | \":=\" | \":<\" | \":>\" {\n    this.stream.expect(TokenType.Colon);\n    const next = this.stream.peek();\n    if (!next) {\n      return \":\";\n    }\n    if (next.type === TokenType.Equals) {\n      this.stream.next();\n      return \":=\";\n    }\n    if (next.type === TokenType.Less) {\n      this.stream.next();\n      return \":<\";\n    }\n    if (next.type === TokenType.Greater) {\n      this.stream.next();\n      return \":>\";\n    }\n    return \":\";\n  }\n\n  private parseFlags(): { flags: DeclarationFlags; flagArgs: DeclarationFlagArgs } {\n    const flags: DeclarationFlags = {};\n    const flagArgs: DeclarationFlagArgs = {};\n\n    while (true) {\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type !== TokenType.Bang) {\n        break;\n      }\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier).value;\n\n      if (name === \"important\") {\n        flags.important = true;\n      } else if (name === \"trusted\") {\n        flags.trusted = true;\n      } else if (name === \"debounce\") {\n        flags.debounce = true;\n        if (this.stream.peek()?.type === TokenType.LParen) {\n          this.stream.next();\n          this.stream.skipWhitespace();\n          const numberToken = this.stream.expect(TokenType.Number);\n          flagArgs.debounce = Number(numberToken.value);\n          this.stream.skipWhitespace();\n          this.stream.expect(TokenType.RParen);\n        } else {\n          flagArgs.debounce = 200;\n        }\n      } else if (this.customFlags.has(name)) {\n        (flags as Record<string, boolean>)[name] = true;\n        const customArg = this.parseCustomFlagArg();\n        if (customArg !== undefined) {\n          (flagArgs as Record<string, any>)[name] = customArg;\n        }\n      } else {\n        throw new Error(`Unknown flag ${name}`);\n      }\n    }\n\n    return { flags, flagArgs };\n  }\n\n  private parseCustomFlagArg(): any {\n    if (this.stream.peek()?.type !== TokenType.LParen) {\n      return undefined;\n    }\n    this.stream.next();\n    this.stream.skipWhitespace();\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Unterminated flag arguments\");\n    }\n    let value: any;\n    if (token.type === TokenType.Number) {\n      value = Number(this.stream.next().value);\n    } else if (token.type === TokenType.String) {\n      value = this.stream.next().value;\n    } else if (token.type === TokenType.Boolean) {\n      value = this.stream.next().value === \"true\";\n    } else if (token.type === TokenType.Identifier) {\n      value = this.stream.next().value;\n    } else {\n      throw new Error(`Unsupported flag argument ${token.type}`);\n    }\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.RParen);\n    return value;\n  }\n\n  private isDeclarationStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first) {\n      return false;\n    }\n\n    if (first.type === TokenType.Identifier) {\n      const second = this.stream.peekNonWhitespace(1);\n      return second?.type === TokenType.Colon;\n    }\n\n    if (first.type === TokenType.At || first.type === TokenType.Dollar) {\n      const second = this.stream.peekNonWhitespace(1);\n      const third = this.stream.peekNonWhitespace(2);\n      return second?.type === TokenType.Identifier && third?.type === TokenType.Colon;\n    }\n\n    return false;\n  }\n\n  private isAssignmentStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first) {\n      return false;\n    }\n\n    if (first.type === TokenType.Identifier) {\n      let index = 1;\n      while (\n        this.stream.peekNonWhitespace(index)?.type === TokenType.Dot &&\n        this.stream.peekNonWhitespace(index + 1)?.type === TokenType.Identifier\n      ) {\n        index += 2;\n      }\n      return this.stream.peekNonWhitespace(index)?.type === TokenType.Equals;\n    }\n\n    if (first.type === TokenType.At || first.type === TokenType.Dollar) {\n      const second = this.stream.peekNonWhitespace(1);\n      const third = this.stream.peekNonWhitespace(2);\n      return second?.type === TokenType.Identifier && third?.type === TokenType.Equals;\n    }\n\n    return false;\n  }\n\n  private isCallStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first || first.type !== TokenType.Identifier) {\n      return false;\n    }\n    let index = 1;\n    while (\n      this.stream.peekNonWhitespace(index)?.type === TokenType.Dot &&\n      this.stream.peekNonWhitespace(index + 1)?.type === TokenType.Identifier\n    ) {\n      index += 2;\n    }\n    return this.stream.peekNonWhitespace(index)?.type === TokenType.LParen;\n  }\n\n  private isFunctionDeclarationStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first || first.type !== TokenType.Identifier) {\n      return false;\n    }\n    let index = 1;\n    if (this.stream.peekNonWhitespace(index)?.type !== TokenType.LParen) {\n      return false;\n    }\n    index += 1;\n    let depth = 1;\n    while (true) {\n      const token = this.stream.peekNonWhitespace(index);\n      if (!token) {\n        return false;\n      }\n      if (token.type === TokenType.LParen) {\n        depth += 1;\n      } else if (token.type === TokenType.RParen) {\n        depth -= 1;\n        if (depth === 0) {\n          index += 1;\n          break;\n        }\n      }\n      index += 1;\n    }\n    return this.stream.peekNonWhitespace(index)?.type === TokenType.LBrace;\n  }\n\n  private isArrowFunctionStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first || first.type !== TokenType.LParen) {\n      return false;\n    }\n    let index = 1;\n    let depth = 1;\n    while (true) {\n      const token = this.stream.peekNonWhitespace(index);\n      if (!token) {\n        return false;\n      }\n      if (token.type === TokenType.LParen) {\n        depth += 1;\n      } else if (token.type === TokenType.RParen) {\n        depth -= 1;\n        if (depth === 0) {\n          index += 1;\n          break;\n        }\n      }\n      index += 1;\n    }\n    return this.stream.peekNonWhitespace(index)?.type === TokenType.Arrow;\n  }\n\n  private isFunctionExpressionAssignmentStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first || first.type !== TokenType.Identifier) {\n      return false;\n    }\n    if (this.stream.peekNonWhitespace(1)?.type !== TokenType.Equals) {\n      return false;\n    }\n    let index = 2;\n    if (this.stream.peekNonWhitespace(index)?.type !== TokenType.LParen) {\n      return false;\n    }\n    index += 1;\n    let depth = 1;\n    while (true) {\n      const token = this.stream.peekNonWhitespace(index);\n      if (!token) {\n        return false;\n      }\n      if (token.type === TokenType.LParen) {\n        depth += 1;\n      } else if (token.type === TokenType.RParen) {\n        depth -= 1;\n        if (depth === 0) {\n          index += 1;\n          break;\n        }\n      }\n      index += 1;\n    }\n    return this.stream.peekNonWhitespace(index)?.type === TokenType.Arrow;\n  }\n\n  private parseExpressionStatement(): ExpressionNode {\n    const expr = this.parseExpression();\n    this.consumeStatementTerminator();\n    return expr;\n  }\n\n  private parseConstructBlock(): BlockNode {\n    this.stream.expect(TokenType.Construct);\n    const body = this.parseBlock({ allowDeclarations: false });\n    body.type = \"Construct\";\n    return body;\n  }\n\n  private parseDestructBlock(): BlockNode {\n    this.stream.expect(TokenType.Destruct);\n    const body = this.parseBlock({ allowDeclarations: false });\n    body.type = \"Destruct\";\n    return body;\n  }\n\n  private parseQueryExpression(): QueryExpression {\n    this.stream.expect(TokenType.Question);\n    let direction: \"self\" | \"descendant\" | \"ancestor\" = \"self\";\n\n    if (this.stream.peek()?.type === TokenType.Greater) {\n      this.stream.next();\n      direction = \"descendant\";\n    } else if (this.stream.peek()?.type === TokenType.Less) {\n      this.stream.next();\n      direction = \"ancestor\";\n    }\n\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    const selector = this.readSelectorUntil(TokenType.RParen);\n    return new QueryExpression(direction, selector);\n  }\n\n  private parseFunctionDeclaration(): FunctionDeclarationNode {\n    const name = this.stream.expect(TokenType.Identifier).value;\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    const params: string[] = [];\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated function parameters\");\n      }\n      if (next.type === TokenType.RParen) {\n        this.stream.next();\n        break;\n      }\n      const param = this.stream.expect(TokenType.Identifier).value;\n      params.push(param);\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.Comma) {\n        this.stream.next();\n        continue;\n      }\n      if (this.stream.peek()?.type === TokenType.RParen) {\n        this.stream.next();\n        break;\n      }\n      throw new Error(\"Expected ',' or ')' in function parameters\");\n    }\n    this.stream.skipWhitespace();\n    const body = this.parseFunctionBlock();\n    return new FunctionDeclarationNode(name, params, body);\n  }\n\n  private parseFunctionBlock(): BlockNode {\n    this.stream.expect(TokenType.LBrace);\n    const statements = [];\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated function block\");\n      }\n      if (next.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n      statements.push(this.parseStatement({ allowBlocks: false, allowReturn: true }));\n    }\n    return new BlockNode(statements);\n  }\n\n  private parseReturnStatement(): ReturnNode {\n    this.stream.expect(TokenType.Return);\n    this.stream.skipWhitespace();\n    if (this.stream.peek()?.type === TokenType.Semicolon) {\n      this.stream.next();\n      return new ReturnNode();\n    }\n    const value = this.parseExpression();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Semicolon);\n    return new ReturnNode(value);\n  }\n\n  private parseArrowFunctionExpression(): FunctionExpression {\n    this.stream.expect(TokenType.LParen);\n    const params: string[] = [];\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated function parameters\");\n      }\n      if (next.type === TokenType.RParen) {\n        this.stream.next();\n        break;\n      }\n      const param = this.stream.expect(TokenType.Identifier).value;\n      params.push(param);\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type === TokenType.Comma) {\n        this.stream.next();\n        continue;\n      }\n      if (this.stream.peek()?.type === TokenType.RParen) {\n        this.stream.next();\n        break;\n      }\n      throw new Error(\"Expected ',' or ')' in function parameters\");\n    }\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Arrow);\n    this.stream.skipWhitespace();\n    const body = this.parseFunctionBlock();\n    return new FunctionExpression(params, body);\n  }\n\n  private readSelectorUntil(terminator: TokenType): string {\n    let selectorText = \"\";\n    let sawNonWhitespace = false;\n\n    while (true) {\n      const token = this.stream.peek();\n      if (!token) {\n        throw new Error(\"Unterminated selector\");\n      }\n      if (token.type === terminator) {\n        this.stream.next();\n        break;\n      }\n\n      if (token.type === TokenType.Whitespace) {\n        this.stream.next();\n        if (sawNonWhitespace && selectorText[selectorText.length - 1] !== \" \") {\n          selectorText += \" \";\n        }\n        continue;\n      }\n\n      sawNonWhitespace = true;\n      selectorText += this.stream.next().value;\n    }\n\n    return selectorText.trim();\n  }\n\n  private parseIdentifierPath(): string {\n    let value = this.stream.expect(TokenType.Identifier).value;\n    while (this.stream.peek()?.type === TokenType.Dot) {\n      this.stream.next();\n      const part = this.stream.expect(TokenType.Identifier).value;\n      value = `${value}.${part}`;\n    }\n    return value;\n  }\n}\n","export class Scope {\n  private data = new Map<string, any>();\n  private root: Scope;\n  private listeners = new Map<string, Set<() => void>>();\n  private anyListeners = new Set<() => void>();\n\n  constructor(public readonly parent?: Scope) {\n    this.root = parent ? parent.root : this;\n  }\n\n  get(key: string): any {\n    return this.getPath(key);\n  }\n\n  set(key: string, value: any): void {\n    this.setPath(key, value);\n  }\n\n  hasKey(path: string): boolean {\n    const parts = path.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return false;\n    }\n    return this.data.has(root);\n  }\n\n  getPath(path: string): any {\n    const explicit = path.startsWith(\"parent.\") || path.startsWith(\"root.\") || path.startsWith(\"self.\");\n    const { targetScope, targetPath } = this.resolveScope(path);\n    if (!targetScope || !targetPath) {\n      return undefined;\n    }\n\n    const localValue = this.getLocalPathValue(targetScope, targetPath);\n    if (explicit || localValue !== undefined) {\n      return localValue;\n    }\n    let cursor = targetScope.parent;\n    while (cursor) {\n      const value = this.getLocalPathValue(cursor, targetPath);\n      if (value !== undefined) {\n        return value;\n      }\n      cursor = cursor.parent;\n    }\n    return undefined;\n  }\n\n  setPath(path: string, value: any): void {\n    const explicit = path.startsWith(\"parent.\") || path.startsWith(\"root.\") || path.startsWith(\"self.\");\n    const { targetScope, targetPath } = this.resolveScope(path);\n    if (!targetScope || !targetPath) {\n      return;\n    }\n\n    const scopeForSet = explicit ? targetScope : this.findNearestScopeWithKey(targetScope, targetPath) ?? targetScope;\n    const parts = targetPath.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return;\n    }\n    if (parts.length === 1) {\n      scopeForSet.data.set(root, value);\n      scopeForSet.emitChange(targetPath);\n      return;\n    }\n    let obj = scopeForSet.data.get(root);\n    if (obj == null || typeof obj !== \"object\") {\n      obj = {};\n      scopeForSet.data.set(root, obj);\n    }\n    let cursor = obj;\n    for (let i = 1; i < parts.length - 1; i += 1) {\n      const key = parts[i];\n      if (!key) {\n        return;\n      }\n      if (cursor[key] == null || typeof cursor[key] !== \"object\") {\n        cursor[key] = {};\n      }\n      cursor = cursor[key];\n    }\n    const lastKey = parts[parts.length - 1];\n    if (!lastKey) {\n      return;\n    }\n    cursor[lastKey] = value;\n    scopeForSet.emitChange(targetPath);\n  }\n\n  on(path: string, handler: () => void): void {\n    const key = path.trim();\n    if (!key) {\n      return;\n    }\n    const set = this.listeners.get(key) ?? new Set<() => void>();\n    set.add(handler);\n    this.listeners.set(key, set);\n  }\n\n  off(path: string, handler: () => void): void {\n    const key = path.trim();\n    const set = this.listeners.get(key);\n    if (!set) {\n      return;\n    }\n    set.delete(handler);\n    if (set.size === 0) {\n      this.listeners.delete(key);\n    }\n  }\n\n  onAny(handler: () => void): void {\n    this.anyListeners.add(handler);\n  }\n\n  offAny(handler: () => void): void {\n    this.anyListeners.delete(handler);\n  }\n\n  private emitChange(path: string): void {\n    const key = path.trim();\n    if (!key) {\n      return;\n    }\n    this.listeners.get(key)?.forEach((fn) => fn());\n    const rootKey = key.split(\".\")[0];\n    if (rootKey && rootKey !== key) {\n      this.listeners.get(rootKey)?.forEach((fn) => fn());\n    }\n    this.anyListeners.forEach((fn) => fn());\n  }\n\n  private resolveScope(path: string): { targetScope: Scope | undefined; targetPath: string | undefined } {\n    let targetScope: Scope | undefined = this;\n    let targetPath = path;\n    while (targetPath.startsWith(\"parent.\")) {\n      targetScope = targetScope?.parent;\n      targetPath = targetPath.slice(\"parent.\".length);\n    }\n    if (targetPath.startsWith(\"root.\")) {\n      targetScope = targetScope?.root;\n      targetPath = targetPath.slice(\"root.\".length);\n    }\n    while (targetPath.startsWith(\"self.\")) {\n      targetScope = targetScope ?? this;\n      targetPath = targetPath.slice(\"self.\".length);\n    }\n    return { targetScope, targetPath };\n  }\n\n  private getLocalPathValue(scope: Scope, path: string): any {\n    const parts = path.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return undefined;\n    }\n    let value = scope.data.get(root);\n    for (let i = 1; i < parts.length; i += 1) {\n      if (value == null) {\n        return undefined;\n      }\n      const key = parts[i];\n      if (!key) {\n        return undefined;\n      }\n      value = value[key];\n    }\n    return value;\n  }\n\n  private findNearestScopeWithKey(start: Scope, path: string): Scope | undefined {\n    const root = path.split(\".\")[0];\n    if (!root) {\n      return undefined;\n    }\n    let cursor: Scope | undefined = start;\n    while (cursor) {\n      if (cursor.data.has(root)) {\n        return cursor;\n      }\n      cursor = cursor.parent;\n    }\n    return undefined;\n  }\n}\n","import { Scope } from \"./scope\";\n\nexport type BindDirection = \"both\" | \"from\" | \"to\";\n\nfunction getElementValue(element: Element): string {\n  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n    return element.value;\n  }\n  return element.textContent ?? \"\";\n}\n\nfunction setElementValue(element: Element, value: string): void {\n  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n    element.value = value;\n    element.setAttribute(\"value\", value);\n    return;\n  }\n  element.textContent = value;\n}\n\nexport function applyBindToScope(element: Element, expression: string, scope: Scope): void {\n  const key = expression.trim();\n  if (!key) {\n    return;\n  }\n\n  const value = getElementValue(element).trim();\n  if (value !== \"\") {\n    scope.set(key, value);\n  }\n}\n\nexport function applyBindToElement(element: Element, expression: string, scope: Scope): void {\n  const key = expression.trim();\n  if (!key) {\n    return;\n  }\n  const value = scope.get(key);\n  if (value == null) {\n    return;\n  }\n  setElementValue(element, String(value));\n}\n","import { Scope } from \"./scope\";\n\nfunction readCondition(expression: string, scope: Scope): boolean {\n  const key = expression.trim();\n  if (!key) {\n    return false;\n  }\n  return !!scope.get(key);\n}\n\nexport function applyIf(element: HTMLElement, expression: string, scope: Scope): void {\n  element.style.display = readCondition(expression, scope) ? \"\" : \"none\";\n}\n\nexport function applyShow(element: HTMLElement, expression: string, scope: Scope): void {\n  element.style.display = readCondition(expression, scope) ? \"\" : \"none\";\n}\n","import { Scope } from \"./scope\";\n\nfunction sanitizeHtml(value: string): string {\n  return value.replace(/<script\\b[^>]*>[\\s\\S]*?<\\/script>/gi, \"\");\n}\n\nexport function applyHtml(\n  element: HTMLElement,\n  expression: string,\n  scope: Scope,\n  trusted: boolean\n): void {\n  const key = expression.trim();\n  if (!key) {\n    return;\n  }\n  const value = scope.get(key);\n  const html = value == null ? \"\" : String(value);\n  element.innerHTML = trusted ? html : sanitizeHtml(html);\n}\n","import { applyHtml } from \"./html\";\nimport { Scope } from \"./scope\";\n\nexport interface GetConfig {\n  url: string;\n  targetSelector?: string;\n  swap?: \"inner\" | \"outer\";\n  trusted: boolean;\n}\n\nexport async function applyGet(\n  element: Element,\n  config: GetConfig,\n  scope: Scope,\n  onHtmlApplied?: (target: Element) => void\n): Promise<void> {\n  if (!globalThis.fetch) {\n    throw new Error(\"fetch is not available\");\n  }\n\n  const response = await globalThis.fetch(config.url);\n  if (!response || !response.ok) {\n    return;\n  }\n\n  const html = await response.text();\n  const target = resolveTarget(element, config.targetSelector);\n  if (!target) {\n    element.dispatchEvent(new CustomEvent(\"vsn:targetError\", { detail: { selector: config.targetSelector } }));\n    return;\n  }\n\n  if (config.swap === \"outer\") {\n    const wrapper = document.createElement(\"div\");\n    applyHtml(wrapper, \"__html\", { get: () => html } as Scope, config.trusted);\n    const replacement = wrapper.firstElementChild;\n    if (replacement && target.parentNode) {\n      target.parentNode.replaceChild(replacement, target);\n      onHtmlApplied?.(replacement);\n    }\n    return;\n  }\n\n  applyHtml(target as HTMLElement, \"__html\", { get: () => html } as Scope, config.trusted);\n  onHtmlApplied?.(target);\n}\n\nfunction resolveTarget(element: Element, selector?: string): Element | null {\n  if (!selector) {\n    return element;\n  }\n  return element.ownerDocument.querySelector(selector);\n}\n","type Debounced = (...args: any[]) => void;\n\nexport function debounce<T extends (...args: any[]) => void>(fn: T, waitMs: number): Debounced {\n  let timer: ReturnType<typeof setTimeout> | undefined;\n  return (...args: any[]) => {\n    if (timer) {\n      clearTimeout(timer);\n    }\n    timer = setTimeout(() => {\n      timer = undefined;\n      fn(...args);\n    }, waitMs);\n  };\n}\n","import { Scope } from \"./scope\";\nimport { applyBindToElement, applyBindToScope, BindDirection } from \"./bindings\";\nimport { applyIf, applyShow } from \"./conditionals\";\nimport { applyHtml } from \"./html\";\nimport { applyGet, GetConfig } from \"./http\";\nimport { debounce } from \"./debounce\";\nimport { Parser } from \"../parser/parser\";\nimport {\n  AssignmentNode,\n  BehaviorNode,\n  BlockNode,\n  DeclarationNode,\n  DirectiveExpression,\n  ExecutionContext,\n  ExpressionNode,\n  FunctionDeclarationNode,\n  FunctionExpression,\n  IdentifierExpression,\n  OnBlockNode\n} from \"../ast/nodes\";\n\ninterface OnConfig {\n  event: string;\n  code: string;\n  debounceMs?: number;\n  modifiers?: string[];\n}\n\ninterface BindConfig {\n  expr: string;\n  direction: BindDirection;\n}\n\ninterface LifecycleConfig {\n  construct?: string;\n  destruct?: string;\n}\n\ninterface RegisteredBehavior {\n  id: number;\n  selector: string;\n  specificity: number;\n  order: number;\n  construct?: BlockNode;\n  destruct?: BlockNode;\n  onBlocks: { event: string; body: BlockNode; modifiers: string[] }[];\n  declarations: DeclarationNode[];\n  functions: FunctionBinding[];\n}\n\ntype FunctionBinding = {\n  name: string;\n  params: string[];\n  body: BlockNode;\n};\n\ntype AttributeHandler = {\n  id: string;\n  match: (name: string) => boolean;\n  handle: (element: Element, name: string, value: string, scope: Scope) => boolean | void;\n};\n\ntype CachedBehavior = {\n  construct?: BlockNode;\n  destruct?: BlockNode;\n  onBlocks: { event: string; body: BlockNode; modifiers: string[] }[];\n  declarations: DeclarationNode[];\n  functions: FunctionBinding[];\n};\n\ntype FlagApplyContext = {\n  name: string;\n  args: any;\n  element: Element;\n  scope: Scope;\n  declaration: DeclarationNode;\n};\n\ntype FlagHandler = {\n  onApply?: (context: FlagApplyContext) => void;\n};\n\nexport class Engine {\n  private scopes = new WeakMap<Element, Scope>();\n  private bindBindings = new WeakMap<Element, BindConfig>();\n  private ifBindings = new WeakMap<Element, string>();\n  private showBindings = new WeakMap<Element, string>();\n  private htmlBindings = new WeakMap<Element, { expr: string; trusted: boolean }>();\n  private getBindings = new WeakMap<Element, GetConfig>();\n  private lifecycleBindings = new WeakMap<Element, LifecycleConfig>();\n  private behaviorRegistry: RegisteredBehavior[] = [];\n  private behaviorBindings = new WeakMap<Element, Set<number>>();\n  private behaviorId = 0;\n  private codeCache = new Map<string, BlockNode>();\n  private behaviorCache = new Map<string, CachedBehavior>();\n  private observer?: MutationObserver;\n  private attributeHandlers: AttributeHandler[] = [];\n  private globals: Record<string, any> = {};\n  private importantFlags = new WeakMap<Element, Set<string>>();\n  private inlineDeclarations = new WeakMap<Element, Set<string>>();\n  private flagHandlers = new Map<string, FlagHandler>();\n  private pendingAdded = new Set<Element>();\n  private pendingRemoved = new Set<Element>();\n  private observerFlush?: () => void;\n\n  constructor() {\n    this.registerGlobal(\"console\", console);\n    this.registerDefaultAttributeHandlers();\n  }\n\n  async mount(root: HTMLElement): Promise<void> {\n    const elements: Element[] = [root, ...Array.from(root.querySelectorAll(\"*\"))];\n    for (const element of elements) {\n      if (!this.hasVsnAttributes(element)) {\n        continue;\n      }\n      const parentScope = this.findParentScope(element);\n      this.getScope(element, parentScope);\n      this.attachAttributes(element);\n      this.runConstruct(element);\n    }\n    await this.applyBehaviors(root);\n    this.attachObserver(root);\n  }\n\n  unmount(element: Element): void {\n    this.runDestruct(element);\n  }\n\n  registerBehaviors(source: string): void {\n    const program = new Parser(source, { customFlags: new Set(this.flagHandlers.keys()) }).parseProgram();\n    for (const use of program.uses) {\n      const value = this.resolveGlobalPath(use.name);\n      if (value === undefined) {\n        console.warn(`vsn: global '${use.name}' not found`);\n        continue;\n      }\n      this.registerGlobal(use.alias, value);\n    }\n    for (const behavior of program.behaviors) {\n      this.collectBehavior(behavior);\n    }\n  }\n\n  registerGlobal(name: string, value: any): void {\n    this.globals[name] = value;\n  }\n\n  registerGlobals(values: Record<string, any>): void {\n    Object.assign(this.globals, values);\n  }\n\n  registerFlag(name: string, handler: FlagHandler = {}): void {\n    const reserved = new Set([\"important\", \"trusted\", \"debounce\"]);\n    if (reserved.has(name)) {\n      throw new Error(`Flag '${name}' is reserved`);\n    }\n    this.flagHandlers.set(name, handler);\n  }\n\n  getRegistryStats(): { behaviorCount: number; behaviorCacheSize: number } {\n    return {\n      behaviorCount: this.behaviorRegistry.length,\n      behaviorCacheSize: this.behaviorCache.size\n    };\n  }\n\n  registerAttributeHandler(handler: AttributeHandler): void {\n    this.attributeHandlers.push(handler);\n  }\n\n  private resolveGlobalPath(name: string): any {\n    const parts = name.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return undefined;\n    }\n    let value: any = (globalThis as any)[root];\n    for (let i = 1; i < parts.length; i += 1) {\n      const part = parts[i];\n      if (!part) {\n        return undefined;\n      }\n      value = value?.[part];\n    }\n    return value;\n  }\n\n  getScope(element: Element, parentScope?: Scope): Scope {\n    const existing = this.scopes.get(element);\n    if (existing) {\n      return existing;\n    }\n    const scope = new Scope(parentScope ?? this.findParentScope(element));\n    this.scopes.set(element, scope);\n    return scope;\n  }\n\n  evaluate(element: Element): void {\n    const scope = this.getScope(element);\n    const bindConfig = this.bindBindings.get(element);\n    if (bindConfig && (bindConfig.direction === \"from\" || bindConfig.direction === \"both\")) {\n      applyBindToElement(element, bindConfig.expr, scope);\n    }\n    const ifExpr = this.ifBindings.get(element);\n    if (ifExpr && element instanceof HTMLElement) {\n      applyIf(element, ifExpr, scope);\n    }\n    const showExpr = this.showBindings.get(element);\n    if (showExpr && element instanceof HTMLElement) {\n      applyShow(element, showExpr, scope);\n    }\n    const htmlBinding = this.htmlBindings.get(element);\n    if (htmlBinding && element instanceof HTMLElement) {\n      applyHtml(element, htmlBinding.expr, scope, htmlBinding.trusted);\n      if (htmlBinding.trusted) {\n        this.handleTrustedHtml(element);\n      }\n    }\n  }\n\n  private attachObserver(root: HTMLElement): void {\n    if (this.observer) {\n      return;\n    }\n    this.observerFlush = debounce(() => this.flushObserverQueue(), 10);\n    this.observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        for (const node of Array.from(mutation.addedNodes)) {\n          if (node && node.nodeType === 1) {\n            this.pendingAdded.add(node as Element);\n          }\n        }\n        for (const node of Array.from(mutation.removedNodes)) {\n          if (node && node.nodeType === 1) {\n            this.pendingRemoved.add(node as Element);\n          }\n        }\n      }\n      this.observerFlush?.();\n    });\n    this.observer.observe(root, { childList: true, subtree: true });\n  }\n\n  private flushObserverQueue(): void {\n    const removed = Array.from(this.pendingRemoved);\n    this.pendingRemoved.clear();\n    for (const node of removed) {\n      this.handleRemovedNode(node);\n    }\n    const added = Array.from(this.pendingAdded);\n    this.pendingAdded.clear();\n    for (const node of added) {\n      this.handleAddedNode(node);\n    }\n  }\n\n  private handleRemovedNode(node: Element): void {\n    if (this.lifecycleBindings.has(node)) {\n      this.runDestruct(node);\n    }\n    if (this.behaviorBindings.has(node)) {\n      this.runBehaviorDestruct(node);\n    }\n    for (const child of Array.from(node.querySelectorAll(\"*\"))) {\n      if (this.lifecycleBindings.has(child)) {\n        this.runDestruct(child);\n      }\n      if (this.behaviorBindings.has(child)) {\n        this.runBehaviorDestruct(child);\n      }\n    }\n  }\n\n  private handleAddedNode(node: Element): void {\n    const elements = [node, ...Array.from(node.querySelectorAll(\"*\"))];\n    for (const element of elements) {\n      if (!this.hasVsnAttributes(element)) {\n        continue;\n      }\n      const parentScope = this.findParentScope(element);\n      this.getScope(element, parentScope);\n      this.attachAttributes(element);\n      this.runConstruct(element);\n    }\n    void this.applyBehaviors(node);\n  }\n\n  private async applyBehaviors(root: Element): Promise<void> {\n    if (this.behaviorRegistry.length === 0) {\n      return;\n    }\n    const elements: Element[] = [root, ...Array.from(root.querySelectorAll(\"*\"))];\n    for (const element of elements) {\n      const bound = this.behaviorBindings.get(element) ?? new Set<number>();\n      const matches = this.behaviorRegistry.filter((behavior) => {\n        if (bound.has(behavior.id)) {\n          return false;\n        }\n        return element.matches(behavior.selector);\n      });\n      if (matches.length === 0) {\n        continue;\n      }\n      matches.sort((a, b) => {\n        if (a.specificity !== b.specificity) {\n          return a.specificity - b.specificity;\n        }\n        return a.order - b.order;\n      });\n      const scope = this.getScope(element);\n      for (const behavior of matches) {\n        bound.add(behavior.id);\n        this.applyBehaviorFunctions(element, scope, behavior.functions);\n        await this.applyBehaviorDeclarations(element, scope, behavior.declarations);\n        if (behavior.construct) {\n          await this.executeBlock(behavior.construct, scope, element);\n        }\n        for (const onBlock of behavior.onBlocks) {\n          this.attachBehaviorOnHandler(element, onBlock.event, onBlock.body, onBlock.modifiers);\n        }\n      }\n      this.behaviorBindings.set(element, bound);\n    }\n  }\n\n  private runBehaviorDestruct(element: Element): void {\n    const bound = this.behaviorBindings.get(element);\n    if (!bound) {\n      return;\n    }\n    const scope = this.getScope(element);\n    for (const behavior of this.behaviorRegistry) {\n      if (!bound.has(behavior.id) || !behavior.destruct) {\n        continue;\n      }\n      void this.executeBlock(behavior.destruct, scope, element);\n    }\n  }\n\n  private attachAttributes(element: Element): void {\n    const scope = this.getScope(element);\n    for (const name of element.getAttributeNames()) {\n      if (!name.startsWith(\"vsn-\")) {\n        continue;\n      }\n      const value = element.getAttribute(name) ?? \"\";\n      for (const handler of this.attributeHandlers) {\n        if (!handler.match(name)) {\n          continue;\n        }\n        const handled = handler.handle(element, name, value, scope);\n        if (handled !== false) {\n          break;\n        }\n      }\n    }\n  }\n\n  private setLifecycle(element: Element, patch: LifecycleConfig): void {\n    const current = this.lifecycleBindings.get(element) ?? {};\n    this.lifecycleBindings.set(element, { ...current, ...patch });\n  }\n\n  private runConstruct(element: Element): void {\n    const config = this.lifecycleBindings.get(element);\n    if (!config?.construct) {\n      return;\n    }\n    const scope = this.getScope(element);\n    this.execute(config.construct, scope, element);\n  }\n\n  private runDestruct(element: Element): void {\n    const config = this.lifecycleBindings.get(element);\n    if (!config?.destruct) {\n      return;\n    }\n    const scope = this.getScope(element);\n    this.execute(config.destruct, scope, element);\n  }\n\n  private attachBindInputHandler(element: Element, expr: string): void {\n    if (!(element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement)) {\n      return;\n    }\n    const handler = () => {\n      const scope = this.getScope(element);\n      applyBindToScope(element, expr, scope);\n    };\n    element.addEventListener(\"input\", handler);\n    element.addEventListener(\"change\", handler);\n  }\n\n  private parseBindDirection(name: string): BindDirection {\n    if (name.includes(\":from\")) {\n      return \"from\";\n    }\n    if (name.includes(\":to\")) {\n      return \"to\";\n    }\n    return \"both\";\n  }\n\n  private hasVsnAttributes(element: Element): boolean {\n    return element.getAttributeNames().some((name) => name.startsWith(\"vsn-\"));\n  }\n\n  private markInlineDeclaration(element: Element, key: string): void {\n    const set = this.inlineDeclarations.get(element) ?? new Set<string>();\n    set.add(key);\n    this.inlineDeclarations.set(element, set);\n  }\n\n  private isInlineDeclaration(element: Element, key: string): boolean {\n    const set = this.inlineDeclarations.get(element);\n    return set ? set.has(key) : false;\n  }\n\n  private findParentScope(element: Element): Scope | undefined {\n    let parent = element.parentElement;\n    while (parent) {\n      const scope = this.scopes.get(parent);\n      if (scope) {\n        return scope;\n      }\n      parent = parent.parentElement;\n    }\n    return undefined;\n  }\n\n  private watch(scope: Scope, expr: string, handler: () => void): void {\n    const key = expr.trim();\n    if (!key) {\n      return;\n    }\n    const root = key.split(\".\")[0];\n    if (!root) {\n      return;\n    }\n    let target: Scope | undefined = scope;\n    while (target && !target.hasKey(root)) {\n      target = target.parent;\n    }\n    if (target) {\n      target.on(key, handler);\n      return;\n    }\n    let cursor: Scope | undefined = scope;\n    while (cursor) {\n      cursor.on(key, handler);\n      cursor = cursor.parent;\n    }\n  }\n\n  private watchWithDebounce(scope: Scope, expr: string, handler: () => void, debounceMs?: number): void {\n    if (debounceMs) {\n      this.watch(scope, expr, debounce(handler, debounceMs));\n    } else {\n      this.watch(scope, expr, handler);\n    }\n  }\n\n  private watchAllScopes(scope: Scope, handler: () => void, debounceMs?: number): void {\n    const effectiveHandler = debounceMs ? debounce(handler, debounceMs) : handler;\n    let cursor: Scope | undefined = scope;\n    while (cursor) {\n      cursor.onAny(effectiveHandler);\n      cursor = cursor.parent;\n    }\n  }\n\n  private parseOnAttribute(name: string, value: string): OnConfig | null {\n    if (!name.startsWith(\"vsn-on:\")) {\n      return null;\n    }\n\n    const eventWithFlags = name.slice(\"vsn-on:\".length);\n    const [event, ...flags] = eventWithFlags.split(\"!\");\n    if (!event) {\n      return null;\n    }\n\n    let debounceMs: number | undefined;\n    const modifiers: string[] = [];\n    for (const flag of flags) {\n      if (flag.startsWith(\"debounce\")) {\n        const match = flag.match(/debounce\\((\\d+)\\)/);\n        debounceMs = match ? Number(match[1]) : 200;\n        continue;\n      }\n      modifiers.push(flag);\n    }\n\n    const config: OnConfig = {\n      event,\n      code: value,\n      ...(debounceMs !== undefined ? { debounceMs } : {}),\n      ...(modifiers.length > 0 ? { modifiers } : {})\n    };\n    return config;\n  }\n\n  private attachOnHandler(element: Element, config: OnConfig): void {\n    const handler = async (event?: Event) => {\n      this.applyEventModifiers(event, config.modifiers);\n      const scope = this.getScope(element);\n      await this.execute(config.code, scope, element);\n      this.evaluate(element);\n    };\n    const effectiveHandler = config.debounceMs ? debounce(handler, config.debounceMs) : handler;\n    element.addEventListener(config.event, effectiveHandler, this.getListenerOptions(config.modifiers));\n  }\n\n  private attachBehaviorOnHandler(element: Element, event: string, body: BlockNode, modifiers?: string[]): void {\n    const handler = async (evt?: Event) => {\n      this.applyEventModifiers(evt, modifiers);\n      const scope = this.getScope(element);\n      await this.executeBlock(body, scope, element);\n      this.evaluate(element);\n    };\n    element.addEventListener(event, handler, this.getListenerOptions(modifiers));\n  }\n\n  private attachGetHandler(element: Element, autoLoad = false): void {\n    const handler = async () => {\n      const config = this.getBindings.get(element);\n      if (!config) {\n        return;\n      }\n      try {\n        await applyGet(element, config, this.getScope(element), (target) => {\n          if (config.trusted) {\n            this.handleTrustedHtml(target);\n          }\n        });\n      } catch (error) {\n        element.dispatchEvent(new CustomEvent(\"vsn:getError\", { detail: { error } }));\n      }\n    };\n\n    element.addEventListener(\"click\", (event) => {\n      if (event.target !== element) {\n        return;\n      }\n      void handler();\n    });\n    if (autoLoad) {\n      Promise.resolve().then(handler);\n    }\n  }\n\n  private applyEventModifiers(event: Event | undefined, modifiers?: string[]): void {\n    if (!event || !modifiers || modifiers.length === 0) {\n      return;\n    }\n    for (const modifier of modifiers) {\n      if (modifier === \"prevent\") {\n        event.preventDefault();\n      } else if (modifier === \"stop\") {\n        event.stopPropagation();\n      }\n    }\n  }\n\n  private getListenerOptions(modifiers?: string[]): AddEventListenerOptions | undefined {\n    if (!modifiers || modifiers.length === 0) {\n      return undefined;\n    }\n    const options: AddEventListenerOptions = {};\n    if (modifiers.includes(\"once\")) {\n      options.once = true;\n    }\n    if (modifiers.includes(\"passive\")) {\n      options.passive = true;\n    }\n    if (modifiers.includes(\"capture\")) {\n      options.capture = true;\n    }\n    return Object.keys(options).length > 0 ? options : undefined;\n  }\n\n  private async execute(code: string, scope: Scope, element?: Element): Promise<void> {\n    let block = this.codeCache.get(code);\n    if (!block) {\n      block = Parser.parseInline(code);\n      this.codeCache.set(code, block);\n    }\n    const context: ExecutionContext = {\n      scope,\n      globals: this.globals,\n      ...(element ? { element } : {})\n    };\n    await block.evaluate(context);\n  }\n\n  private async executeBlock(block: BlockNode, scope: Scope, element?: Element): Promise<void> {\n    const context: ExecutionContext = {\n      scope,\n      globals: this.globals,\n      ...(element ? { element } : {})\n    };\n    await block.evaluate(context);\n  }\n\n  private collectBehavior(behavior: BehaviorNode, parentSelector?: string): void {\n    const selector = parentSelector\n      ? `${parentSelector} ${behavior.selector.selectorText}`\n      : behavior.selector.selectorText;\n    const cached = this.getCachedBehavior(behavior);\n    this.behaviorRegistry.push({\n      id: this.behaviorId += 1,\n      selector,\n      specificity: this.computeSpecificity(selector),\n      order: this.behaviorRegistry.length,\n      ...cached\n    });\n    for (const statement of behavior.body.statements) {\n      if (statement instanceof BehaviorNode) {\n        this.collectBehavior(statement, selector);\n      }\n    }\n  }\n\n  private computeSpecificity(selector: string): number {\n    const idMatches = selector.match(/#[\\w-]+/g)?.length ?? 0;\n    const classMatches = selector.match(/\\.[\\w-]+/g)?.length ?? 0;\n    const attrMatches = selector.match(/\\[[^\\]]+\\]/g)?.length ?? 0;\n    const pseudoMatches = selector.match(/:[\\w-]+/g)?.length ?? 0;\n    const elementMatches = selector.match(/(^|[\\s>+~])([a-zA-Z][\\w-]*)/g)?.length ?? 0;\n    return idMatches * 100 + (classMatches + attrMatches + pseudoMatches) * 10 + elementMatches;\n  }\n\n\n  private getImportantKey(declaration: DeclarationNode): string | undefined {\n    if (declaration.target instanceof IdentifierExpression) {\n      return `state:${declaration.target.name}`;\n    }\n    if (declaration.target instanceof DirectiveExpression) {\n      return `${declaration.target.kind}:${declaration.target.name}`;\n    }\n    return undefined;\n  }\n\n  private isImportant(element: Element, key: string): boolean {\n    const set = this.importantFlags.get(element);\n    return set ? set.has(key) : false;\n  }\n\n  private markImportant(element: Element, key: string): void {\n    const set = this.importantFlags.get(element) ?? new Set<string>();\n    set.add(key);\n    this.importantFlags.set(element, set);\n  }\n\n  private extractLifecycle(body: BlockNode): { construct?: BlockNode; destruct?: BlockNode } {\n    let construct: BlockNode | undefined;\n    let destruct: BlockNode | undefined;\n    for (const statement of body.statements) {\n      if (!(statement instanceof BlockNode)) {\n        continue;\n      }\n      if (statement.type === \"Construct\") {\n        construct = statement;\n      } else if (statement.type === \"Destruct\") {\n        destruct = statement;\n      }\n    }\n    return {\n      ...(construct ? { construct } : {}),\n      ...(destruct ? { destruct } : {})\n    };\n  }\n\n  private extractOnBlocks(body: BlockNode): { event: string; body: BlockNode; modifiers: string[] }[] {\n    const blocks: { event: string; body: BlockNode; modifiers: string[] }[] = [];\n    for (const statement of body.statements) {\n      if (statement instanceof OnBlockNode) {\n        blocks.push({ event: statement.eventName, body: statement.body, modifiers: statement.modifiers });\n      }\n    }\n    return blocks;\n  }\n\n  private extractDeclarations(body: BlockNode): DeclarationNode[] {\n    const declarations: DeclarationNode[] = [];\n    for (const statement of body.statements) {\n      if (statement instanceof DeclarationNode) {\n        declarations.push(statement);\n      }\n    }\n    return declarations;\n  }\n\n  private extractFunctionDeclarations(body: BlockNode): FunctionBinding[] {\n    const functions: FunctionBinding[] = [];\n    for (const statement of body.statements) {\n      if (statement instanceof FunctionDeclarationNode) {\n        functions.push({ name: statement.name, params: statement.params, body: statement.body });\n        continue;\n      }\n      if (statement instanceof AssignmentNode) {\n        if (statement.target instanceof IdentifierExpression && statement.value instanceof FunctionExpression) {\n          functions.push({\n            name: statement.target.name,\n            params: statement.value.params,\n            body: statement.value.body\n          });\n        }\n      }\n    }\n    return functions;\n  }\n\n  private getCachedBehavior(behavior: BehaviorNode): CachedBehavior {\n    const hash = this.hashBehavior(behavior);\n    const cached = this.behaviorCache.get(hash);\n    if (cached) {\n      return cached;\n    }\n    const lifecycle = this.extractLifecycle(behavior.body);\n    const fresh: CachedBehavior = {\n      onBlocks: this.extractOnBlocks(behavior.body),\n      declarations: this.extractDeclarations(behavior.body),\n      functions: this.extractFunctionDeclarations(behavior.body),\n      ...lifecycle\n    };\n    this.behaviorCache.set(hash, fresh);\n    return fresh;\n  }\n\n  private hashBehavior(behavior: BehaviorNode): string {\n    const normalized = this.normalizeNode(behavior);\n    const json = JSON.stringify(normalized);\n    return this.hashString(json);\n  }\n\n  private normalizeNode(node: any): any {\n    if (!node || typeof node !== \"object\") {\n      return node;\n    }\n    const type = node.type ?? \"Unknown\";\n    if (type === \"Behavior\") {\n      return {\n        type,\n        selector: node.selector?.selectorText ?? \"\",\n        body: this.normalizeNode(node.body)\n      };\n    }\n    if (type === \"Selector\") {\n      return { type, selectorText: node.selectorText ?? \"\" };\n    }\n    if (type === \"Block\" || type === \"Construct\" || type === \"Destruct\") {\n      return {\n        type,\n        statements: Array.isArray(node.statements)\n          ? node.statements.map((statement: any) => this.normalizeNode(statement))\n          : []\n      };\n    }\n    if (type === \"OnBlock\") {\n      return {\n        type,\n        eventName: node.eventName ?? \"\",\n        args: Array.isArray(node.args) ? node.args : [],\n        body: this.normalizeNode(node.body)\n      };\n    }\n    if (type === \"Declaration\") {\n      return {\n        type,\n        target: this.normalizeNode(node.target),\n        operator: node.operator ?? \"\",\n        value: this.normalizeNode(node.value),\n        flags: node.flags ?? {},\n        flagArgs: node.flagArgs ?? {}\n      };\n    }\n    if (type === \"Assignment\") {\n      return {\n        type,\n        target: this.normalizeNode(node.target),\n        value: this.normalizeNode(node.value)\n      };\n    }\n    if (type === \"StateBlock\") {\n      return {\n        type,\n        entries: Array.isArray(node.entries)\n          ? node.entries.map((entry: any) => this.normalizeNode(entry))\n          : []\n      };\n    }\n    if (type === \"StateEntry\") {\n      return {\n        type,\n        name: node.name ?? \"\",\n        value: this.normalizeNode(node.value),\n        important: Boolean(node.important)\n      };\n    }\n    if (type === \"FunctionDeclaration\") {\n      return {\n        type,\n        name: node.name ?? \"\",\n        params: Array.isArray(node.params) ? node.params : [],\n        body: this.normalizeNode(node.body)\n      };\n    }\n    if (type === \"FunctionExpression\") {\n      return {\n        type,\n        params: Array.isArray(node.params) ? node.params : [],\n        body: this.normalizeNode(node.body)\n      };\n    }\n    if (type === \"Return\") {\n      return {\n        type,\n        value: this.normalizeNode(node.value ?? null)\n      };\n    }\n    if (type === \"Identifier\") {\n      return { type, name: node.name ?? \"\" };\n    }\n    if (type === \"Literal\") {\n      return { type, value: node.value };\n    }\n    if (type === \"UnaryExpression\") {\n      return {\n        type,\n        operator: node.operator ?? \"\",\n        argument: this.normalizeNode(node.argument)\n      };\n    }\n    if (type === \"BinaryExpression\") {\n      return {\n        type,\n        operator: node.operator ?? \"\",\n        left: this.normalizeNode(node.left),\n        right: this.normalizeNode(node.right)\n      };\n    }\n    if (type === \"TernaryExpression\") {\n      return {\n        type,\n        test: this.normalizeNode(node.test),\n        consequent: this.normalizeNode(node.consequent),\n        alternate: this.normalizeNode(node.alternate)\n      };\n    }\n    if (type === \"CallExpression\") {\n      return {\n        type,\n        callee: this.normalizeNode(node.callee),\n        args: Array.isArray(node.args) ? node.args.map((arg: any) => this.normalizeNode(arg)) : []\n      };\n    }\n    if (type === \"Directive\") {\n      return { type, kind: node.kind ?? \"\", name: node.name ?? \"\" };\n    }\n    if (type === \"Query\") {\n      return { type, direction: node.direction ?? \"\", selector: node.selector ?? \"\" };\n    }\n    if (type === \"ArrayExpression\") {\n      return {\n        type,\n        elements: Array.isArray(node.elements)\n          ? node.elements.map((element: any) => this.normalizeNode(element))\n          : []\n      };\n    }\n    if (type === \"IndexExpression\") {\n      return {\n        type,\n        target: this.normalizeNode(node.target),\n        index: this.normalizeNode(node.index)\n      };\n    }\n    return { type };\n  }\n\n  private hashString(value: string): string {\n    let hash = 5381;\n    for (let i = 0; i < value.length; i += 1) {\n      hash = ((hash << 5) + hash) + value.charCodeAt(i);\n      hash |= 0;\n    }\n    return (hash >>> 0).toString(16);\n  }\n\n  private applyBehaviorFunctions(\n    element: Element,\n    scope: Scope,\n    functions: FunctionBinding[]\n  ): void {\n    for (const declaration of functions) {\n      this.applyBehaviorFunction(element, scope, declaration);\n    }\n  }\n\n  private applyBehaviorFunction(\n    element: Element,\n    scope: Scope,\n    declaration: FunctionBinding\n  ): void {\n    const existing = scope.getPath(declaration.name);\n    if (existing !== undefined && typeof existing !== \"function\") {\n      throw new Error(`Cannot override non-function '${declaration.name}' with a function`);\n    }\n    const fn = async (...args: any[]) => {\n      const context: ExecutionContext = {\n        scope,\n        globals: this.globals,\n        element,\n        returnValue: undefined,\n        returning: false\n      };\n      const previousValues = new Map<string, any>();\n      for (let i = 0; i < declaration.params.length; i += 1) {\n        const name = declaration.params[i];\n        if (!name) {\n          continue;\n        }\n        previousValues.set(name, scope.getPath(name));\n        scope.setPath(name, args[i]);\n      }\n      await declaration.body.evaluate(context);\n      for (const name of declaration.params) {\n        if (!name) {\n          continue;\n        }\n        scope.setPath(name, previousValues.get(name));\n      }\n      return context.returnValue;\n    };\n    scope.setPath(declaration.name, fn);\n  }\n\n  private async applyBehaviorDeclarations(\n    element: Element,\n    scope: Scope,\n    declarations: DeclarationNode[]\n  ): Promise<void> {\n    for (const declaration of declarations) {\n      await this.applyBehaviorDeclaration(element, scope, declaration);\n    }\n  }\n\n  private async applyBehaviorDeclaration(\n    element: Element,\n    scope: Scope,\n    declaration: DeclarationNode\n  ): Promise<void> {\n    const context: ExecutionContext = { scope, element };\n    const operator = declaration.operator;\n    const debounceMs = declaration.flags.debounce\n      ? declaration.flagArgs.debounce ?? 200\n      : undefined;\n    const importantKey = this.getImportantKey(declaration);\n    if (!declaration.flags.important && importantKey && this.isImportant(element, importantKey)) {\n      return;\n    }\n    if (importantKey && this.isInlineDeclaration(element, importantKey)) {\n      return;\n    }\n    this.applyCustomFlags(element, scope, declaration);\n\n    if (declaration.target instanceof IdentifierExpression) {\n      const value = await declaration.value.evaluate(context);\n      scope.setPath(declaration.target.name, value);\n      if (declaration.flags.important && importantKey) {\n        this.markImportant(element, importantKey);\n      }\n      return;\n    }\n\n    if (!(declaration.target instanceof DirectiveExpression)) {\n      return;\n    }\n\n    const target = declaration.target;\n    const exprIdentifier =\n      declaration.value instanceof IdentifierExpression ? declaration.value.name : undefined;\n\n    if (operator === \":>\") {\n      if (exprIdentifier) {\n        this.applyDirectiveToScope(element, target, exprIdentifier, scope, debounceMs);\n      }\n      if (declaration.flags.important && importantKey) {\n        this.markImportant(element, importantKey);\n      }\n      return;\n    }\n\n    if (operator === \":=\" && exprIdentifier) {\n      this.applyDirectiveToScope(element, target, exprIdentifier, scope, debounceMs);\n    }\n\n    if (!exprIdentifier) {\n      const value = await declaration.value.evaluate(context);\n      this.setDirectiveValue(element, target, value, declaration.flags.trusted);\n      const shouldWatch = operator === \":<\" || operator === \":=\";\n      if (shouldWatch) {\n        this.applyDirectiveFromExpression(\n          element,\n          target,\n          declaration.value,\n          scope,\n          declaration.flags.trusted,\n          debounceMs\n        );\n      }\n      if (declaration.flags.important && importantKey) {\n        this.markImportant(element, importantKey);\n      }\n      return;\n    }\n\n    const shouldWatch = operator === \":<\" || operator === \":=\";\n    this.applyDirectiveFromScope(\n      element,\n      target,\n      exprIdentifier,\n      scope,\n      declaration.flags.trusted,\n      debounceMs,\n      shouldWatch\n    );\n    if (declaration.flags.important && importantKey) {\n      this.markImportant(element, importantKey);\n    }\n  }\n\n  private applyCustomFlags(element: Element, scope: Scope, declaration: DeclarationNode): void {\n    if (this.flagHandlers.size === 0) {\n      return;\n    }\n    for (const [name, handler] of this.flagHandlers) {\n      if (!declaration.flags[name]) {\n        continue;\n      }\n      handler.onApply?.({\n        name,\n        args: declaration.flagArgs[name],\n        element,\n        scope,\n        declaration\n      });\n    }\n  }\n\n  private applyDirectiveFromScope(\n    element: Element,\n    target: DirectiveExpression,\n    expr: string,\n    scope: Scope,\n    trusted: boolean | undefined,\n    debounceMs?: number,\n    watch = true\n  ): void {\n    if (target.kind === \"attr\" && target.name === \"html\" && element instanceof HTMLElement) {\n      const handler = () => applyHtml(element, expr, scope, Boolean(trusted));\n      handler();\n      if (trusted) {\n        this.handleTrustedHtml(element);\n      }\n      if (watch) {\n        this.watchWithDebounce(scope, expr, handler, debounceMs);\n      }\n      return;\n    }\n    const handler = () => {\n      const value = scope.get(expr);\n      if (value == null) {\n        return;\n      }\n      this.setDirectiveValue(element, target, value, trusted);\n    };\n    handler();\n    if (watch) {\n      this.watchWithDebounce(scope, expr, handler, debounceMs);\n    }\n  }\n\n  private applyDirectiveFromExpression(\n    element: Element,\n    target: DirectiveExpression,\n    expr: ExpressionNode,\n    scope: Scope,\n    trusted: boolean | undefined,\n    debounceMs?: number\n  ): void {\n    const handler = async () => {\n      const context: ExecutionContext = { scope, element };\n      const value = await expr.evaluate(context);\n      this.setDirectiveValue(element, target, value, trusted);\n    };\n    void handler();\n    this.watchAllScopes(scope, () => {\n      void handler();\n    }, debounceMs);\n  }\n\n  private applyDirectiveToScope(\n    element: Element,\n    target: DirectiveExpression,\n    expr: string,\n    scope: Scope,\n    debounceMs?: number\n  ): void {\n    if (target.kind === \"attr\" && target.name === \"value\") {\n      this.applyValueBindingToScope(element, expr, debounceMs);\n      return;\n    }\n    if (target.kind === \"attr\" && target.name === \"checked\") {\n      this.applyCheckedBindingToScope(element, expr, debounceMs);\n      return;\n    }\n    const value = this.getDirectiveValue(element, target);\n    if (value != null) {\n      scope.set(expr, value);\n    }\n  }\n\n  private applyCheckedBindingToScope(element: Element, expr: string, debounceMs?: number): void {\n    if (!(element instanceof HTMLInputElement)) {\n      return;\n    }\n    const handler = () => {\n      const scope = this.getScope(element);\n      if (!scope) {\n        return;\n      }\n      scope.set(expr, element.checked);\n    };\n    const effectiveHandler = debounceMs ? debounce(handler, debounceMs) : handler;\n    effectiveHandler();\n    element.addEventListener(\"change\", effectiveHandler);\n    element.addEventListener(\"input\", effectiveHandler);\n  }\n\n  private applyValueBindingToScope(element: Element, expr: string, debounceMs?: number): void {\n    if (!(element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement)) {\n      return;\n    }\n    const handler = () => {\n      const scope = this.getScope(element);\n      applyBindToScope(element, expr, scope);\n    };\n    const effectiveHandler = debounceMs ? debounce(handler, debounceMs) : handler;\n    effectiveHandler();\n    element.addEventListener(\"input\", effectiveHandler);\n    element.addEventListener(\"change\", effectiveHandler);\n  }\n\n  private setDirectiveValue(\n    element: Element,\n    target: DirectiveExpression,\n    value: unknown,\n    trusted: boolean | undefined\n  ): void {\n    if (target.kind === \"attr\" && target.name === \"html\" && element instanceof HTMLElement) {\n      const html = value == null ? \"\" : String(value);\n      element.innerHTML = trusted ? html : html.replace(/<script\\b[^>]*>[\\s\\S]*?<\\/script>/gi, \"\");\n      if (trusted) {\n        this.handleTrustedHtml(element);\n      }\n      return;\n    }\n    if (target.kind === \"attr\") {\n      if (target.name === \"value\") {\n        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n          element.value = value == null ? \"\" : String(value);\n          element.setAttribute(\"value\", element.value);\n          return;\n        }\n        if (element instanceof HTMLSelectElement) {\n          element.value = value == null ? \"\" : String(value);\n          return;\n        }\n      }\n      if (target.name === \"checked\" && element instanceof HTMLInputElement) {\n        const checked = value === true || value === \"true\" || value === 1 || value === \"1\";\n        element.checked = checked;\n        if (checked) {\n          element.setAttribute(\"checked\", \"\");\n        } else {\n          element.removeAttribute(\"checked\");\n        }\n        return;\n      }\n      element.setAttribute(target.name, value == null ? \"\" : String(value));\n      return;\n    }\n    if (target.kind === \"style\" && element instanceof HTMLElement) {\n      element.style.setProperty(target.name, value == null ? \"\" : String(value));\n    }\n  }\n\n  private getDirectiveValue(element: Element, target: DirectiveExpression): unknown {\n    if (target.kind === \"attr\") {\n      if (target.name === \"value\") {\n        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n          return element.value;\n        }\n        if (element instanceof HTMLSelectElement) {\n          return element.value;\n        }\n      }\n      if (target.name === \"checked\" && element instanceof HTMLInputElement) {\n        return element.checked;\n      }\n      return element.getAttribute(target.name) ?? undefined;\n    }\n    if (target.kind === \"style\" && element instanceof HTMLElement) {\n      return element.style.getPropertyValue(target.name) ?? undefined;\n    }\n    return undefined;\n  }\n\n  private handleTrustedHtml(root: Element): void {\n    const scripts = Array.from(root.querySelectorAll('script[type=\"text/vsn\"]'));\n    if (scripts.length === 0) {\n      return;\n    }\n    const source = scripts.map((script) => script.textContent ?? \"\").join(\"\\n\");\n    if (!source.trim()) {\n      return;\n    }\n    this.registerBehaviors(source);\n    void this.applyBehaviors(root);\n  }\n\n  private registerDefaultAttributeHandlers(): void {\n    this.registerAttributeHandler({\n      id: \"vsn-bind\",\n      match: (name) => name.startsWith(\"vsn-bind\"),\n      handle: (element, name, value, scope) => {\n        const direction = this.parseBindDirection(name);\n        this.bindBindings.set(element, { expr: value, direction });\n        if (direction === \"to\" || direction === \"both\") {\n          this.markInlineDeclaration(element, `state:${value}`);\n        }\n        if (direction === \"to\" || direction === \"both\") {\n          applyBindToScope(element, value, scope);\n          this.attachBindInputHandler(element, value);\n        }\n        if (direction === \"from\" || direction === \"both\") {\n          this.watch(scope, value, () => applyBindToElement(element, value, scope));\n        }\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-if\",\n      match: (name) => name === \"vsn-if\",\n      handle: (element, _name, value, scope) => {\n        this.ifBindings.set(element, value);\n        if (element instanceof HTMLElement) {\n          applyIf(element, value, scope);\n        }\n        this.watch(scope, value, () => this.evaluate(element));\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-show\",\n      match: (name) => name === \"vsn-show\",\n      handle: (element, _name, value, scope) => {\n        this.showBindings.set(element, value);\n        if (element instanceof HTMLElement) {\n          applyShow(element, value, scope);\n        }\n        this.watch(scope, value, () => this.evaluate(element));\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-html\",\n      match: (name) => name.startsWith(\"vsn-html\"),\n      handle: (element, name, value, scope) => {\n        const trusted = name.includes(\"!trusted\");\n        this.htmlBindings.set(element, { expr: value, trusted });\n        this.markInlineDeclaration(element, \"attr:html\");\n        if (element instanceof HTMLElement) {\n          applyHtml(element, value, scope, trusted);\n          if (trusted) {\n            this.handleTrustedHtml(element);\n          }\n        }\n        this.watch(scope, value, () => this.evaluate(element));\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-get\",\n      match: (name) => name.startsWith(\"vsn-get\"),\n      handle: (element, name) => {\n        const trusted = name.includes(\"!trusted\");\n        const autoLoad = name.includes(\"!load\");\n        const url = element.getAttribute(name) ?? \"\";\n        const target = element.getAttribute(\"vsn-target\") ?? undefined;\n        const swap = (element.getAttribute(\"vsn-swap\") as \"inner\" | \"outer\" | null) ?? \"inner\";\n        const config: GetConfig = {\n          url,\n          swap,\n          trusted,\n          ...(target ? { targetSelector: target } : {})\n        };\n        this.getBindings.set(element, config);\n        this.attachGetHandler(element, autoLoad);\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-construct\",\n      match: (name) => name === \"vsn-construct\",\n      handle: (element, _name, value) => {\n        this.setLifecycle(element, { construct: value });\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-destruct\",\n      match: (name) => name === \"vsn-destruct\",\n      handle: (element, _name, value) => {\n        this.setLifecycle(element, { destruct: value });\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-on\",\n      match: (name) => name.startsWith(\"vsn-on:\"),\n      handle: (element, name, value) => {\n        const onConfig = this.parseOnAttribute(name, value);\n        if (onConfig) {\n          this.attachOnHandler(element, onConfig);\n        }\n      }\n    });\n  }\n}\n","export const VERSION = \"0.1.0\";\n\nexport { Lexer } from \"./parser/lexer\";\nimport { Parser } from \"./parser/parser\";\nimport { Engine } from \"./runtime/engine\";\nexport { Parser };\nexport { TokenType } from \"./parser/token\";\nexport * from \"./ast/nodes\";\nexport { Engine } from \"./runtime/engine\";\n\nexport function parseCFS(source: string) {\n  const parser = new Parser(source);\n  return parser.parseProgram();\n}\n\nexport function autoMount(root: HTMLElement | Document = document): Engine | null {\n  if (typeof document === \"undefined\") {\n    return null;\n  }\n  const engine = new Engine();\n  const startTime = typeof performance !== \"undefined\" && performance.now ? performance.now() : Date.now();\n  const mount = () => {\n    const target = root instanceof Document ? root.body : root;\n    if (target) {\n      const sources = Array.from(document.querySelectorAll('script[type=\"text/vsn\"]'))\n        .map((script) => script.textContent ?? \"\")\n        .join(\"\\n\");\n      if (sources.trim()) {\n        engine.registerBehaviors(sources);\n      }\n      engine.mount(target);\n      const endTime = typeof performance !== \"undefined\" && performance.now ? performance.now() : Date.now();\n      const elapsedMs = Math.round(endTime - startTime);\n      console.log(`Took ${elapsedMs}ms to start up VSN.js. https://www.vsnjs.com/ v${VERSION}`);\n    }\n  };\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", mount, { once: true });\n  } else {\n    mount();\n  }\n  return engine;\n}\n\nif (typeof document !== \"undefined\") {\n  const scriptTag = document.querySelector(\"script[auto-mount]\");\n  if (scriptTag) {\n    autoMount();\n  }\n}\n"],"mappings":"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","names":["TokenType","KEYWORDS","Lexer","input","tokens","ch","punct","start","value","keywordType","quote","escaped","next","type","offset","BaseNode","type","_context","ProgramNode","behaviors","uses","UseNode","name","alias","BlockNode","statements","context","statement","SelectorNode","selectorText","BehaviorNode","selector","body","StateEntryNode","value","important","StateBlockNode","entries","OnBlockNode","eventName","args","modifiers","AssignmentNode","target","targetPath","IdentifierExpression","ReturnNode","FunctionDeclarationNode","params","FunctionExpression","scope","globals","element","inner","previousValues","i","DeclarationNode","operator","flags","flagArgs","LiteralExpression","UnaryExpression","argument","BinaryExpression","left","right","TernaryExpression","test","consequent","alternate","CallExpression","callee","resolved","fn","values","arg","parts","root","parentPath","methodName","parentValue","parent","part","ArrayExpression","elements","IndexExpression","index","DirectiveExpression","kind","QueryExpression","direction","results","cursor","TokenStream","tokens","offset","token","type","count","i","Parser","_Parser","input","options","lexer","Lexer","TokenStream","code","behaviors","uses","next","ProgramNode","selector","body","BehaviorNode","selectorText","sawNonWhitespace","token","SelectorNode","name","alias","UseNode","fn","error","message","line","column","snippet","content","caret","allowDeclarations","statements","declarationsOpen","sawConstruct","sawFunctionOrOn","BlockNode","allowBlocks","allowReturn","entries","nameToken","value","important","importantToken","StateEntryNode","StateBlockNode","event","args","modifiers","OnBlockNode","target","AssignmentNode","test","consequent","alternate","TernaryExpression","left","right","BinaryExpression","op","operator","argument","UnaryExpression","expr","argToken","CallExpression","index","IndexExpression","kind","DirectiveExpression","IdentifierExpression","LiteralExpression","elements","ArrayExpression","flags","flagArgs","DeclarationNode","numberToken","customArg","first","second","third","depth","direction","QueryExpression","params","param","FunctionDeclarationNode","ReturnNode","FunctionExpression","terminator","part","Scope","parent","key","value","path","root","explicit","targetScope","targetPath","localValue","cursor","scopeForSet","parts","obj","i","lastKey","handler","set","fn","rootKey","scope","start","getElementValue","element","setElementValue","value","applyBindToScope","expression","scope","key","applyBindToElement","readCondition","expression","scope","key","applyIf","element","applyShow","sanitizeHtml","value","applyHtml","element","expression","scope","trusted","key","html","applyGet","element","config","scope","onHtmlApplied","response","html","target","resolveTarget","wrapper","applyHtml","replacement","selector","debounce","fn","waitMs","timer","args","Engine","root","elements","element","parentScope","source","program","Parser","use","value","behavior","name","values","handler","parts","part","existing","scope","Scope","bindConfig","applyBindToElement","ifExpr","applyIf","showExpr","applyShow","htmlBinding","applyHtml","debounce","mutations","mutation","node","removed","added","child","bound","matches","b","onBlock","patch","current","config","expr","applyBindToScope","key","set","parent","target","cursor","debounceMs","effectiveHandler","eventWithFlags","event","flags","modifiers","flag","match","body","evt","autoLoad","applyGet","error","modifier","options","code","block","context","parentSelector","selector","cached","statement","BehaviorNode","idMatches","classMatches","attrMatches","pseudoMatches","elementMatches","declaration","IdentifierExpression","DirectiveExpression","construct","destruct","BlockNode","blocks","OnBlockNode","declarations","DeclarationNode","functions","FunctionDeclarationNode","AssignmentNode","FunctionExpression","hash","lifecycle","fresh","normalized","json","type","entry","arg","i","fn","args","previousValues","operator","importantKey","exprIdentifier","shouldWatch","trusted","watch","html","checked","scripts","script","direction","_name","url","swap","onConfig","VERSION","parseCFS","source","Parser","autoMount","root","engine","Engine","startTime","mount","target","sources","script","endTime","elapsedMs","VERSION"]}