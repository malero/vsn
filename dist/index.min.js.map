{"version":3,"sources":["../src/parser/token.ts","../src/parser/lexer.ts","../src/ast/nodes.ts","../src/parser/token-stream.ts","../src/parser/parser.ts","../src/runtime/scope.ts","../src/runtime/bindings.ts","../src/runtime/conditionals.ts","../src/runtime/html.ts","../src/runtime/http.ts","../src/runtime/debounce.ts","../src/runtime/engine.ts","../src/index.ts"],"sourcesContent":["export enum TokenType {\n  Whitespace = \"Whitespace\",\n  Identifier = \"Identifier\",\n  Number = \"Number\",\n  String = \"String\",\n  Boolean = \"Boolean\",\n  Null = \"Null\",\n\n  Behavior = \"Behavior\",\n  State = \"State\",\n  On = \"On\",\n  Construct = \"Construct\",\n  Destruct = \"Destruct\",\n\n  LBrace = \"LBrace\",\n  RBrace = \"RBrace\",\n  LParen = \"LParen\",\n  RParen = \"RParen\",\n  LBracket = \"LBracket\",\n  RBracket = \"RBracket\",\n\n  Colon = \"Colon\",\n  Semicolon = \"Semicolon\",\n  Comma = \"Comma\",\n\n  Dot = \"Dot\",\n  Hash = \"Hash\",\n  Greater = \"Greater\",\n  Less = \"Less\",\n  Plus = \"Plus\",\n  Minus = \"Minus\",\n  Tilde = \"Tilde\",\n  Star = \"Star\",\n\n  Equals = \"Equals\",\n  Bang = \"Bang\",\n\n  At = \"At\",\n  Dollar = \"Dollar\",\n  Question = \"Question\"\n}\n\nexport interface Position {\n  index: number;\n  line: number;\n  column: number;\n}\n\nexport interface Token {\n  type: TokenType;\n  value: string;\n  start: Position;\n  end: Position;\n}\n","import { Token, TokenType } from \"./token\";\n\nconst KEYWORDS: Record<string, TokenType> = {\n  behavior: TokenType.Behavior,\n  state: TokenType.State,\n  on: TokenType.On,\n  construct: TokenType.Construct,\n  destruct: TokenType.Destruct,\n  true: TokenType.Boolean,\n  false: TokenType.Boolean,\n  null: TokenType.Null\n};\n\nexport class Lexer {\n  private index = 0;\n  private line = 1;\n  private column = 1;\n\n  constructor(private input: string) {}\n\n  tokenize(): Token[] {\n    const tokens: Token[] = [];\n\n    while (!this.eof()) {\n      const ch = this.peek();\n\n      if (this.isWhitespace(ch)) {\n        tokens.push(this.readWhitespace());\n        continue;\n      }\n\n      if (ch === \"/\" && this.peek(1) === \"/\") {\n        this.readLineComment();\n        continue;\n      }\n\n      if (ch === \"/\" && this.peek(1) === \"*\") {\n        this.readBlockComment();\n        continue;\n      }\n\n      if (this.isAlpha(ch) || ch === \"_\") {\n        tokens.push(this.readIdentifier());\n        continue;\n      }\n\n      if (this.isDigit(ch) || (ch === \"-\" && this.isDigit(this.peek(1)))) {\n        tokens.push(this.readNumber());\n        continue;\n      }\n\n      if (ch === \"\\\"\" || ch === \"'\") {\n        tokens.push(this.readString());\n        continue;\n      }\n\n      const punct = this.readPunctuator();\n      if (punct) {\n        tokens.push(punct);\n        continue;\n      }\n\n      throw new Error(`Unexpected character '${ch}' at ${this.line}:${this.column}`);\n    }\n\n    return tokens;\n  }\n\n  private readWhitespace(): Token {\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof() && this.isWhitespace(this.peek())) {\n      value += this.next();\n    }\n    return this.token(TokenType.Whitespace, value, start);\n  }\n\n  private readLineComment(): void {\n    this.next();\n    this.next();\n    while (!this.eof() && this.peek() !== \"\\n\") {\n      this.next();\n    }\n  }\n\n  private readBlockComment(): void {\n    this.next();\n    this.next();\n    while (!this.eof()) {\n      if (this.peek() === \"*\" && this.peek(1) === \"/\") {\n        this.next();\n        this.next();\n        return;\n      }\n      this.next();\n    }\n  }\n\n  private readIdentifier(): Token {\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof() && (this.isAlphaNumeric(this.peek()) || this.peek() === \"_\" || this.peek() === \"-\")) {\n      value += this.next();\n    }\n\n    const keywordType = KEYWORDS[value];\n    if (keywordType) {\n      return this.token(keywordType, value, start);\n    }\n\n    return this.token(TokenType.Identifier, value, start);\n  }\n\n  private readNumber(): Token {\n    const start = this.position();\n    let value = \"\";\n    if (this.peek() === \"-\") {\n      value += this.next();\n    }\n    while (!this.eof() && this.isDigit(this.peek())) {\n      value += this.next();\n    }\n    if (this.peek() === \".\") {\n      value += this.next();\n      while (!this.eof() && this.isDigit(this.peek())) {\n        value += this.next();\n      }\n    }\n    return this.token(TokenType.Number, value, start);\n  }\n\n  private readString(): Token {\n    const quote = this.next();\n    const start = this.position();\n    let value = \"\";\n    while (!this.eof()) {\n      const ch = this.next();\n      if (ch === \"\\\\\") {\n        const escaped = this.next();\n        value += escaped;\n        continue;\n      }\n      if (ch === quote) {\n        return this.token(TokenType.String, value, start);\n      }\n      value += ch;\n    }\n    throw new Error(`Unterminated string at ${start.line}:${start.column}`);\n  }\n\n  private readPunctuator(): Token | null {\n    const start = this.position();\n    const ch = this.peek();\n    const punctMap: Record<string, TokenType> = {\n      \"{\": TokenType.LBrace,\n      \"}\": TokenType.RBrace,\n      \"(\": TokenType.LParen,\n      \")\": TokenType.RParen,\n      \"[\": TokenType.LBracket,\n      \"]\": TokenType.RBracket,\n      \":\": TokenType.Colon,\n      \";\": TokenType.Semicolon,\n      \",\": TokenType.Comma,\n      \".\": TokenType.Dot,\n      \"#\": TokenType.Hash,\n      \">\": TokenType.Greater,\n      \"<\": TokenType.Less,\n      \"+\": TokenType.Plus,\n      \"-\": TokenType.Minus,\n      \"~\": TokenType.Tilde,\n      \"*\": TokenType.Star,\n      \"=\": TokenType.Equals,\n      \"!\": TokenType.Bang,\n      \"@\": TokenType.At,\n      \"$\": TokenType.Dollar,\n      \"?\": TokenType.Question\n    };\n\n    const type = punctMap[ch];\n    if (!type) {\n      return null;\n    }\n\n    this.next();\n    return this.token(type, ch, start);\n  }\n\n  private token(type: TokenType, value: string, start: { index: number; line: number; column: number }): Token {\n    return {\n      type,\n      value,\n      start,\n      end: this.position()\n    };\n  }\n\n  private position() {\n    return { index: this.index, line: this.line, column: this.column };\n  }\n\n  private peek(offset = 0): string {\n    return this.input[this.index + offset] ?? \"\";\n  }\n\n  private next(): string {\n    const ch = this.input[this.index++] ?? \"\";\n    if (ch === \"\\n\") {\n      this.line += 1;\n      this.column = 1;\n    } else {\n      this.column += 1;\n    }\n    return ch;\n  }\n\n  private eof(): boolean {\n    return this.index >= this.input.length;\n  }\n\n  private isWhitespace(ch: string): boolean {\n    return ch === \" \" || ch === \"\\t\" || ch === \"\\n\" || ch === \"\\r\";\n  }\n\n  private isAlpha(ch: string): boolean {\n    return (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\");\n  }\n\n  private isDigit(ch: string): boolean {\n    return ch >= \"0\" && ch <= \"9\";\n  }\n\n  private isAlphaNumeric(ch: string): boolean {\n    return this.isAlpha(ch) || this.isDigit(ch);\n  }\n}\n","export interface ExecutionContext {\n  scope?: {\n    getPath(key: string): any;\n    setPath?(key: string, value: any): void;\n  };\n}\n\nexport interface CFSNode {\n  type: string;\n  prepare(context: ExecutionContext): Promise<void>;\n  evaluate(context: ExecutionContext): Promise<any>;\n}\n\nexport abstract class BaseNode implements CFSNode {\n  constructor(public type: string) {}\n\n  async prepare(_context: ExecutionContext): Promise<void> {\n    return;\n  }\n\n  async evaluate(_context: ExecutionContext): Promise<any> {\n    return undefined;\n  }\n}\n\nexport class ProgramNode extends BaseNode {\n  constructor(public behaviors: BehaviorNode[]) {\n    super(\"Program\");\n  }\n}\n\nexport class BlockNode extends BaseNode {\n  constructor(public statements: CFSNode[]) {\n    super(\"Block\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    for (const statement of this.statements) {\n      if (statement && typeof statement.evaluate === \"function\") {\n        await statement.evaluate(context);\n      }\n    }\n  }\n}\n\nexport class SelectorNode extends BaseNode {\n  constructor(public selectorText: string) {\n    super(\"Selector\");\n  }\n}\n\nexport class BehaviorNode extends BaseNode {\n  constructor(public selector: SelectorNode, public body: BlockNode) {\n    super(\"Behavior\");\n  }\n}\n\nexport class StateEntryNode extends BaseNode {\n  constructor(\n    public name: string,\n    public value: ExpressionNode,\n    public important: boolean\n  ) {\n    super(\"StateEntry\");\n  }\n}\n\nexport class StateBlockNode extends BaseNode {\n  constructor(public entries: StateEntryNode[]) {\n    super(\"StateBlock\");\n  }\n}\n\nexport class OnBlockNode extends BaseNode {\n  constructor(\n    public eventName: string,\n    public args: string[],\n    public body: BlockNode\n  ) {\n    super(\"OnBlock\");\n  }\n}\n\nexport class AssignmentNode extends BaseNode {\n  constructor(public target: AssignmentTarget, public value: ExpressionNode) {\n    super(\"Assignment\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    if (!context.scope || !context.scope.setPath) {\n      return undefined;\n    }\n    let targetPath: string | undefined;\n    if (this.target instanceof IdentifierExpression) {\n      targetPath = this.target.name;\n    }\n    if (!targetPath) {\n      return undefined;\n    }\n    const value = await this.value.evaluate(context);\n    context.scope.setPath(targetPath, value);\n    return value;\n  }\n}\n\nexport interface DeclarationFlags {\n  important?: boolean;\n  trusted?: boolean;\n  debounce?: boolean;\n}\n\nexport interface DeclarationFlagArgs {\n  debounce?: number;\n}\n\nexport class DeclarationNode extends BaseNode {\n  constructor(\n    public target: DeclarationTarget,\n    public operator: \":\" | \":=\" | \":<\" | \":>\",\n    public value: ExpressionNode,\n    public flags: DeclarationFlags,\n    public flagArgs: DeclarationFlagArgs\n  ) {\n    super(\"Declaration\");\n  }\n}\n\nexport type ExpressionNode =\n  | IdentifierExpression\n  | LiteralExpression\n  | UnaryExpression\n  | BinaryExpression\n  | DirectiveExpression\n  | QueryExpression;\n\nexport type DeclarationTarget = IdentifierExpression | DirectiveExpression;\nexport type AssignmentTarget = IdentifierExpression | DirectiveExpression;\n\nexport class IdentifierExpression extends BaseNode {\n  constructor(public name: string) {\n    super(\"Identifier\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    if (!context.scope) {\n      return undefined;\n    }\n    return context.scope.getPath(this.name);\n  }\n}\n\nexport class LiteralExpression extends BaseNode {\n  constructor(public value: string | number | boolean | null) {\n    super(\"Literal\");\n  }\n\n  async evaluate(): Promise<any> {\n    return this.value;\n  }\n}\n\nexport class UnaryExpression extends BaseNode {\n  constructor(public operator: string, public argument: ExpressionNode) {\n    super(\"UnaryExpression\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    const value = await this.argument.evaluate(context);\n    if (this.operator === \"!\") {\n      return !value;\n    }\n    if (this.operator === \"-\") {\n      return -(value as any);\n    }\n    return value;\n  }\n}\n\nexport class BinaryExpression extends BaseNode {\n  constructor(\n    public operator: string,\n    public left: ExpressionNode,\n    public right: ExpressionNode\n  ) {\n    super(\"BinaryExpression\");\n  }\n\n  async evaluate(context: ExecutionContext): Promise<any> {\n    const left = await this.left.evaluate(context);\n    const right = await this.right.evaluate(context);\n    if (this.operator === \"+\") {\n      return (left as any) + (right as any);\n    }\n    if (this.operator === \"-\") {\n      return (left as any) - (right as any);\n    }\n    return undefined;\n  }\n}\n\nexport class DirectiveExpression extends BaseNode {\n  constructor(public kind: \"attr\" | \"style\", public name: string) {\n    super(\"Directive\");\n  }\n\n  async evaluate(): Promise<any> {\n    return `${this.kind}:${this.name}`;\n  }\n}\n\nexport class QueryExpression extends BaseNode {\n  constructor(public direction: \"self\" | \"descendant\" | \"ancestor\", public selector: string) {\n    super(\"Query\");\n  }\n}\n","import { Token, TokenType } from \"./token\";\n\nexport class TokenStream {\n  private index = 0;\n\n  constructor(private tokens: Token[]) {}\n\n  peek(offset = 0): Token | null {\n    return this.tokens[this.index + offset] ?? null;\n  }\n\n  next(): Token {\n    const token = this.tokens[this.index++];\n    if (!token) {\n      throw new Error(\"Unexpected end of input\");\n    }\n    return token;\n  }\n\n  eof(): boolean {\n    return this.index >= this.tokens.length;\n  }\n\n  match(type: TokenType): boolean {\n    if (this.peek()?.type === type) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n\n  expect(type: TokenType): Token {\n    const token = this.next();\n    if (token.type !== type) {\n      throw new Error(`Expected ${type} but got ${token.type}`);\n    }\n    return token;\n  }\n\n  skipWhitespace(): void {\n    while (this.peek()?.type === TokenType.Whitespace) {\n      this.next();\n    }\n  }\n\n  peekNonWhitespace(offset = 0): Token | null {\n    let count = 0;\n    for (let i = this.index; i < this.tokens.length; i++) {\n      const token = this.tokens[i];\n      if (token.type === TokenType.Whitespace) {\n        continue;\n      }\n      if (count === offset) {\n        return token;\n      }\n      count += 1;\n    }\n    return null;\n  }\n}\n","import {\n  AssignmentNode,\n  BehaviorNode,\n  BinaryExpression,\n  BlockNode,\n  AssignmentTarget,\n  DeclarationNode,\n  DeclarationTarget,\n  DeclarationFlags,\n  DeclarationFlagArgs,\n  DirectiveExpression,\n  IdentifierExpression,\n  LiteralExpression,\n  OnBlockNode,\n  ProgramNode,\n  QueryExpression,\n  SelectorNode,\n  StateBlockNode,\n  StateEntryNode,\n  UnaryExpression,\n  ExpressionNode\n} from \"../ast/nodes\";\nimport { Lexer } from \"./lexer\";\nimport { TokenStream } from \"./token-stream\";\nimport { TokenType } from \"./token\";\n\nexport class Parser {\n  private stream: TokenStream;\n\n  constructor(input: string) {\n    const lexer = new Lexer(input);\n    this.stream = new TokenStream(lexer.tokenize());\n  }\n\n  static parseInline(code: string): BlockNode {\n    const parser = new Parser(`{${code}}`);\n    return parser.parseInlineBlock();\n  }\n\n  parseProgram(): ProgramNode {\n    const behaviors: BehaviorNode[] = [];\n    this.stream.skipWhitespace();\n    while (!this.stream.eof()) {\n      behaviors.push(this.parseBehavior());\n      this.stream.skipWhitespace();\n    }\n    return new ProgramNode(behaviors);\n  }\n\n  parseInlineBlock(): BlockNode {\n    this.stream.skipWhitespace();\n    return this.parseBlock({ allowDeclarations: false });\n  }\n\n  private parseBehavior(): BehaviorNode {\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Behavior);\n    const selector = this.parseSelector();\n    const body = this.parseBlock({ allowDeclarations: true });\n    return new BehaviorNode(selector, body);\n  }\n\n  private parseSelector(): SelectorNode {\n    let selectorText = \"\";\n    let sawNonWhitespace = false;\n\n    while (true) {\n      const token = this.stream.peek();\n      if (!token) {\n        break;\n      }\n\n      if (token.type === TokenType.LBrace) {\n        break;\n      }\n\n      if (token.type === TokenType.Whitespace) {\n        this.stream.next();\n        if (sawNonWhitespace && selectorText[selectorText.length - 1] !== \" \") {\n          selectorText += \" \";\n        }\n        continue;\n      }\n\n      sawNonWhitespace = true;\n      selectorText += this.stream.next().value;\n    }\n\n    if (!selectorText.trim()) {\n      throw new Error(\"Behavior selector is required\");\n    }\n\n    return new SelectorNode(selectorText.trim());\n  }\n\n  private parseBlock(options?: { allowDeclarations?: boolean }): BlockNode {\n    const allowDeclarations = options?.allowDeclarations ?? false;\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LBrace);\n    const statements = [];\n    let declarationsOpen = allowDeclarations;\n\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated block\");\n      }\n      if (next.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n\n      const isDeclaration = this.isDeclarationStart();\n      if (isDeclaration) {\n        if (!allowDeclarations) {\n          throw new Error(\"Declarations are only allowed at the behavior root\");\n        }\n        if (!declarationsOpen) {\n          throw new Error(\"Declarations must appear before blocks\");\n        }\n        statements.push(this.parseDeclaration());\n      } else {\n        if (declarationsOpen) {\n          declarationsOpen = false;\n        }\n        statements.push(this.parseStatement());\n      }\n    }\n\n    return new BlockNode(statements);\n  }\n\n  private parseStatement() {\n    this.stream.skipWhitespace();\n    const next = this.stream.peek();\n    if (!next) {\n      throw new Error(\"Unexpected end of input\");\n    }\n\n    if (next.type === TokenType.On) {\n      return this.parseOnBlock();\n    }\n\n    if (next.type === TokenType.Construct) {\n      return this.parseConstructBlock();\n    }\n\n    if (next.type === TokenType.Destruct) {\n      return this.parseDestructBlock();\n    }\n\n    if (next.type === TokenType.Behavior) {\n      return this.parseBehavior();\n    }\n\n    if (this.isAssignmentStart()) {\n      return this.parseAssignment();\n    }\n\n    throw new Error(`Unexpected token ${next.type}`);\n  }\n\n  private parseStateBlock(): StateBlockNode {\n    this.stream.expect(TokenType.State);\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LBrace);\n\n    const entries: StateEntryNode[] = [];\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated state block\");\n      }\n      if (next.type === TokenType.RBrace) {\n        this.stream.next();\n        break;\n      }\n\n      const nameToken = this.stream.expect(TokenType.Identifier);\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Colon);\n      this.stream.skipWhitespace();\n      const value = this.parseExpression();\n      this.stream.skipWhitespace();\n\n      let important = false;\n      if (this.stream.peek()?.type === TokenType.Bang) {\n        this.stream.next();\n        this.stream.skipWhitespace();\n        const importantToken = this.stream.next();\n        if (importantToken.type === TokenType.Identifier && importantToken.value === \"important\") {\n          important = true;\n        } else {\n          throw new Error(\"Expected 'important' after '!'\");\n        }\n      }\n\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.Semicolon);\n      entries.push(new StateEntryNode(nameToken.value, value, important));\n    }\n\n    return new StateBlockNode(entries);\n  }\n\n  private parseOnBlock(): OnBlockNode {\n    this.stream.expect(TokenType.On);\n    this.stream.skipWhitespace();\n    const event = this.stream.expect(TokenType.Identifier);\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    const args: string[] = [];\n\n    while (true) {\n      this.stream.skipWhitespace();\n      const next = this.stream.peek();\n      if (!next) {\n        throw new Error(\"Unterminated on() arguments\");\n      }\n      if (next.type === TokenType.RParen) {\n        this.stream.next();\n        break;\n      }\n      if (next.type === TokenType.Identifier) {\n        args.push(this.stream.next().value);\n        this.stream.skipWhitespace();\n        if (this.stream.peek()?.type === TokenType.Comma) {\n          this.stream.next();\n        }\n        continue;\n      }\n      throw new Error(`Unexpected token in on() args: ${next.type}`);\n    }\n\n    const body = this.parseBlock({ allowDeclarations: false });\n    return new OnBlockNode(event.value, args, body);\n  }\n\n  private parseAssignment(): AssignmentNode {\n    const target = this.parseAssignmentTarget();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Equals);\n    this.stream.skipWhitespace();\n    const value = this.parseExpression();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Semicolon);\n    return new AssignmentNode(target, value);\n  }\n\n  private parseExpression(): ExpressionNode {\n    return this.parseAdditiveExpression();\n  }\n\n  private parseAdditiveExpression(): ExpressionNode {\n    let left = this.parseUnaryExpression();\n    this.stream.skipWhitespace();\n    while (true) {\n      const next = this.stream.peekNonWhitespace(0);\n      if (!next || (next.type !== TokenType.Plus && next.type !== TokenType.Minus)) {\n        break;\n      }\n      this.stream.skipWhitespace();\n      const op = this.stream.next();\n      this.stream.skipWhitespace();\n      const right = this.parseUnaryExpression();\n      this.stream.skipWhitespace();\n      left = new BinaryExpression(op.type === TokenType.Plus ? \"+\" : \"-\", left, right);\n    }\n    return left;\n  }\n\n  private parseUnaryExpression(): ExpressionNode {\n    this.stream.skipWhitespace();\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected expression\");\n    }\n    if (token.type === TokenType.Bang) {\n      this.stream.next();\n      const argument = this.parseUnaryExpression();\n      return new UnaryExpression(\"!\", argument);\n    }\n    if (token.type === TokenType.Minus) {\n      this.stream.next();\n      const argument = this.parseUnaryExpression();\n      return new UnaryExpression(\"-\", argument);\n    }\n    return this.parsePrimaryExpression();\n  }\n\n  private parsePrimaryExpression(): ExpressionNode {\n    this.stream.skipWhitespace();\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected expression\");\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier);\n      return new DirectiveExpression(kind, name.value);\n    }\n\n    if (token.type === TokenType.Question) {\n      return this.parseQueryExpression();\n    }\n\n    if (token.type === TokenType.LParen) {\n      this.stream.next();\n      const value = this.parseExpression();\n      this.stream.skipWhitespace();\n      this.stream.expect(TokenType.RParen);\n      return value;\n    }\n\n    if (token.type === TokenType.Identifier) {\n      const name = this.parseIdentifierPath();\n      return new IdentifierExpression(name);\n    }\n\n    if (token.type === TokenType.Boolean) {\n      return new LiteralExpression(this.stream.next().value === \"true\");\n    }\n\n    if (token.type === TokenType.Null) {\n      this.stream.next();\n      return new LiteralExpression(null);\n    }\n\n    if (token.type === TokenType.Number) {\n      return new LiteralExpression(Number(this.stream.next().value));\n    }\n\n    if (token.type === TokenType.String) {\n      return new LiteralExpression(this.stream.next().value);\n    }\n\n    throw new Error(`Unsupported expression token ${token.type}`);\n  }\n\n  private parseAssignmentTarget(): AssignmentTarget {\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected assignment target\");\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier);\n      return new DirectiveExpression(kind, name.value);\n    }\n\n    if (token.type === TokenType.Identifier) {\n      return new IdentifierExpression(this.parseIdentifierPath());\n    }\n\n    throw new Error(`Invalid assignment target ${token.type}`);\n  }\n\n  private parseDeclaration(): DeclarationNode {\n    const target = this.parseDeclarationTarget();\n    this.stream.skipWhitespace();\n    const operator = this.parseDeclarationOperator();\n    this.stream.skipWhitespace();\n    const value = this.parseExpression();\n    const { flags, flagArgs } = this.parseFlags();\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.Semicolon);\n    return new DeclarationNode(target, operator, value, flags, flagArgs);\n  }\n\n  private parseDeclarationTarget(): DeclarationTarget {\n    const token = this.stream.peek();\n    if (!token) {\n      throw new Error(\"Expected declaration target\");\n    }\n\n    if (token.type === TokenType.At || token.type === TokenType.Dollar) {\n      const kind = token.type === TokenType.At ? \"attr\" : \"style\";\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier);\n      return new DirectiveExpression(kind, name.value);\n    }\n\n    if (token.type === TokenType.Identifier) {\n      return new IdentifierExpression(this.stream.next().value);\n    }\n\n    throw new Error(`Invalid declaration target ${token.type}`);\n  }\n\n  private parseDeclarationOperator(): \":\" | \":=\" | \":<\" | \":>\" {\n    this.stream.expect(TokenType.Colon);\n    const next = this.stream.peek();\n    if (!next) {\n      return \":\";\n    }\n    if (next.type === TokenType.Equals) {\n      this.stream.next();\n      return \":=\";\n    }\n    if (next.type === TokenType.Less) {\n      this.stream.next();\n      return \":<\";\n    }\n    if (next.type === TokenType.Greater) {\n      this.stream.next();\n      return \":>\";\n    }\n    return \":\";\n  }\n\n  private parseFlags(): { flags: DeclarationFlags; flagArgs: DeclarationFlagArgs } {\n    const flags: DeclarationFlags = {};\n    const flagArgs: DeclarationFlagArgs = {};\n\n    while (true) {\n      this.stream.skipWhitespace();\n      if (this.stream.peek()?.type !== TokenType.Bang) {\n        break;\n      }\n      this.stream.next();\n      const name = this.stream.expect(TokenType.Identifier).value;\n\n      if (name === \"important\") {\n        flags.important = true;\n      } else if (name === \"trusted\") {\n        flags.trusted = true;\n      } else if (name === \"debounce\") {\n        flags.debounce = true;\n        if (this.stream.peek()?.type === TokenType.LParen) {\n          this.stream.next();\n          this.stream.skipWhitespace();\n          const numberToken = this.stream.expect(TokenType.Number);\n          flagArgs.debounce = Number(numberToken.value);\n          this.stream.skipWhitespace();\n          this.stream.expect(TokenType.RParen);\n        } else {\n          flagArgs.debounce = 200;\n        }\n      } else {\n        throw new Error(`Unknown flag ${name}`);\n      }\n    }\n\n    return { flags, flagArgs };\n  }\n\n  private isDeclarationStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first) {\n      return false;\n    }\n\n    if (first.type === TokenType.Identifier) {\n      const second = this.stream.peekNonWhitespace(1);\n      return second?.type === TokenType.Colon;\n    }\n\n    if (first.type === TokenType.At || first.type === TokenType.Dollar) {\n      const second = this.stream.peekNonWhitespace(1);\n      const third = this.stream.peekNonWhitespace(2);\n      return second?.type === TokenType.Identifier && third?.type === TokenType.Colon;\n    }\n\n    return false;\n  }\n\n  private isAssignmentStart(): boolean {\n    const first = this.stream.peekNonWhitespace(0);\n    if (!first) {\n      return false;\n    }\n\n    if (first.type === TokenType.Identifier) {\n      const second = this.stream.peekNonWhitespace(1);\n      return second?.type === TokenType.Equals || second?.type === TokenType.Dot;\n    }\n\n    if (first.type === TokenType.At || first.type === TokenType.Dollar) {\n      const second = this.stream.peekNonWhitespace(1);\n      const third = this.stream.peekNonWhitespace(2);\n      return second?.type === TokenType.Identifier && third?.type === TokenType.Equals;\n    }\n\n    return false;\n  }\n\n  private parseConstructBlock(): BlockNode {\n    this.stream.expect(TokenType.Construct);\n    const body = this.parseBlock({ allowDeclarations: false });\n    body.type = \"Construct\";\n    return body;\n  }\n\n  private parseDestructBlock(): BlockNode {\n    this.stream.expect(TokenType.Destruct);\n    const body = this.parseBlock({ allowDeclarations: false });\n    body.type = \"Destruct\";\n    return body;\n  }\n\n  private parseQueryExpression(): QueryExpression {\n    this.stream.expect(TokenType.Question);\n    let direction: \"self\" | \"descendant\" | \"ancestor\" = \"self\";\n\n    if (this.stream.peek()?.type === TokenType.Greater) {\n      this.stream.next();\n      direction = \"descendant\";\n    } else if (this.stream.peek()?.type === TokenType.Less) {\n      this.stream.next();\n      direction = \"ancestor\";\n    }\n\n    this.stream.skipWhitespace();\n    this.stream.expect(TokenType.LParen);\n    const selector = this.readSelectorUntil(TokenType.RParen);\n    return new QueryExpression(direction, selector);\n  }\n\n  private readSelectorUntil(terminator: TokenType): string {\n    let selectorText = \"\";\n    let sawNonWhitespace = false;\n\n    while (true) {\n      const token = this.stream.peek();\n      if (!token) {\n        throw new Error(\"Unterminated selector\");\n      }\n      if (token.type === terminator) {\n        this.stream.next();\n        break;\n      }\n\n      if (token.type === TokenType.Whitespace) {\n        this.stream.next();\n        if (sawNonWhitespace && selectorText[selectorText.length - 1] !== \" \") {\n          selectorText += \" \";\n        }\n        continue;\n      }\n\n      sawNonWhitespace = true;\n      selectorText += this.stream.next().value;\n    }\n\n    return selectorText.trim();\n  }\n\n  private parseIdentifierPath(): string {\n    let value = this.stream.expect(TokenType.Identifier).value;\n    while (this.stream.peek()?.type === TokenType.Dot) {\n      this.stream.next();\n      const part = this.stream.expect(TokenType.Identifier).value;\n      value = `${value}.${part}`;\n    }\n    return value;\n  }\n}\n","export class Scope {\n  private data = new Map<string, any>();\n  private root: Scope;\n  private listeners = new Map<string, Set<() => void>>();\n\n  constructor(public readonly parent?: Scope) {\n    this.root = parent ? parent.root : this;\n  }\n\n  get(key: string): any {\n    return this.getPath(key);\n  }\n\n  set(key: string, value: any): void {\n    this.setPath(key, value);\n  }\n\n  getPath(path: string): any {\n    const { targetScope, targetPath } = this.resolveScope(path);\n    if (!targetScope || !targetPath) {\n      return undefined;\n    }\n\n    const parts = targetPath.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return undefined;\n    }\n    let value = targetScope.data.get(root);\n    for (let i = 1; i < parts.length; i += 1) {\n      if (value == null) {\n        return undefined;\n      }\n      const key = parts[i];\n      if (!key) {\n        return undefined;\n      }\n      value = value[key];\n    }\n    return value;\n  }\n\n  setPath(path: string, value: any): void {\n    const { targetScope, targetPath } = this.resolveScope(path);\n    if (!targetScope || !targetPath) {\n      return;\n    }\n\n    const parts = targetPath.split(\".\");\n    const root = parts[0];\n    if (!root) {\n      return;\n    }\n    if (parts.length === 1) {\n      targetScope.data.set(root, value);\n      targetScope.emitChange(targetPath);\n      return;\n    }\n    let obj = targetScope.data.get(root);\n    if (obj == null || typeof obj !== \"object\") {\n      obj = {};\n      targetScope.data.set(root, obj);\n    }\n    let cursor = obj;\n    for (let i = 1; i < parts.length - 1; i += 1) {\n      const key = parts[i];\n      if (!key) {\n        return;\n      }\n      if (cursor[key] == null || typeof cursor[key] !== \"object\") {\n        cursor[key] = {};\n      }\n      cursor = cursor[key];\n    }\n    const lastKey = parts[parts.length - 1];\n    if (!lastKey) {\n      return;\n    }\n    cursor[lastKey] = value;\n    this.emitChange(path);\n  }\n\n  on(path: string, handler: () => void): void {\n    const key = path.trim();\n    if (!key) {\n      return;\n    }\n    const set = this.listeners.get(key) ?? new Set<() => void>();\n    set.add(handler);\n    this.listeners.set(key, set);\n  }\n\n  off(path: string, handler: () => void): void {\n    const key = path.trim();\n    const set = this.listeners.get(key);\n    if (!set) {\n      return;\n    }\n    set.delete(handler);\n    if (set.size === 0) {\n      this.listeners.delete(key);\n    }\n  }\n\n  private emitChange(path: string): void {\n    const key = path.trim();\n    if (!key) {\n      return;\n    }\n    this.listeners.get(key)?.forEach((fn) => fn());\n    const rootKey = key.split(\".\")[0];\n    if (rootKey && rootKey !== key) {\n      this.listeners.get(rootKey)?.forEach((fn) => fn());\n    }\n  }\n\n  private resolveScope(path: string): { targetScope: Scope | undefined; targetPath: string | undefined } {\n    if (path.startsWith(\"parent.\")) {\n      return { targetScope: this.parent, targetPath: path.slice(\"parent.\".length) };\n    }\n    if (path.startsWith(\"root.\")) {\n      return { targetScope: this.root, targetPath: path.slice(\"root.\".length) };\n    }\n    if (path.startsWith(\"self.\")) {\n      return { targetScope: this, targetPath: path.slice(\"self.\".length) };\n    }\n    return { targetScope: this, targetPath: path };\n  }\n}\n","import { Scope } from \"./scope\";\n\nexport type BindDirection = \"both\" | \"from\" | \"to\";\n\nfunction getElementValue(element: Element): string {\n  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n    return element.value;\n  }\n  return element.textContent ?? \"\";\n}\n\nfunction setElementValue(element: Element, value: string): void {\n  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n    element.value = value;\n    element.setAttribute(\"value\", value);\n    return;\n  }\n  element.textContent = value;\n}\n\nexport function applyBindToScope(element: Element, expression: string, scope: Scope): void {\n  const key = expression.trim();\n  if (!key) {\n    return;\n  }\n\n  const value = getElementValue(element).trim();\n  if (value !== \"\") {\n    scope.set(key, value);\n  }\n}\n\nexport function applyBindToElement(element: Element, expression: string, scope: Scope): void {\n  const key = expression.trim();\n  if (!key) {\n    return;\n  }\n  const value = scope.get(key);\n  if (value == null) {\n    return;\n  }\n  setElementValue(element, String(value));\n}\n","import { Scope } from \"./scope\";\n\nfunction readCondition(expression: string, scope: Scope): boolean {\n  const key = expression.trim();\n  if (!key) {\n    return false;\n  }\n  return !!scope.get(key);\n}\n\nexport function applyIf(element: HTMLElement, expression: string, scope: Scope): void {\n  element.style.display = readCondition(expression, scope) ? \"\" : \"none\";\n}\n\nexport function applyShow(element: HTMLElement, expression: string, scope: Scope): void {\n  element.style.display = readCondition(expression, scope) ? \"\" : \"none\";\n}\n","import { Scope } from \"./scope\";\n\nfunction sanitizeHtml(value: string): string {\n  return value.replace(/<script\\b[^>]*>[\\s\\S]*?<\\/script>/gi, \"\");\n}\n\nexport function applyHtml(\n  element: HTMLElement,\n  expression: string,\n  scope: Scope,\n  trusted: boolean\n): void {\n  const key = expression.trim();\n  if (!key) {\n    return;\n  }\n  const value = scope.get(key);\n  const html = value == null ? \"\" : String(value);\n  element.innerHTML = trusted ? html : sanitizeHtml(html);\n}\n","import { applyHtml } from \"./html\";\nimport { Scope } from \"./scope\";\n\nexport interface GetConfig {\n  url: string;\n  targetSelector?: string;\n  swap?: \"inner\" | \"outer\";\n  trusted: boolean;\n}\n\nexport async function applyGet(\n  element: Element,\n  config: GetConfig,\n  scope: Scope\n): Promise<void> {\n  if (!globalThis.fetch) {\n    throw new Error(\"fetch is not available\");\n  }\n\n  const response = await globalThis.fetch(config.url);\n  if (!response || !response.ok) {\n    return;\n  }\n\n  const html = await response.text();\n  const target = resolveTarget(element, config.targetSelector);\n  if (!target) {\n    element.dispatchEvent(new CustomEvent(\"vsn:targetError\", { detail: { selector: config.targetSelector } }));\n    return;\n  }\n\n  if (config.swap === \"outer\") {\n    const wrapper = document.createElement(\"div\");\n    applyHtml(wrapper, \"__html\", { get: () => html } as Scope, config.trusted);\n    const replacement = wrapper.firstElementChild;\n    if (replacement && target.parentNode) {\n      target.parentNode.replaceChild(replacement, target);\n    }\n    return;\n  }\n\n  applyHtml(target as HTMLElement, \"__html\", { get: () => html } as Scope, config.trusted);\n}\n\nfunction resolveTarget(element: Element, selector?: string): Element | null {\n  if (!selector) {\n    return element;\n  }\n  return element.ownerDocument.querySelector(selector);\n}\n","type Debounced = (...args: any[]) => void;\n\nexport function debounce<T extends (...args: any[]) => void>(fn: T, waitMs: number): Debounced {\n  let timer: ReturnType<typeof setTimeout> | undefined;\n  return (...args: any[]) => {\n    if (timer) {\n      clearTimeout(timer);\n    }\n    timer = setTimeout(() => {\n      timer = undefined;\n      fn(...args);\n    }, waitMs);\n  };\n}\n","import { Scope } from \"./scope\";\nimport { applyBindToElement, applyBindToScope, BindDirection } from \"./bindings\";\nimport { applyIf, applyShow } from \"./conditionals\";\nimport { applyHtml } from \"./html\";\nimport { applyGet, GetConfig } from \"./http\";\nimport { debounce } from \"./debounce\";\nimport { Parser } from \"../parser/parser\";\nimport { BehaviorNode, BlockNode, ExecutionContext } from \"../ast/nodes\";\n\ninterface OnConfig {\n  event: string;\n  code: string;\n  debounceMs?: number;\n}\n\ninterface BindConfig {\n  expr: string;\n  direction: BindDirection;\n}\n\ninterface LifecycleConfig {\n  construct?: string;\n  destruct?: string;\n}\n\ninterface RegisteredBehavior {\n  id: number;\n  selector: string;\n  construct?: BlockNode;\n  destruct?: BlockNode;\n}\n\ntype AttributeHandler = {\n  id: string;\n  match: (name: string) => boolean;\n  handle: (element: Element, name: string, value: string, scope: Scope) => boolean | void;\n};\n\nexport class Engine {\n  private scopes = new WeakMap<Element, Scope>();\n  private bindBindings = new WeakMap<Element, BindConfig>();\n  private ifBindings = new WeakMap<Element, string>();\n  private showBindings = new WeakMap<Element, string>();\n  private htmlBindings = new WeakMap<Element, { expr: string; trusted: boolean }>();\n  private getBindings = new WeakMap<Element, GetConfig>();\n  private lifecycleBindings = new WeakMap<Element, LifecycleConfig>();\n  private behaviorRegistry: RegisteredBehavior[] = [];\n  private behaviorBindings = new WeakMap<Element, Set<number>>();\n  private behaviorId = 0;\n  private codeCache = new Map<string, BlockNode>();\n  private observer?: MutationObserver;\n  private attributeHandlers: AttributeHandler[] = [];\n\n  constructor() {\n    this.registerDefaultAttributeHandlers();\n  }\n\n  async mount(root: HTMLElement): Promise<void> {\n    const elements: Element[] = [root, ...Array.from(root.querySelectorAll(\"*\"))];\n    for (const element of elements) {\n      if (!this.hasVsnAttributes(element)) {\n        continue;\n      }\n      const parentScope = this.findParentScope(element);\n      this.getScope(element, parentScope);\n      this.attachAttributes(element);\n      this.runConstruct(element);\n    }\n    await this.applyBehaviors(root);\n    this.attachObserver(root);\n  }\n\n  unmount(element: Element): void {\n    this.runDestruct(element);\n  }\n\n  registerBehaviors(source: string): void {\n    const program = new Parser(source).parseProgram();\n    for (const behavior of program.behaviors) {\n      this.collectBehavior(behavior);\n    }\n  }\n\n  registerAttributeHandler(handler: AttributeHandler): void {\n    this.attributeHandlers.push(handler);\n  }\n\n  getScope(element: Element, parentScope?: Scope): Scope {\n    const existing = this.scopes.get(element);\n    if (existing) {\n      return existing;\n    }\n    const scope = new Scope(parentScope ?? this.findParentScope(element));\n    this.scopes.set(element, scope);\n    return scope;\n  }\n\n  evaluate(element: Element): void {\n    const scope = this.getScope(element);\n    const bindConfig = this.bindBindings.get(element);\n    if (bindConfig && (bindConfig.direction === \"from\" || bindConfig.direction === \"both\")) {\n      applyBindToElement(element, bindConfig.expr, scope);\n    }\n    const ifExpr = this.ifBindings.get(element);\n    if (ifExpr && element instanceof HTMLElement) {\n      applyIf(element, ifExpr, scope);\n    }\n    const showExpr = this.showBindings.get(element);\n    if (showExpr && element instanceof HTMLElement) {\n      applyShow(element, showExpr, scope);\n    }\n    const htmlBinding = this.htmlBindings.get(element);\n    if (htmlBinding && element instanceof HTMLElement) {\n      applyHtml(element, htmlBinding.expr, scope, htmlBinding.trusted);\n    }\n  }\n\n  private attachObserver(root: HTMLElement): void {\n    if (this.observer) {\n      return;\n    }\n    this.observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        for (const node of Array.from(mutation.removedNodes)) {\n          if (node && node.nodeType === 1) {\n            this.handleRemovedNode(node as Element);\n          }\n        }\n      }\n    });\n    this.observer.observe(root, { childList: true, subtree: true });\n  }\n\n  private handleRemovedNode(node: Element): void {\n    if (this.lifecycleBindings.has(node)) {\n      this.runDestruct(node);\n    }\n    if (this.behaviorBindings.has(node)) {\n      this.runBehaviorDestruct(node);\n    }\n    for (const child of Array.from(node.querySelectorAll(\"*\"))) {\n      if (this.lifecycleBindings.has(child)) {\n        this.runDestruct(child);\n      }\n      if (this.behaviorBindings.has(child)) {\n        this.runBehaviorDestruct(child);\n      }\n    }\n  }\n\n  private async applyBehaviors(root: HTMLElement): Promise<void> {\n    if (this.behaviorRegistry.length === 0) {\n      return;\n    }\n    for (const behavior of this.behaviorRegistry) {\n      const matches: Element[] = [];\n      if (root.matches(behavior.selector)) {\n        matches.push(root);\n      }\n      matches.push(...Array.from(root.querySelectorAll(behavior.selector)));\n      for (const element of matches) {\n        const bound = this.behaviorBindings.get(element) ?? new Set<number>();\n        if (bound.has(behavior.id)) {\n          continue;\n        }\n        bound.add(behavior.id);\n        this.behaviorBindings.set(element, bound);\n        const scope = this.getScope(element);\n        if (behavior.construct) {\n          await this.executeBlock(behavior.construct, scope);\n        }\n      }\n    }\n  }\n\n  private runBehaviorDestruct(element: Element): void {\n    const bound = this.behaviorBindings.get(element);\n    if (!bound) {\n      return;\n    }\n    const scope = this.getScope(element);\n    for (const behavior of this.behaviorRegistry) {\n      if (!bound.has(behavior.id) || !behavior.destruct) {\n        continue;\n      }\n      void this.executeBlock(behavior.destruct, scope);\n    }\n  }\n\n  private attachAttributes(element: Element): void {\n    const scope = this.getScope(element);\n    for (const name of element.getAttributeNames()) {\n      if (!name.startsWith(\"vsn-\")) {\n        continue;\n      }\n      const value = element.getAttribute(name) ?? \"\";\n      for (const handler of this.attributeHandlers) {\n        if (!handler.match(name)) {\n          continue;\n        }\n        const handled = handler.handle(element, name, value, scope);\n        if (handled !== false) {\n          break;\n        }\n      }\n    }\n  }\n\n  private setLifecycle(element: Element, patch: LifecycleConfig): void {\n    const current = this.lifecycleBindings.get(element) ?? {};\n    this.lifecycleBindings.set(element, { ...current, ...patch });\n  }\n\n  private runConstruct(element: Element): void {\n    const config = this.lifecycleBindings.get(element);\n    if (!config?.construct) {\n      return;\n    }\n    const scope = this.getScope(element);\n    this.execute(config.construct, scope);\n  }\n\n  private runDestruct(element: Element): void {\n    const config = this.lifecycleBindings.get(element);\n    if (!config?.destruct) {\n      return;\n    }\n    const scope = this.getScope(element);\n    this.execute(config.destruct, scope);\n  }\n\n  private attachBindInputHandler(element: Element, expr: string): void {\n    if (!(element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement)) {\n      return;\n    }\n    const handler = () => {\n      const scope = this.getScope(element);\n      applyBindToScope(element, expr, scope);\n    };\n    element.addEventListener(\"input\", handler);\n    element.addEventListener(\"change\", handler);\n  }\n\n  private parseBindDirection(name: string): BindDirection {\n    if (name.includes(\":from\")) {\n      return \"from\";\n    }\n    if (name.includes(\":to\")) {\n      return \"to\";\n    }\n    return \"both\";\n  }\n\n  private hasVsnAttributes(element: Element): boolean {\n    return element.getAttributeNames().some((name) => name.startsWith(\"vsn-\"));\n  }\n\n  private findParentScope(element: Element): Scope | undefined {\n    let parent = element.parentElement;\n    while (parent) {\n      const scope = this.scopes.get(parent);\n      if (scope) {\n        return scope;\n      }\n      parent = parent.parentElement;\n    }\n    return undefined;\n  }\n\n  private watch(scope: Scope, expr: string, handler: () => void): void {\n    const key = expr.trim();\n    if (!key) {\n      return;\n    }\n    scope.on(key, handler);\n  }\n\n  private parseOnAttribute(name: string, value: string): OnConfig | null {\n    if (!name.startsWith(\"vsn-on:\")) {\n      return null;\n    }\n\n    const eventWithFlags = name.slice(\"vsn-on:\".length);\n    const [event, ...flags] = eventWithFlags.split(\"!\");\n    if (!event) {\n      return null;\n    }\n\n    let debounceMs: number | undefined;\n    for (const flag of flags) {\n      if (!flag.startsWith(\"debounce\")) {\n        continue;\n      }\n      const match = flag.match(/debounce\\((\\d+)\\)/);\n      debounceMs = match ? Number(match[1]) : 200;\n    }\n\n    const config: OnConfig = {\n      event,\n      code: value,\n      ...(debounceMs !== undefined ? { debounceMs } : {})\n    };\n    return config;\n  }\n\n  private attachOnHandler(element: Element, config: OnConfig): void {\n    const handler = async () => {\n      const scope = this.getScope(element);\n      await this.execute(config.code, scope);\n      this.evaluate(element);\n    };\n    const effectiveHandler = config.debounceMs ? debounce(handler, config.debounceMs) : handler;\n    element.addEventListener(config.event, effectiveHandler);\n  }\n\n  private attachGetHandler(element: Element): void {\n    element.addEventListener(\"click\", async () => {\n      const config = this.getBindings.get(element);\n      if (!config) {\n        return;\n      }\n      await applyGet(element, config, this.getScope(element));\n    });\n  }\n\n  private async execute(code: string, scope: Scope): Promise<void> {\n    let block = this.codeCache.get(code);\n    if (!block) {\n      block = Parser.parseInline(code);\n      this.codeCache.set(code, block);\n    }\n    const context: ExecutionContext = { scope };\n    await block.evaluate(context);\n  }\n\n  private async executeBlock(block: BlockNode, scope: Scope): Promise<void> {\n    const context: ExecutionContext = { scope };\n    await block.evaluate(context);\n  }\n\n  private collectBehavior(behavior: BehaviorNode, parentSelector?: string): void {\n    const selector = parentSelector\n      ? `${parentSelector} ${behavior.selector.selectorText}`\n      : behavior.selector.selectorText;\n    const lifecycle = this.extractLifecycle(behavior.body);\n    this.behaviorRegistry.push({\n      id: this.behaviorId += 1,\n      selector,\n      ...lifecycle\n    });\n    for (const statement of behavior.body.statements) {\n      if (statement instanceof BehaviorNode) {\n        this.collectBehavior(statement, selector);\n      }\n    }\n  }\n\n  private extractLifecycle(body: BlockNode): { construct?: BlockNode; destruct?: BlockNode } {\n    let construct: BlockNode | undefined;\n    let destruct: BlockNode | undefined;\n    for (const statement of body.statements) {\n      if (!(statement instanceof BlockNode)) {\n        continue;\n      }\n      if (statement.type === \"Construct\") {\n        construct = statement;\n      } else if (statement.type === \"Destruct\") {\n        destruct = statement;\n      }\n    }\n    return {\n      ...(construct ? { construct } : {}),\n      ...(destruct ? { destruct } : {})\n    };\n  }\n\n  private registerDefaultAttributeHandlers(): void {\n    this.registerAttributeHandler({\n      id: \"vsn-bind\",\n      match: (name) => name.startsWith(\"vsn-bind\"),\n      handle: (element, name, value, scope) => {\n        const direction = this.parseBindDirection(name);\n        this.bindBindings.set(element, { expr: value, direction });\n        if (direction === \"to\" || direction === \"both\") {\n          applyBindToScope(element, value, scope);\n          this.attachBindInputHandler(element, value);\n        }\n        if (direction === \"from\" || direction === \"both\") {\n          this.watch(scope, value, () => applyBindToElement(element, value, scope));\n        }\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-if\",\n      match: (name) => name === \"vsn-if\",\n      handle: (element, _name, value, scope) => {\n        this.ifBindings.set(element, value);\n        if (element instanceof HTMLElement) {\n          applyIf(element, value, scope);\n        }\n        this.watch(scope, value, () => this.evaluate(element));\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-show\",\n      match: (name) => name === \"vsn-show\",\n      handle: (element, _name, value, scope) => {\n        this.showBindings.set(element, value);\n        if (element instanceof HTMLElement) {\n          applyShow(element, value, scope);\n        }\n        this.watch(scope, value, () => this.evaluate(element));\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-html\",\n      match: (name) => name.startsWith(\"vsn-html\"),\n      handle: (element, name, value, scope) => {\n        const trusted = name.includes(\"!trusted\");\n        this.htmlBindings.set(element, { expr: value, trusted });\n        if (element instanceof HTMLElement) {\n          applyHtml(element, value, scope, trusted);\n        }\n        this.watch(scope, value, () => this.evaluate(element));\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-get\",\n      match: (name) => name.startsWith(\"vsn-get\"),\n      handle: (element, name) => {\n        const trusted = name.includes(\"!trusted\");\n        const url = element.getAttribute(name) ?? \"\";\n        const target = element.getAttribute(\"vsn-target\") ?? undefined;\n        const swap = (element.getAttribute(\"vsn-swap\") as \"inner\" | \"outer\" | null) ?? \"inner\";\n        const config: GetConfig = {\n          url,\n          swap,\n          trusted,\n          ...(target ? { targetSelector: target } : {})\n        };\n        this.getBindings.set(element, config);\n        this.attachGetHandler(element);\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-construct\",\n      match: (name) => name === \"vsn-construct\",\n      handle: (element, _name, value) => {\n        this.setLifecycle(element, { construct: value });\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-destruct\",\n      match: (name) => name === \"vsn-destruct\",\n      handle: (element, _name, value) => {\n        this.setLifecycle(element, { destruct: value });\n      }\n    });\n\n    this.registerAttributeHandler({\n      id: \"vsn-on\",\n      match: (name) => name.startsWith(\"vsn-on:\"),\n      handle: (element, name, value) => {\n        const onConfig = this.parseOnAttribute(name, value);\n        if (onConfig) {\n          this.attachOnHandler(element, onConfig);\n        }\n      }\n    });\n  }\n}\n","export const VERSION = \"0.1.0\";\n\nexport { Lexer } from \"./parser/lexer\";\nimport { Parser } from \"./parser/parser\";\nimport { Engine } from \"./runtime/engine\";\nexport { Parser };\nexport { TokenType } from \"./parser/token\";\nexport * from \"./ast/nodes\";\nexport { Engine } from \"./runtime/engine\";\n\nexport function parseCFS(source: string) {\n  const parser = new Parser(source);\n  return parser.parseProgram();\n}\n\nexport function autoMount(root: HTMLElement | Document = document): Engine | null {\n  console.log('auto mounting');\n  if (typeof document === \"undefined\") {\n    return null;\n  }\n  const engine = new Engine();\n  const mount = () => {\n    const target = root instanceof Document ? root.body : root;\n    if (target) {\n      engine.mount(target);\n    }\n  };\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", mount, { once: true });\n  } else {\n    mount();\n  }\n  return engine;\n}\n\nif (typeof document !== \"undefined\") {\n  const scriptTag = document.querySelector(\"script[auto-mount]\");\n  if (scriptTag) {\n    autoMount();\n  }\n}\n"],"mappings":"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","names":["TokenType","KEYWORDS","Lexer","input","tokens","ch","punct","start","value","keywordType","quote","escaped","type","offset","BaseNode","type","_context","ProgramNode","behaviors","BlockNode","statements","context","statement","SelectorNode","selectorText","BehaviorNode","selector","body","StateEntryNode","name","value","important","StateBlockNode","entries","OnBlockNode","eventName","args","AssignmentNode","target","targetPath","IdentifierExpression","DeclarationNode","operator","flags","flagArgs","LiteralExpression","UnaryExpression","argument","BinaryExpression","left","right","DirectiveExpression","kind","QueryExpression","direction","TokenStream","tokens","offset","token","type","count","i","Parser","_Parser","input","lexer","Lexer","TokenStream","code","behaviors","ProgramNode","selector","body","BehaviorNode","selectorText","sawNonWhitespace","token","SelectorNode","options","allowDeclarations","statements","declarationsOpen","next","BlockNode","entries","nameToken","value","important","importantToken","StateEntryNode","StateBlockNode","event","args","OnBlockNode","target","AssignmentNode","left","op","right","BinaryExpression","argument","UnaryExpression","kind","name","DirectiveExpression","IdentifierExpression","LiteralExpression","operator","flags","flagArgs","DeclarationNode","numberToken","first","second","third","direction","QueryExpression","terminator","part","Scope","parent","key","value","path","targetScope","targetPath","parts","root","i","obj","cursor","lastKey","handler","set","fn","rootKey","getElementValue","element","setElementValue","value","applyBindToScope","expression","scope","key","applyBindToElement","readCondition","expression","scope","key","applyIf","element","applyShow","sanitizeHtml","value","applyHtml","element","expression","scope","trusted","key","html","applyGet","element","config","scope","response","html","target","resolveTarget","wrapper","applyHtml","replacement","selector","debounce","fn","waitMs","timer","args","Engine","root","elements","element","parentScope","source","program","Parser","behavior","handler","existing","scope","Scope","bindConfig","applyBindToElement","ifExpr","applyIf","showExpr","applyShow","htmlBinding","applyHtml","mutations","mutation","node","child","matches","bound","name","value","patch","current","config","expr","applyBindToScope","parent","key","eventWithFlags","event","flags","debounceMs","flag","match","effectiveHandler","debounce","applyGet","code","block","context","parentSelector","selector","lifecycle","statement","BehaviorNode","body","construct","destruct","BlockNode","direction","_name","trusted","url","target","swap","onConfig","VERSION","parseCFS","source","Parser","autoMount","root","engine","Engine","mount","target"]}