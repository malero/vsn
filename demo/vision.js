/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/simple-ts-event-dispatcher/dist/EventDispatcher.js":
/*!*************************************************************************!*\
  !*** ./node_modules/simple-ts-event-dispatcher/dist/EventDispatcher.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar EventCallback = /** @class */ (function () {\n    function EventCallback(fnc, key, once, context) {\n        this.fnc = fnc;\n        this.key = key;\n        this.once = once;\n        this.context = context;\n        this.calls = 0;\n    }\n    EventCallback.prototype.call = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (this.once && this.calls > 0)\n            return false;\n        (_a = this.fnc).apply.apply(_a, [this.context].concat(args));\n        this.calls += 1;\n        return true;\n        var _a;\n    };\n    return EventCallback;\n}());\nexports.EventCallback = EventCallback;\nvar EventDispatcher = /** @class */ (function () {\n    function EventDispatcher() {\n        this._lastKey = 0;\n        this._listeners = {};\n    }\n    EventDispatcher.prototype.bind = function (event, fct, context, once) {\n        once = once || false;\n        this._lastKey++;\n        this._listeners[event] = this._listeners[event] || [];\n        this._listeners[event].push(new EventCallback(fct, this._lastKey, once, context));\n        return this._lastKey;\n    };\n    EventDispatcher.prototype.once = function (event, fct, context) {\n        return this.bind(event, fct, context, true);\n    };\n    EventDispatcher.prototype.unbind = function (event, key) {\n        if (event in this._listeners === false)\n            return false;\n        if (key) {\n            for (var _i = 0, _a = this._listeners[event]; _i < _a.length; _i++) {\n                var cb = _a[_i];\n                if (key == cb.key) {\n                    this._listeners[event].splice(this._listeners[event].indexOf(cb), 1);\n                    return true;\n                }\n            }\n        }\n        else {\n            this._listeners[event] = [];\n            return true;\n        }\n        return false;\n    };\n    EventDispatcher.prototype.unbindWithContext = function (event, context) {\n        if (event in this._listeners === false)\n            return 0;\n        var toRemove = [], cnt = 0;\n        for (var _i = 0, _a = this._listeners[event]; _i < _a.length; _i++) {\n            var cb = _a[_i];\n            if (context == cb.context) {\n                toRemove.push(cb);\n            }\n        }\n        for (var _b = 0, toRemove_1 = toRemove; _b < toRemove_1.length; _b++) {\n            var cb = toRemove_1[_b];\n            this._listeners[event].splice(this._listeners[event].indexOf(cb), 1);\n            cnt++;\n        }\n        return cnt;\n    };\n    EventDispatcher.prototype.getListener = function (event, key) {\n        for (var _i = 0, _a = this._listeners[event]; _i < _a.length; _i++) {\n            var cb = _a[_i];\n            if (key == cb.key)\n                return cb;\n        }\n    };\n    EventDispatcher.prototype.trigger = function (event) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        if (event in this._listeners === false)\n            return;\n        for (var i = 0; i < this._listeners[event].length; i++) {\n            var cb = this._listeners[event][i];\n            // We need to unbind callbacks before they're called to prevent\n            // infinite loops if the event is somehow triggered within the\n            // callback\n            if (cb.once) {\n                this.unbind(event, cb.key);\n                i--;\n            }\n            cb.call(args);\n        }\n    };\n    return EventDispatcher;\n}());\nexports.EventDispatcher = EventDispatcher;\n//# sourceMappingURL=EventDispatcher.js.map\n\n//# sourceURL=webpack://vsn/./node_modules/simple-ts-event-dispatcher/dist/EventDispatcher.js?");

/***/ }),

/***/ "./node_modules/simple-ts-message-list/dist/MessageList.js":
/*!*****************************************************************!*\
  !*** ./node_modules/simple-ts-message-list/dist/MessageList.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar MessageList = /** @class */ (function () {\n    function MessageList(messages) {\n        this.reset();\n        if (messages)\n            this.merge(messages);\n    }\n    MessageList.prototype.reset = function () {\n        // Reset the object\n        var keys = this.keys;\n        this._cachedList = undefined;\n        if (keys.length > 0) {\n            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n                var field = keys_1[_i];\n                delete this[field];\n            }\n        }\n    };\n    MessageList.prototype.add = function (field, errors, replace) {\n        var _a;\n        if (replace === void 0) { replace = false; }\n        this.merge((_a = {},\n            _a[field] = typeof errors == 'string' ? [errors] : errors,\n            _a), replace);\n    };\n    MessageList.prototype.merge = function (messages, replace) {\n        var _this = this;\n        if (replace === void 0) { replace = false; }\n        if (!messages)\n            return;\n        this._cachedList = undefined;\n        var keys = this.keys;\n        var _loop_1 = function (field) {\n            if (!messages.hasOwnProperty(field))\n                return \"continue\";\n            var message = messages[field];\n            if (message instanceof Array) {\n                if (!replace && keys.indexOf(field) > -1) {\n                    message.map(function (x) {\n                        _this[field].push(x);\n                    });\n                }\n                else if (message.length > 0) {\n                    this_1[field] = message;\n                }\n            }\n        };\n        var this_1 = this;\n        for (var field in messages) {\n            _loop_1(field);\n        }\n    };\n    Object.defineProperty(MessageList.prototype, \"list\", {\n        get: function () {\n            if (this._cachedList)\n                return this._cachedList;\n            var list = {}, keys = this.keys;\n            for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n                var field = keys_2[_i];\n                list[field] = this[field];\n            }\n            this._cachedList = list;\n            return list;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MessageList.prototype, \"keys\", {\n        get: function () {\n            var keys = Object.keys(this);\n            keys.splice(keys.indexOf('_cachedList'), 1);\n            return keys;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MessageList.prototype, \"length\", {\n        get: function () {\n            return this.keys.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return MessageList;\n}());\nexports.default = MessageList;\n//# sourceMappingURL=MessageList.js.map\n\n//# sourceURL=webpack://vsn/./node_modules/simple-ts-message-list/dist/MessageList.js?");

/***/ }),

/***/ "./node_modules/simple-ts-models/dist/Collection.js":
/*!**********************************************************!*\
  !*** ./node_modules/simple-ts-models/dist/Collection.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Collection = void 0;\nvar Collection = /** @class */ (function (_super) {\n    __extends(Collection, _super);\n    function Collection() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.getData = function () {\n            // Returns an array of data from all of the models in the collection\n            var data = [];\n            for (var _i = 0, _a = _this; _i < _a.length; _i++) {\n                var item = _a[_i];\n                data.push(item.getData());\n            }\n            return data;\n        };\n        return _this;\n    }\n    return Collection;\n}(Array));\nexports.Collection = Collection;\n//# sourceMappingURL=Collection.js.map\n\n//# sourceURL=webpack://vsn/./node_modules/simple-ts-models/dist/Collection.js?");

/***/ }),

/***/ "./node_modules/simple-ts-models/dist/DataModel.js":
/*!*********************************************************!*\
  !*** ./node_modules/simple-ts-models/dist/DataModel.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataModel = void 0;\nvar ModelAbstract_1 = __webpack_require__(/*! ./ModelAbstract */ \"./node_modules/simple-ts-models/dist/ModelAbstract.js\");\nvar DataModel = /** @class */ (function (_super) {\n    __extends(DataModel, _super);\n    function DataModel(data) {\n        var _this = _super.call(this) || this;\n        if (data instanceof Array) {\n            _this.__fields__ = data;\n            for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\n                var field = data_1[_i];\n                _this.createField(field);\n            }\n        }\n        else {\n            _this.setData(data);\n        }\n        return _this;\n    }\n    DataModel.prototype.setData = function (data) {\n        for (var _i = 0, _a = Object.keys(data); _i < _a.length; _i++) {\n            var field = _a[_i];\n            if (this.__fields__.indexOf(field) == -1) {\n                this.__fields__.push(field);\n                this.createField(field);\n            }\n        }\n        _super.prototype.setData.call(this, data);\n    };\n    DataModel.prototype.bind = function (event, fct, context, once) {\n        if (event.indexOf('change:') == 0)\n            this.createField(event.substr(7));\n        return _super.prototype.bind.call(this, event, fct, context, once);\n    };\n    return DataModel;\n}(ModelAbstract_1.ModelAbstract));\nexports.DataModel = DataModel;\n//# sourceMappingURL=DataModel.js.map\n\n//# sourceURL=webpack://vsn/./node_modules/simple-ts-models/dist/DataModel.js?");

/***/ }),

/***/ "./node_modules/simple-ts-models/dist/Model.js":
/*!*****************************************************!*\
  !*** ./node_modules/simple-ts-models/dist/Model.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Model = void 0;\nvar simple_ts_message_list_1 = __webpack_require__(/*! simple-ts-message-list */ \"./node_modules/simple-ts-message-list/dist/MessageList.js\");\nvar ModelAbstract_1 = __webpack_require__(/*! ./ModelAbstract */ \"./node_modules/simple-ts-models/dist/ModelAbstract.js\");\nvar Model = /** @class */ (function (_super) {\n    __extends(Model, _super);\n    function Model(data) {\n        if (data === void 0) { data = null; }\n        var _this = _super.call(this) || this;\n        var fields = _this.__fields__.splice(0, _this.__fields__.length);\n        for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {\n            var field = fields_1[_i];\n            (function (_self, field) {\n                if (!_self['__' + field + '__'])\n                    return;\n                _self.__fields__.push(field);\n                var _field = _self['__' + field + '__'], fieldType = _field[0], config = _field[1] || {};\n                _self.createField(field, fieldType, config);\n            })(_this, field);\n        }\n        _this._hasErrors = false;\n        if (data)\n            _this.setData(data);\n        _this._lastData = _this.getData();\n        _this._constructor();\n        return _this;\n    }\n    Model.prototype._constructor = function () { };\n    Model.prototype.validate = function () {\n        this._hasErrors = false;\n        this._errors = new simple_ts_message_list_1.default;\n        for (var _i = 0, _a = this.getFields(); _i < _a.length; _i++) {\n            var field = _a[_i];\n            var errors = this['__' + field].validate();\n            if (errors.length > 0) {\n                this._errors.add(field, errors, true);\n                this._hasErrors = true;\n            }\n        }\n        return this._errors;\n    };\n    Model.prototype.hasErrors = function () {\n        this.validate();\n        return this._hasErrors;\n    };\n    Object.defineProperty(Model.prototype, \"errors\", {\n        get: function () {\n            return this._errors;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Model;\n}(ModelAbstract_1.ModelAbstract));\nexports.Model = Model;\n//# sourceMappingURL=Model.js.map\n\n//# sourceURL=webpack://vsn/./node_modules/simple-ts-models/dist/Model.js?");

/***/ }),

/***/ "./node_modules/simple-ts-models/dist/ModelAbstract.js":
/*!*************************************************************!*\
  !*** ./node_modules/simple-ts-models/dist/ModelAbstract.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModelAbstract = void 0;\nvar simple_ts_event_dispatcher_1 = __webpack_require__(/*! simple-ts-event-dispatcher */ \"./node_modules/simple-ts-event-dispatcher/dist/EventDispatcher.js\");\nvar Field_1 = __webpack_require__(/*! ./fields/Field */ \"./node_modules/simple-ts-models/dist/fields/Field.js\");\nvar ModelAbstract = /** @class */ (function (_super) {\n    __extends(ModelAbstract, _super);\n    function ModelAbstract() {\n        var _this = _super.call(this) || this;\n        // Models may have __fields__ from prototype\n        if (!_this['__fields__'])\n            _this.__fields__ = [];\n        return _this;\n    }\n    ModelAbstract.prototype.createField = function (field, fieldType, config) {\n        var _this = this;\n        if (fieldType === void 0) { fieldType = Field_1.Field; }\n        config = config || {};\n        var instance = new fieldType(this, config.default, config), propDesc = Object.getOwnPropertyDescriptor(this, field);\n        this['__' + field] = instance;\n        // property getter\n        var fieldGetter = function () {\n            return instance.value;\n        };\n        var getter = propDesc ? propDesc.get : fieldGetter, fieldSetter = function (newVal) {\n            instance.value = newVal;\n        }, setter = propDesc ? propDesc.set : fieldSetter;\n        // Delete the original property\n        delete this[field];\n        // Create new property with getter and setter\n        Object.defineProperty(this, field, {\n            get: getter,\n            set: setter,\n            enumerable: true,\n            configurable: true\n        });\n        instance.bind('change', function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            _this.trigger.apply(_this, __spreadArray(['change', field], args));\n            _this.trigger.apply(_this, __spreadArray(['change:' + field], args));\n        });\n        return instance;\n    };\n    ModelAbstract.prototype.setData = function (data) {\n        var fields = this.getFields();\n        for (var key in data) {\n            if (fields.indexOf(key) > -1) {\n                this[key] = data[key];\n            }\n        }\n    };\n    ModelAbstract.prototype.getData = function () {\n        var data = {};\n        for (var _i = 0, _a = this.getFields(); _i < _a.length; _i++) {\n            var key = _a[_i];\n            var field = this['__' + key];\n            if (this[key] == null || !field)\n                continue;\n            data[key] = field.getData();\n        }\n        return data;\n    };\n    ModelAbstract.prototype.getFields = function () {\n        return this.__fields__;\n    };\n    ModelAbstract.prototype.getField = function (field) {\n        return this['__' + field];\n    };\n    ModelAbstract.prototype.bindToFields = function (event, fields, callback) {\n        for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {\n            var field = fields_1[_i];\n            var _field = this['__' + field];\n            if (_field)\n                _field.bind(event, callback);\n        }\n    };\n    ModelAbstract.prototype.setLastData = function () {\n        this._lastData = this.getData();\n    };\n    /*\n     * Revert data to the last setData() call. Useful for forms that edit a\n     * list of items and then hit cancel rather than saving the list.\n     */\n    ModelAbstract.prototype.revert = function () {\n        this.setData(this._lastData);\n    };\n    ModelAbstract.prototype.isModified = function () {\n        var oData = this._lastData, nData = this.getData();\n        for (var _i = 0, _a = this.getFields(); _i < _a.length; _i++) {\n            var key = _a[_i];\n            if (nData[key] != oData[key])\n                return true;\n        }\n        return false;\n    };\n    return ModelAbstract;\n}(simple_ts_event_dispatcher_1.EventDispatcher));\nexports.ModelAbstract = ModelAbstract;\n//# sourceMappingURL=ModelAbstract.js.map\n\n//# sourceURL=webpack://vsn/./node_modules/simple-ts-models/dist/ModelAbstract.js?");

/***/ }),

/***/ "./node_modules/simple-ts-models/dist/fields/BooleanField.js":
/*!*******************************************************************!*\
  !*** ./node_modules/simple-ts-models/dist/fields/BooleanField.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BooleanField = void 0;\nvar Field_1 = __webpack_require__(/*! ./Field */ \"./node_modules/simple-ts-models/dist/fields/Field.js\");\nvar BooleanField = /** @class */ (function (_super) {\n    __extends(BooleanField, _super);\n    function BooleanField() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(BooleanField.prototype, \"value\", {\n        get: function () {\n            return this._value;\n        },\n        set: function (data) {\n            var oldValue = this.value;\n            this._value = !!data;\n            this.trigger('change', {\n                oldValue: oldValue,\n                value: data\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return BooleanField;\n}(Field_1.Field));\nexports.BooleanField = BooleanField;\n//# sourceMappingURL=BooleanField.js.map\n\n//# sourceURL=webpack://vsn/./node_modules/simple-ts-models/dist/fields/BooleanField.js?");

/***/ }),

/***/ "./node_modules/simple-ts-models/dist/fields/EmailField.js":
/*!*****************************************************************!*\
  !*** ./node_modules/simple-ts-models/dist/fields/EmailField.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EmailField = void 0;\nvar Field_1 = __webpack_require__(/*! ./Field */ \"./node_modules/simple-ts-models/dist/fields/Field.js\");\nvar EmailField = /** @class */ (function (_super) {\n    __extends(EmailField, _super);\n    function EmailField() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._emailRegex = /^(([^<>()\\[\\]\\.,;:\\s@\\\"]+(\\.[^<>()\\[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\.,;:\\s@\\\"]{2,})$/i;\n        return _this;\n    }\n    EmailField.prototype.validate = function () {\n        _super.prototype.validate.call(this);\n        if (this._value != null && !this._emailRegex.test(this._value))\n            this._errors.push('Please enter a valid email address');\n        return this._errors;\n    };\n    return EmailField;\n}(Field_1.Field));\nexports.EmailField = EmailField;\n//# sourceMappingURL=EmailField.js.map\n\n//# sourceURL=webpack://vsn/./node_modules/simple-ts-models/dist/fields/EmailField.js?");

/***/ }),

/***/ "./node_modules/simple-ts-models/dist/fields/Field.js":
/*!************************************************************!*\
  !*** ./node_modules/simple-ts-models/dist/fields/Field.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Field = exports.field = void 0;\nvar simple_ts_event_dispatcher_1 = __webpack_require__(/*! simple-ts-event-dispatcher */ \"./node_modules/simple-ts-event-dispatcher/dist/EventDispatcher.js\");\nfunction field(fieldType, config) {\n    if (fieldType === void 0) { fieldType = Field; }\n    if (config === void 0) { config = {}; }\n    return function (target, key) {\n        if (target.__fields__ == undefined) {\n            target.__fields__ = [];\n        }\n        // Abstract models share __fields__\n        if (target.__fields__.indexOf(key) == -1)\n            target.__fields__.push(key);\n        var getter = function () {\n            return [fieldType, config];\n        };\n        Object.defineProperty(target, '__' + key + '__', {\n            get: getter,\n            set: function (v) { },\n            enumerable: false,\n            configurable: true\n        });\n    };\n}\nexports.field = field;\nvar Field = /** @class */ (function (_super) {\n    __extends(Field, _super);\n    function Field(model, value, config) {\n        var _this = _super.call(this) || this;\n        _this.model = model;\n        _this.config = config;\n        _this.value = value;\n        _this._errors = [];\n        return _this;\n    }\n    Object.defineProperty(Field.prototype, \"value\", {\n        get: function () {\n            return this._value;\n        },\n        set: function (v) {\n            var oldValue = this._value;\n            this._value = v;\n            this.trigger('change', {\n                oldValue: oldValue,\n                value: v\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Field.prototype.getData = function () {\n        return this.value;\n    };\n    Field.prototype.validate = function () {\n        this._errors = [];\n        if (this.config['required'] == true && this._value == null)\n            this._errors.push('This field is required.');\n        return this._errors;\n    };\n    return Field;\n}(simple_ts_event_dispatcher_1.EventDispatcher));\nexports.Field = Field;\n//# sourceMappingURL=Field.js.map\n\n//# sourceURL=webpack://vsn/./node_modules/simple-ts-models/dist/fields/Field.js?");

/***/ }),

/***/ "./node_modules/simple-ts-models/dist/fields/FloatField.js":
/*!*****************************************************************!*\
  !*** ./node_modules/simple-ts-models/dist/fields/FloatField.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FloatField = void 0;\nvar Field_1 = __webpack_require__(/*! ./Field */ \"./node_modules/simple-ts-models/dist/fields/Field.js\");\nvar FloatField = /** @class */ (function (_super) {\n    __extends(FloatField, _super);\n    function FloatField() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(FloatField.prototype, \"value\", {\n        get: function () {\n            return this._value;\n        },\n        set: function (data) {\n            var oldValue = this.value;\n            if (typeof (data) == 'string')\n                data = parseFloat(data);\n            if (typeof (data) == \"number\" && this.config.toFixed)\n                data = parseFloat(data.toFixed(this.config.toFixed));\n            this._value = data;\n            this.trigger('change', {\n                oldValue: oldValue,\n                value: data\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return FloatField;\n}(Field_1.Field));\nexports.FloatField = FloatField;\n//# sourceMappingURL=FloatField.js.map\n\n//# sourceURL=webpack://vsn/./node_modules/simple-ts-models/dist/fields/FloatField.js?");

/***/ }),

/***/ "./node_modules/simple-ts-models/dist/fields/PositiveNumberField.js":
/*!**************************************************************************!*\
  !*** ./node_modules/simple-ts-models/dist/fields/PositiveNumberField.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PositiveIntegerField = void 0;\nvar Field_1 = __webpack_require__(/*! ./Field */ \"./node_modules/simple-ts-models/dist/fields/Field.js\");\nvar PositiveIntegerField = /** @class */ (function (_super) {\n    __extends(PositiveIntegerField, _super);\n    function PositiveIntegerField() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(PositiveIntegerField.prototype, \"value\", {\n        get: function () {\n            return this._value;\n        },\n        set: function (data) {\n            var oldValue = this.value;\n            if (data == null) {\n                this._value = null;\n                return;\n            }\n            else if (typeof (data) == 'string')\n                data = parseInt(data);\n            if (data <= 0)\n                data = 0;\n            this._value = data;\n            this.trigger('change', {\n                oldValue: oldValue,\n                value: data\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return PositiveIntegerField;\n}(Field_1.Field));\nexports.PositiveIntegerField = PositiveIntegerField;\n//# sourceMappingURL=PositiveNumberField.js.map\n\n//# sourceURL=webpack://vsn/./node_modules/simple-ts-models/dist/fields/PositiveNumberField.js?");

/***/ }),

/***/ "./node_modules/simple-ts-models/dist/fields/StringField.js":
/*!******************************************************************!*\
  !*** ./node_modules/simple-ts-models/dist/fields/StringField.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StringField = void 0;\nvar Field_1 = __webpack_require__(/*! ./Field */ \"./node_modules/simple-ts-models/dist/fields/Field.js\");\nvar StringField = /** @class */ (function (_super) {\n    __extends(StringField, _super);\n    function StringField() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(StringField.prototype, \"value\", {\n        get: function () {\n            return this._value;\n        },\n        set: function (data) {\n            var oldValue = this.value;\n            this._value = '' + data;\n            this.trigger('change', {\n                oldValue: oldValue,\n                value: data\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return StringField;\n}(Field_1.Field));\nexports.StringField = StringField;\n//# sourceMappingURL=StringField.js.map\n\n//# sourceURL=webpack://vsn/./node_modules/simple-ts-models/dist/fields/StringField.js?");

/***/ }),

/***/ "./node_modules/simple-ts-models/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/simple-ts-models/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fields = exports.field = exports.Collection = exports.Model = exports.DataModel = void 0;\nvar Field_1 = __webpack_require__(/*! ./fields/Field */ \"./node_modules/simple-ts-models/dist/fields/Field.js\");\nObject.defineProperty(exports, \"field\", ({ enumerable: true, get: function () { return Field_1.field; } }));\nvar BooleanField_1 = __webpack_require__(/*! ./fields/BooleanField */ \"./node_modules/simple-ts-models/dist/fields/BooleanField.js\");\nvar EmailField_1 = __webpack_require__(/*! ./fields/EmailField */ \"./node_modules/simple-ts-models/dist/fields/EmailField.js\");\nvar FloatField_1 = __webpack_require__(/*! ./fields/FloatField */ \"./node_modules/simple-ts-models/dist/fields/FloatField.js\");\nvar PositiveNumberField_1 = __webpack_require__(/*! ./fields/PositiveNumberField */ \"./node_modules/simple-ts-models/dist/fields/PositiveNumberField.js\");\nvar StringField_1 = __webpack_require__(/*! ./fields/StringField */ \"./node_modules/simple-ts-models/dist/fields/StringField.js\");\nvar DataModel_1 = __webpack_require__(/*! ./DataModel */ \"./node_modules/simple-ts-models/dist/DataModel.js\");\nObject.defineProperty(exports, \"DataModel\", ({ enumerable: true, get: function () { return DataModel_1.DataModel; } }));\nvar Model_1 = __webpack_require__(/*! ./Model */ \"./node_modules/simple-ts-models/dist/Model.js\");\nObject.defineProperty(exports, \"Model\", ({ enumerable: true, get: function () { return Model_1.Model; } }));\nvar Collection_1 = __webpack_require__(/*! ./Collection */ \"./node_modules/simple-ts-models/dist/Collection.js\");\nObject.defineProperty(exports, \"Collection\", ({ enumerable: true, get: function () { return Collection_1.Collection; } }));\nvar fields = {\n    Field: Field_1.Field,\n    BooleanField: BooleanField_1.BooleanField,\n    EmailField: EmailField_1.EmailField,\n    FloatField: FloatField_1.FloatField,\n    PositiveIntegerField: PositiveNumberField_1.PositiveIntegerField,\n    StringField: StringField_1.StringField\n};\nexports.fields = fields;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://vsn/./node_modules/simple-ts-models/dist/index.js?");

/***/ }),

/***/ "./node_modules/simple-ts-promise/dist/Promise.js":
/*!********************************************************!*\
  !*** ./node_modules/simple-ts-promise/dist/Promise.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Most basic/simple implementation of a Typescript Promise!\n * Documentation and implementation based off of:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n *\n * Recreating wheels!\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Promise = exports.noop = exports.EPromiseStates = void 0;\nvar simple_ts_event_dispatcher_1 = __webpack_require__(/*! simple-ts-event-dispatcher */ \"./node_modules/simple-ts-event-dispatcher/dist/EventDispatcher.js\");\nvar EPromiseStates;\n(function (EPromiseStates) {\n    EPromiseStates[EPromiseStates[\"PENDING\"] = 0] = \"PENDING\";\n    EPromiseStates[EPromiseStates[\"FULFILLED\"] = 1] = \"FULFILLED\";\n    EPromiseStates[EPromiseStates[\"REJECTED\"] = 2] = \"REJECTED\";\n})(EPromiseStates = exports.EPromiseStates || (exports.EPromiseStates = {}));\nfunction noop(result) { return result; }\nexports.noop = noop;\nvar Promise = /** @class */ (function (_super) {\n    __extends(Promise, _super);\n    function Promise(executor) {\n        var _this = _super.call(this) || this;\n        _this._result = null;\n        _this._state = EPromiseStates.PENDING;\n        _this.promiseClass = (Object.getPrototypeOf(_this).constructor);\n        try {\n            executor(_this._resolve.bind(_this), _this._reject.bind(_this));\n        }\n        catch (e) {\n            _this._reject(e);\n        }\n        return _this;\n    }\n    Object.defineProperty(Promise.prototype, \"state\", {\n        get: function () {\n            return this._state;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Promise.prototype, \"result\", {\n        get: function () {\n            return this._result;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Promise.defer = function () {\n        var promise = new Promise(function (res, rej) { });\n        return {\n            promise: promise,\n            resolve: promise._resolve.bind(promise),\n            reject: promise._reject.bind(promise)\n        };\n    };\n    /*\n     * Returns a Promise object that is resolved with the given value. If the value is a thenable (i.e. has a then\n     * method), the returned promise will \"follow\" that thenable, adopting its eventual state; otherwise the returned\n     * promise will be fulfilled with the value. Generally, if you don't know if a value is a promise or not,\n     * Promise.resolve(value) it instead and work with the return value as a promise.\n     */\n    Promise.resolve = function (result) {\n        return new Promise(function (resolve) {\n            if (result instanceof Promise) {\n                result.then(function (innerResult) {\n                    resolve(innerResult);\n                });\n            }\n            else {\n                resolve(result);\n            }\n        });\n    };\n    /*\n     * Returns a Promise object that is rejected with the given reason.\n     */\n    Promise.reject = function (reason) {\n        return new Promise(function (resolve, reject) {\n            reject(reason);\n        });\n    };\n    /*\n     * Returns a promise that either fulfills when all of the promises in the iterable argument have fulfilled or\n     * rejects as soon as one of the promises in the iterable argument rejects. If the returned promise fulfills, it is\n     * fulfilled with an array of the values from the fulfilled promises in the same order as defined in the iterable.\n     * If the returned promise rejects, it is rejected with the reason from the first promise in the iterable that\n     * rejected. This method can be useful for aggregating results of multiple promises.\n     */\n    Promise.all = function (iter) {\n        var deferred = Promise.defer();\n        var done = true;\n        for (var _i = 0, iter_1 = iter; _i < iter_1.length; _i++) {\n            var promise = iter_1[_i];\n            if (promise.state == EPromiseStates.PENDING) {\n                done = false;\n                promise.once('fulfilled', function (result) {\n                    Promise.poolResults(iter, deferred);\n                });\n                promise.once('rejected', function (reason) {\n                    deferred.reject(reason);\n                });\n            }\n            else if (promise.state == EPromiseStates.REJECTED) {\n                deferred.reject(promise.result);\n                done = false;\n                break;\n            }\n        }\n        if (done)\n            Promise.poolResults(iter, deferred);\n        return deferred.promise;\n    };\n    Promise.poolResults = function (iter, deferred) {\n        var done = true;\n        var results = [];\n        for (var _i = 0, iter_2 = iter; _i < iter_2.length; _i++) {\n            var p = iter_2[_i];\n            if (p.state === EPromiseStates.REJECTED) {\n                deferred.reject(p.result);\n                break;\n            }\n            else if (p.state === EPromiseStates.PENDING) {\n                done = false;\n            }\n            results.push(p.result);\n        }\n        if (done)\n            deferred.resolve(results);\n    };\n    /*\n     * Returns a promise that fulfills or rejects as soon as one of the promises in the iterable fulfills or rejects,\n     * with the value or reason from that promise.\n     */\n    Promise.race = function (iter) {\n        var deferred = Promise.defer();\n        for (var _i = 0, iter_3 = iter; _i < iter_3.length; _i++) {\n            var promise = iter_3[_i];\n            promise.once('fulfilled', function (result) {\n                deferred.resolve(result);\n            });\n            promise.once('rejected', function (reason) {\n                deferred.reject(reason);\n            });\n        }\n        return deferred.promise;\n    };\n    /*\n     * Appends fulfillment and rejection handlers to the promise, and returns a new promise resolving to the return\n     * value of the called handler, or to its original settled value if the promise was not handled (i.e. if the\n     * relevant handler onFulfilled or onRejected is not a function).\n     */\n    Promise.prototype.then = function (success, error) {\n        var _this = this;\n        return new this.promiseClass(function (resolve, reject) {\n            if (_this.state === EPromiseStates.FULFILLED) {\n                if (success)\n                    resolve(success(_this.result));\n            }\n            else if (_this.state === EPromiseStates.REJECTED) {\n                if (error)\n                    reject(error(_this.result));\n            }\n            else {\n                _this.once('fulfilled', function (result) {\n                    if (success)\n                        resolve(success(result));\n                });\n                _this.once('rejected', function (reason) {\n                    if (error)\n                        reject(error(reason));\n                });\n            }\n        });\n    };\n    /*\n     * Appends a rejection handler callback to the promise, and returns a new promise resolving to the return value of\n     * the callback if it is called, or to its original fulfillment value if the promise is instead fulfilled.\n     */\n    Promise.prototype.catch = function (onRejected) {\n        return this.then(undefined, onRejected);\n    };\n    /*\n     * Appends a handler to the promise, and returns a new promise which is resolved when the original promise is\n     * resolved. The handler is called when the promise is settled, whether fulfilled or rejected.\n     */\n    Promise.prototype.finally = function (finallyCallback) {\n        var success = function (result) { return finallyCallback(result); };\n        var error = function (reason) { return finallyCallback(reason); };\n        return this.then(success, error);\n    };\n    Promise.prototype._resolve = function (result) {\n        if (this.state !== EPromiseStates.PENDING)\n            return;\n        this._state = EPromiseStates.FULFILLED;\n        this._result = result;\n        this.trigger('fulfilled', result);\n    };\n    Promise.prototype._reject = function (reason) {\n        if (this.state !== EPromiseStates.PENDING)\n            return;\n        this._state = EPromiseStates.REJECTED;\n        this._result = reason;\n        this.trigger('rejected', reason);\n    };\n    return Promise;\n}(simple_ts_event_dispatcher_1.EventDispatcher));\nexports.Promise = Promise;\n//# sourceMappingURL=Promise.js.map\n\n//# sourceURL=webpack://vsn/./node_modules/simple-ts-promise/dist/Promise.js?");

/***/ }),

/***/ "./src/AST.ts":
/*!********************!*\
  !*** ./src/AST.ts ***!
  \********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Tree = exports.AttributableNodes = exports.BlockNode = exports.Node = exports.TokenType = exports.BlockType = void 0;\nconst Scope_1 = __webpack_require__(/*! ./Scope */ \"./src/Scope.ts\");\nconst Tag_1 = __webpack_require__(/*! ./Tag */ \"./src/Tag.ts\");\nfunction lower(str) {\n    return str ? str.toLowerCase() : null;\n}\nvar BlockType;\n(function (BlockType) {\n    BlockType[BlockType[\"BRACE\"] = 0] = \"BRACE\";\n    BlockType[BlockType[\"BRACKET\"] = 1] = \"BRACKET\";\n    BlockType[BlockType[\"PAREN\"] = 2] = \"PAREN\";\n    BlockType[BlockType[\"STATEMENT\"] = 3] = \"STATEMENT\";\n})(BlockType = exports.BlockType || (exports.BlockType = {}));\nvar TokenType;\n(function (TokenType) {\n    TokenType[TokenType[\"WHITESPACE\"] = 0] = \"WHITESPACE\";\n    TokenType[TokenType[\"TYPE_INT\"] = 1] = \"TYPE_INT\";\n    TokenType[TokenType[\"TYPE_UINT\"] = 2] = \"TYPE_UINT\";\n    TokenType[TokenType[\"TYPE_FLOAT\"] = 3] = \"TYPE_FLOAT\";\n    TokenType[TokenType[\"TYPE_STRING\"] = 4] = \"TYPE_STRING\";\n    TokenType[TokenType[\"RETURN\"] = 5] = \"RETURN\";\n    TokenType[TokenType[\"OF\"] = 6] = \"OF\";\n    TokenType[TokenType[\"IN\"] = 7] = \"IN\";\n    TokenType[TokenType[\"FOR\"] = 8] = \"FOR\";\n    TokenType[TokenType[\"IF\"] = 9] = \"IF\";\n    TokenType[TokenType[\"ELSE_IF\"] = 10] = \"ELSE_IF\";\n    TokenType[TokenType[\"ELSE\"] = 11] = \"ELSE\";\n    TokenType[TokenType[\"NAME\"] = 12] = \"NAME\";\n    TokenType[TokenType[\"L_BRACE\"] = 13] = \"L_BRACE\";\n    TokenType[TokenType[\"R_BRACE\"] = 14] = \"R_BRACE\";\n    TokenType[TokenType[\"L_BRACKET\"] = 15] = \"L_BRACKET\";\n    TokenType[TokenType[\"R_BRACKET\"] = 16] = \"R_BRACKET\";\n    TokenType[TokenType[\"L_PAREN\"] = 17] = \"L_PAREN\";\n    TokenType[TokenType[\"R_PAREN\"] = 18] = \"R_PAREN\";\n    TokenType[TokenType[\"PERIOD\"] = 19] = \"PERIOD\";\n    TokenType[TokenType[\"COMMA\"] = 20] = \"COMMA\";\n    TokenType[TokenType[\"COLON\"] = 21] = \"COLON\";\n    TokenType[TokenType[\"SEMI_COLON\"] = 22] = \"SEMI_COLON\";\n    TokenType[TokenType[\"STRING_LITERAL\"] = 23] = \"STRING_LITERAL\";\n    TokenType[TokenType[\"NUMBER_LITERAL\"] = 24] = \"NUMBER_LITERAL\";\n    TokenType[TokenType[\"BOOLEAN_LITERAL\"] = 25] = \"BOOLEAN_LITERAL\";\n    TokenType[TokenType[\"NULL_LITERAL\"] = 26] = \"NULL_LITERAL\";\n    TokenType[TokenType[\"STRICT_EQUALS\"] = 27] = \"STRICT_EQUALS\";\n    TokenType[TokenType[\"STRICT_NOT_EQUALS\"] = 28] = \"STRICT_NOT_EQUALS\";\n    TokenType[TokenType[\"EQUALS\"] = 29] = \"EQUALS\";\n    TokenType[TokenType[\"NOT_EQUALS\"] = 30] = \"NOT_EQUALS\";\n    TokenType[TokenType[\"GREATER_THAN_EQUAL\"] = 31] = \"GREATER_THAN_EQUAL\";\n    TokenType[TokenType[\"LESS_THAN_EQUAL\"] = 32] = \"LESS_THAN_EQUAL\";\n    TokenType[TokenType[\"GREATER_THAN\"] = 33] = \"GREATER_THAN\";\n    TokenType[TokenType[\"LESS_THAN\"] = 34] = \"LESS_THAN\";\n    TokenType[TokenType[\"ASSIGN\"] = 35] = \"ASSIGN\";\n    TokenType[TokenType[\"AND\"] = 36] = \"AND\";\n    TokenType[TokenType[\"OR\"] = 37] = \"OR\";\n    TokenType[TokenType[\"ADD\"] = 38] = \"ADD\";\n    TokenType[TokenType[\"SUBTRACT\"] = 39] = \"SUBTRACT\";\n    TokenType[TokenType[\"MULTIPLY\"] = 40] = \"MULTIPLY\";\n    TokenType[TokenType[\"DIVIDE\"] = 41] = \"DIVIDE\";\n    TokenType[TokenType[\"ADD_ASSIGN\"] = 42] = \"ADD_ASSIGN\";\n    TokenType[TokenType[\"SUBTRACT_ASSIGN\"] = 43] = \"SUBTRACT_ASSIGN\";\n    TokenType[TokenType[\"MULTIPLY_ASSIGN\"] = 44] = \"MULTIPLY_ASSIGN\";\n    TokenType[TokenType[\"DIVIDE_ASSIGN\"] = 45] = \"DIVIDE_ASSIGN\";\n    TokenType[TokenType[\"EXCLAMATION_POINT\"] = 46] = \"EXCLAMATION_POINT\";\n    TokenType[TokenType[\"ELEMENT_REFERENCE\"] = 47] = \"ELEMENT_REFERENCE\";\n    TokenType[TokenType[\"ELEMENT_ATTRIBUTE\"] = 48] = \"ELEMENT_ATTRIBUTE\";\n    TokenType[TokenType[\"ELEMENT_QUERY\"] = 49] = \"ELEMENT_QUERY\";\n})(TokenType = exports.TokenType || (exports.TokenType = {}));\nconst TOKEN_PATTERNS = [\n    {\n        type: TokenType.WHITESPACE,\n        pattern: /^[\\s\\n\\r]+/\n    },\n    {\n        type: TokenType.TYPE_INT,\n        pattern: /^int+/\n    },\n    {\n        type: TokenType.TYPE_UINT,\n        pattern: /^uint+/\n    },\n    {\n        type: TokenType.TYPE_FLOAT,\n        pattern: /^float+/\n    },\n    {\n        type: TokenType.TYPE_STRING,\n        pattern: /^string+/\n    },\n    {\n        type: TokenType.BOOLEAN_LITERAL,\n        pattern: /^(true|false)/\n    },\n    {\n        type: TokenType.NULL_LITERAL,\n        pattern: /^null/\n    },\n    {\n        type: TokenType.RETURN,\n        pattern: /^return\\s/\n    },\n    {\n        type: TokenType.OF,\n        pattern: /^of\\s/\n    },\n    {\n        type: TokenType.FOR,\n        pattern: /^for\\s/\n    },\n    {\n        type: TokenType.IF,\n        pattern: /^if\\s/\n    },\n    {\n        type: TokenType.ELSE_IF,\n        pattern: /^else if\\s/\n    },\n    {\n        type: TokenType.ELSE,\n        pattern: /^else\\s/\n    },\n    {\n        type: TokenType.ELEMENT_ATTRIBUTE,\n        pattern: /^\\.@[_a-zA-Z0-9]*/\n    },\n    {\n        type: TokenType.ELEMENT_REFERENCE,\n        pattern: /^#[-_a-zA-Z0-9]*/\n    },\n    {\n        type: TokenType.ELEMENT_QUERY,\n        pattern: /^\\?([#.\\[\\],=\\-_a-zA-Z0-9*\\s]*[\\]_a-zA-Z0-9*])/\n    },\n    {\n        type: TokenType.NAME,\n        pattern: /^[$_a-zA-Z][_a-zA-Z0-9]*/\n    },\n    {\n        type: TokenType.NUMBER_LITERAL,\n        pattern: /^-?\\d+(?:\\.\\d+)?(?:e[+\\-]?\\d+)?/i\n    },\n    {\n        type: TokenType.L_BRACE,\n        pattern: /^{/\n    },\n    {\n        type: TokenType.R_BRACE,\n        pattern: /^}/\n    },\n    {\n        type: TokenType.L_BRACKET,\n        pattern: /^\\[/\n    },\n    {\n        type: TokenType.R_BRACKET,\n        pattern: /^]/\n    },\n    {\n        type: TokenType.L_PAREN,\n        pattern: /^\\(/\n    },\n    {\n        type: TokenType.R_PAREN,\n        pattern: /^\\)/\n    },\n    {\n        type: TokenType.PERIOD,\n        pattern: /^\\./\n    },\n    {\n        type: TokenType.COMMA,\n        pattern: /^,/\n    },\n    {\n        type: TokenType.EQUALS,\n        pattern: /^==/\n    },\n    {\n        type: TokenType.NOT_EQUALS,\n        pattern: /^!=/\n    },\n    {\n        type: TokenType.GREATER_THAN,\n        pattern: /^>/\n    },\n    {\n        type: TokenType.LESS_THAN,\n        pattern: /^</\n    },\n    {\n        type: TokenType.GREATER_THAN_EQUAL,\n        pattern: /^>=/\n    },\n    {\n        type: TokenType.LESS_THAN_EQUAL,\n        pattern: /^<=/\n    },\n    {\n        type: TokenType.COLON,\n        pattern: /^:/\n    },\n    {\n        type: TokenType.SEMI_COLON,\n        pattern: /^;/\n    },\n    {\n        type: TokenType.STRING_LITERAL,\n        pattern: /^\"([^\"]*)\"/\n    },\n    {\n        type: TokenType.STRING_LITERAL,\n        pattern: /^'([^']*)'/ // Try to make this work: /^(?<!\\\\)(?:\\\\\\\\)*\"([^(?<!\\\\)(?:\\\\\\\\)*\"]*)(?<!\\\\)(?:\\\\\\\\)*\"/\n    },\n    {\n        type: TokenType.AND,\n        pattern: /^&&/\n    },\n    {\n        type: TokenType.OR,\n        pattern: /^\\|\\|/\n    },\n    {\n        type: TokenType.ADD_ASSIGN,\n        pattern: /^\\+=/\n    },\n    {\n        type: TokenType.SUBTRACT_ASSIGN,\n        pattern: /^-=/\n    },\n    {\n        type: TokenType.MULTIPLY_ASSIGN,\n        pattern: /^\\*=/\n    },\n    {\n        type: TokenType.DIVIDE_ASSIGN,\n        pattern: /^\\/=/\n    },\n    {\n        type: TokenType.ADD,\n        pattern: /^\\+/\n    },\n    {\n        type: TokenType.SUBTRACT,\n        pattern: /^-/\n    },\n    {\n        type: TokenType.MULTIPLY,\n        pattern: /^\\*/\n    },\n    {\n        type: TokenType.DIVIDE,\n        pattern: /^\\//\n    },\n    {\n        type: TokenType.ASSIGN,\n        pattern: /^=/\n    },\n    {\n        type: TokenType.EXCLAMATION_POINT,\n        pattern: /^!/\n    }\n];\nclass Node {\n    constructor() {\n        this.requiresPrep = false;\n    }\n    isPreparationRequired() {\n        if (this.requiresPrep)\n            return true;\n        if (this._isPreparationRequired !== undefined)\n            return this._isPreparationRequired;\n        for (const node of this.getChildNodes()) {\n            if (node.isPreparationRequired()) {\n                this._isPreparationRequired = true;\n                return true;\n            }\n        }\n        return false;\n    }\n    prepare(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const node of this.getChildNodes()) {\n                yield node.prepare(scope, dom);\n            }\n        });\n    }\n    _getChildNodes() {\n        return [];\n    }\n    getChildNodes() {\n        if (this.childNodes === undefined) {\n            this.childNodes = this._getChildNodes();\n        }\n        return this.childNodes;\n    }\n    findChildrenByType(t) {\n        return this.findChildrenByTypes([t]);\n    }\n    findChildrenByTypes(types) {\n        const nodes = [];\n        for (const child of this.getChildNodes()) {\n            for (const t of types) {\n                if (child instanceof t)\n                    nodes.push(child);\n                const childNodes = child.findChildrenByType(t);\n                nodes.push(...childNodes);\n            }\n        }\n        return nodes;\n    }\n}\nexports.Node = Node;\nclass BlockNode extends Node {\n    constructor(statements) {\n        super();\n        this.statements = statements;\n    }\n    _getChildNodes() {\n        return [...this.statements];\n    }\n    evaluate(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let returnValue = null;\n            for (let i = 0; i < this.statements.length; i++) {\n                returnValue = yield this.statements[i].evaluate(scope, dom);\n            }\n            return returnValue;\n        });\n    }\n}\nexports.BlockNode = BlockNode;\nclass ComparisonNode extends Node {\n    constructor(left, right, type) {\n        super();\n        this.left = left;\n        this.right = right;\n        this.type = type;\n    }\n    _getChildNodes() {\n        return [\n            this.left,\n            this.right\n        ];\n    }\n    evaluate(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const left = yield this.left.evaluate(scope, dom);\n            const right = yield this.right.evaluate(scope, dom);\n            switch (this.type) {\n                case TokenType.EQUALS:\n                    return left === right;\n                case TokenType.NOT_EQUALS:\n                    return left !== right;\n                case TokenType.GREATER_THAN:\n                    return left > right;\n                case TokenType.LESS_THAN:\n                    return left < right;\n                case TokenType.GREATER_THAN_EQUAL:\n                    return left >= right;\n                case TokenType.LESS_THAN_EQUAL:\n                    return left <= right;\n            }\n        });\n    }\n    static match(tokens) {\n        return [\n            TokenType.EQUALS,\n            TokenType.NOT_EQUALS,\n            TokenType.GREATER_THAN,\n            TokenType.LESS_THAN,\n            TokenType.GREATER_THAN_EQUAL,\n            TokenType.LESS_THAN_EQUAL\n        ].indexOf(tokens[0].type) > -1;\n    }\n    static parse(lastNode, token, tokens) {\n        tokens.splice(0, 1); // Remove comparison operator\n        return new ComparisonNode(lastNode, Tree.processTokens(Tree.getNextStatementTokens(tokens)), token.type);\n    }\n}\nclass ConditionalNode extends Node {\n    constructor(condition, block) {\n        super();\n        this.condition = condition;\n        this.block = block;\n    }\n    _getChildNodes() {\n        return [\n            this.condition,\n            this.block\n        ];\n    }\n    evaluate(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const condition = yield this.condition.evaluate(scope, dom);\n            if (condition) {\n                return yield this.block.evaluate(scope, dom);\n            }\n            return null;\n        });\n    }\n}\nclass IfStatementNode extends Node {\n    constructor(nodes) {\n        super();\n        this.nodes = nodes;\n    }\n    _getChildNodes() {\n        return [\n            ...this.nodes\n        ];\n    }\n    evaluate(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const condition of this.nodes) {\n                const uno = yield condition.condition.evaluate(scope, dom);\n                if (uno) {\n                    return yield condition.block.evaluate(scope, dom);\n                }\n            }\n        });\n    }\n    static parseConditional(tokens) {\n        if ([\n            TokenType.IF,\n            TokenType.ELSE_IF\n        ].indexOf(tokens[0].type) === -1) {\n            throw SyntaxError('Invalid Syntax');\n        }\n        tokens.splice(0, 1); // consume if and else if\n        return new ConditionalNode(Tree.processTokens(Tree.getBlockTokens(tokens, null)[0]), Tree.processTokens(Tree.getBlockTokens(tokens, null)[0]));\n    }\n    static parse(lastNode, token, tokens) {\n        if (tokens[1].type !== TokenType.L_PAREN) {\n            throw SyntaxError('If statement needs to be followed by a condition encased in parenthesis.');\n        }\n        const nodes = [];\n        nodes.push(IfStatementNode.parseConditional(tokens));\n        while (tokens.length > 0 && TokenType.ELSE_IF === tokens[0].type) {\n            nodes.push(IfStatementNode.parseConditional(tokens));\n        }\n        if (tokens.length > 0 && TokenType.ELSE === tokens[0].type) {\n            tokens.splice(0, 1); // Consume else\n            nodes.push(new ConditionalNode(new LiteralNode(true), Tree.processTokens(Tree.getBlockTokens(tokens, null)[0])));\n        }\n        return new IfStatementNode(nodes);\n    }\n}\nclass ForStatementNode extends Node {\n    constructor(variable, list, block) {\n        super();\n        this.variable = variable;\n        this.list = list;\n        this.block = block;\n    }\n    _getChildNodes() {\n        return [\n            this.variable,\n            this.list,\n            this.block\n        ];\n    }\n    evaluate(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const variable = yield this.variable.evaluate(scope, dom);\n            const list = yield this.list.evaluate(scope, dom);\n            for (let i = 0; i < list.length; i++) {\n                scope.set(variable, list[i]);\n                yield this.block.evaluate(scope, dom);\n            }\n            return null;\n        });\n    }\n    static parse(lastNode, token, tokens) {\n        if (tokens[1].type !== TokenType.L_PAREN) {\n            throw SyntaxError('Syntax error: Missing (');\n        }\n        if (tokens[3].type !== TokenType.OF) {\n            throw SyntaxError('Syntax error: Missing of');\n        }\n        tokens.splice(0, 1); // consume for\n        const loopDef = Tree.getNextStatementTokens(tokens);\n        const variableName = loopDef.splice(0, 1)[0];\n        loopDef.splice(0, 1); // consume of\n        const list = Tree.processTokens(loopDef);\n        const block = Tree.processTokens(Tree.getBlockTokens(tokens, null)[0]);\n        return new ForStatementNode(new LiteralNode(variableName.value), list, block);\n    }\n}\nclass NotNode extends Node {\n    constructor(toFlip) {\n        super();\n        this.toFlip = toFlip;\n    }\n    evaluate(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const flipping = yield this.toFlip.evaluate(scope, dom);\n            return !flipping;\n        });\n    }\n    _getChildNodes() {\n        return [\n            this.toFlip\n        ];\n    }\n    static parse(lastNode, token, tokens) {\n        tokens.splice(0, 1); // Remove not operator\n        let containedTokens;\n        if (tokens[0].type === TokenType.L_PAREN) {\n            containedTokens = Tree.getNextStatementTokens(tokens);\n        }\n        else {\n            containedTokens = Tree.consumeTypes(tokens, [\n                TokenType.BOOLEAN_LITERAL,\n                TokenType.NUMBER_LITERAL,\n                TokenType.STRING_LITERAL,\n                TokenType.NAME,\n                TokenType.PERIOD\n            ]);\n        }\n        return new NotNode(Tree.processTokens(containedTokens));\n    }\n}\nclass LiteralNode extends Node {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    evaluate(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.value;\n        });\n    }\n}\nclass BooleanLiteralNode extends LiteralNode {\n    constructor(value) {\n        super(value);\n        this.value = value;\n        this.value = value === 'true';\n    }\n}\nclass NumberLiteralNode extends LiteralNode {\n    constructor(value) {\n        super(value);\n        this.value = value;\n        if (this.value.indexOf('.') > -1) {\n            this.value = parseFloat(this.value);\n        }\n        else {\n            this.value = parseInt(this.value);\n        }\n    }\n}\nclass FunctionCallNode extends Node {\n    constructor(fnc, args) {\n        super();\n        this.fnc = fnc;\n        this.args = args;\n    }\n    _getChildNodes() {\n        return [\n            this.fnc,\n            this.args\n        ];\n    }\n    evaluate(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let functionScope = scope;\n            if (this.fnc instanceof ScopeMemberNode) {\n                functionScope = yield this.fnc.scope.evaluate(scope, dom);\n            }\n            const values = yield this.args.evaluate(scope, dom);\n            return (yield this.fnc.evaluate(scope, dom)).call(functionScope.wrapped || functionScope, ...values);\n        });\n    }\n}\nclass FunctionArgumentNode extends Node {\n    constructor(args) {\n        super();\n        this.args = args;\n    }\n    _getChildNodes() {\n        return [\n            ...this.args\n        ];\n    }\n    evaluate(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const values = [];\n            for (const arg of this.args) {\n                values.push(yield arg.evaluate(scope, dom));\n            }\n            return values;\n        });\n    }\n}\nclass ScopeMemberNode extends Node {\n    constructor(scope, name) {\n        super();\n        this.scope = scope;\n        this.name = name;\n    }\n    _getChildNodes() {\n        return [\n            this.scope,\n            this.name\n        ];\n    }\n    evaluate(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let scopes = [];\n            const values = [];\n            if (this.scope instanceof ElementQueryNode) {\n                scopes = yield this.scope.evaluate(scope, dom);\n            }\n            else\n                scopes.push(yield this.scope.evaluate(scope, dom));\n            for (let parent of scopes) {\n                if (parent instanceof Tag_1.Tag)\n                    parent = parent.scope;\n                if (!parent) {\n                    throw Error(`Cannot access \"${yield this.name.evaluate(scope, dom)}\" of undefined.`);\n                }\n                const name = yield this.name.evaluate(scope, dom);\n                const value = parent.get(name, false);\n                values.push(value instanceof Scope_1.Scope && value.wrapped || value);\n            }\n            return values.length === 1 ? values[0] : values;\n        });\n    }\n}\nclass RootScopeMemberNode extends Node {\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n    _getChildNodes() {\n        return [\n            this.name\n        ];\n    }\n    evaluate(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const value = scope.get(yield this.name.evaluate(scope, dom));\n            return value instanceof Scope_1.Scope && value.wrapped || value;\n        });\n    }\n}\nclass ArithmeticNode extends Node {\n    constructor(left, right, type) {\n        super();\n        this.left = left;\n        this.right = right;\n        this.type = type;\n    }\n    _getChildNodes() {\n        return [\n            this.left,\n            this.right\n        ];\n    }\n    evaluate(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const left = yield this.left.evaluate(scope, dom);\n            const right = yield this.right.evaluate(scope, dom);\n            switch (this.type) {\n                case TokenType.ADD:\n                    return left + right;\n                case TokenType.SUBTRACT:\n                    return left - right;\n                case TokenType.MULTIPLY:\n                    return left * right;\n                case TokenType.DIVIDE:\n                    return left / right;\n            }\n        });\n    }\n    static match(tokens) {\n        return [\n            TokenType.ADD,\n            TokenType.SUBTRACT,\n            TokenType.MULTIPLY,\n            TokenType.DIVIDE\n        ].indexOf(tokens[0].type) > -1;\n    }\n    static parse(lastNode, token, tokens) {\n        tokens.splice(0, 1); // Remove arithmetic operator\n        return new ArithmeticNode(lastNode, Tree.processTokens(Tree.getNextStatementTokens(tokens)), token.type);\n    }\n}\nclass ArithmeticAssignmentNode extends Node {\n    constructor(left, right, type) {\n        super();\n        this.left = left;\n        this.right = right;\n        this.type = type;\n    }\n    _getChildNodes() {\n        return [\n            this.left,\n            this.right\n        ];\n    }\n    evaluate(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let scopes = [];\n            const name = yield this.left.name.evaluate(scope, dom);\n            if (this.left instanceof ScopeMemberNode) {\n                const inner = yield this.left.scope.evaluate(scope, dom);\n                if (this.left.scope instanceof ElementQueryNode) {\n                    scopes.push(...inner);\n                }\n                else {\n                    scopes.push(inner);\n                }\n            }\n            else if (this.left instanceof ElementAttributeNode)\n                scopes = yield this.left.elementRef.evaluate(scope, dom);\n            else\n                scopes.push(scope);\n            const values = [];\n            for (let localScope of scopes) {\n                if (localScope instanceof Tag_1.Tag) {\n                    localScope = localScope.scope;\n                }\n                else if (localScope['$wrapped'] && localScope['$scope'])\n                    localScope = localScope['$scope'];\n                let left = yield this.left.evaluate(localScope, dom);\n                let right = yield this.right.evaluate(localScope, dom);\n                if (this.left instanceof ElementAttributeNode) {\n                    left = left[0];\n                }\n                if (this.right instanceof ElementAttributeNode) {\n                    right = right[0];\n                }\n                if (left instanceof Array) {\n                    if (!(right instanceof Array))\n                        right = [right];\n                    switch (this.type) {\n                        case TokenType.ASSIGN:\n                            left.splice(0, left.length);\n                            left.push(...right);\n                            break;\n                        case TokenType.ADD_ASSIGN:\n                            left.push(...right);\n                            break;\n                        case TokenType.SUBTRACT_ASSIGN:\n                            for (let i = left.length - 1; i >= 0; i--) {\n                                if (right.indexOf(left[i]) > -1) {\n                                    left.splice(i, 1);\n                                    i++;\n                                }\n                            }\n                            break;\n                    }\n                    /*\n                     We have to trigger a change manually here. Setting the variable on the scope with an array won't trigger\n                     it since we are modifying values inside of the array instance.\n                     */\n                    localScope.trigger(`change:${name}`);\n                }\n                else if (Number.isFinite(left)) {\n                    if (right !== null && !Number.isFinite(right))\n                        right = parseFloat(`${right}`);\n                    left = left;\n                    right = right;\n                    switch (this.type) {\n                        case TokenType.ASSIGN:\n                            left = right;\n                            break;\n                        case TokenType.ADD_ASSIGN:\n                            left += right;\n                            break;\n                        case TokenType.SUBTRACT_ASSIGN:\n                            left -= right;\n                            break;\n                        case TokenType.MULTIPLY_ASSIGN:\n                            left *= right;\n                            break;\n                        case TokenType.DIVIDE_ASSIGN:\n                            left /= right;\n                            break;\n                    }\n                    localScope.set(name, left);\n                }\n                else {\n                    left = right;\n                    localScope.set(name, left);\n                }\n                values.push(left);\n            }\n            return values.length > 1 ? values : values[0];\n        });\n    }\n    static match(tokens) {\n        return [\n            TokenType.ASSIGN,\n            TokenType.ADD_ASSIGN,\n            TokenType.SUBTRACT_ASSIGN,\n            TokenType.MULTIPLY_ASSIGN,\n            TokenType.DIVIDE_ASSIGN\n        ].indexOf(tokens[0].type) > -1;\n    }\n    static parsed(lastNode, token, tokens) {\n        if (!(lastNode instanceof RootScopeMemberNode) && !(lastNode instanceof ScopeMemberNode) && !(lastNode instanceof ElementAttributeNode)) {\n            throw SyntaxError('Invalid assignment syntax.');\n        }\n        tokens.splice(0, 1); // consume +=\n        const assignmentTokens = Tree.getNextStatementTokens(tokens);\n        return new ArithmeticAssignmentNode(lastNode, Tree.processTokens(assignmentTokens), token.type);\n    }\n    static parse(lastNode, token, tokens) {\n        if (!(lastNode instanceof RootScopeMemberNode) && !(lastNode instanceof ScopeMemberNode) && !(lastNode instanceof ElementAttributeNode)) {\n            throw SyntaxError(`Invalid assignment syntax near ${Tree.toCode(tokens.splice(0, 10))}`);\n        }\n        tokens.splice(0, 1); // consume =\n        const assignmentTokens = Tree.getNextStatementTokens(tokens, false, false, true);\n        return new ArithmeticAssignmentNode(lastNode, Tree.processTokens(assignmentTokens), token.type);\n    }\n}\nclass IndexNode extends Node {\n    constructor(object, index, indexTwo = null) {\n        super();\n        this.object = object;\n        this.index = index;\n        this.indexTwo = indexTwo;\n    }\n    _getChildNodes() {\n        const children = [\n            this.object,\n            this.index\n        ];\n        if (this.indexTwo)\n            children.push(this.indexTwo);\n        return children;\n    }\n    negativeIndex(obj, index) {\n        if (Number.isFinite(index) && index < 0)\n            return obj.length + index;\n        return index;\n    }\n    evaluate(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const obj = yield this.object.evaluate(scope, dom);\n            const index = this.negativeIndex(obj, yield this.index.evaluate(scope, dom));\n            if (Number.isFinite(index) && this.indexTwo) {\n                const indexTwo = this.negativeIndex(obj, yield this.indexTwo.evaluate(scope, dom));\n                const values = [];\n                for (let i = index; i <= indexTwo; i++) {\n                    values.push(obj[i]);\n                }\n                return values;\n            }\n            else {\n                return (obj)[index];\n            }\n        });\n    }\n    static match(tokens) {\n        return tokens[0].type === TokenType.L_BRACKET;\n    }\n    static parse(lastNode, token, tokens) {\n        const valueTokens = Tree.getBlockTokens(tokens, TokenType.COLON);\n        const values = [];\n        for (const arg of valueTokens) {\n            values.push(Tree.processTokens(arg));\n        }\n        return new IndexNode(lastNode, values[0], values.length > 1 && values[1]);\n    }\n}\nclass ArrayNode extends Node {\n    constructor(values) {\n        super();\n        this.values = values;\n    }\n    _getChildNodes() {\n        return new Array(...this.values);\n    }\n    evaluate(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const arr = [];\n            for (const val of this.values) {\n                arr.push(yield val.evaluate(scope, dom));\n            }\n            return arr;\n        });\n    }\n    static match(tokens) {\n        return tokens[0].type === TokenType.L_BRACKET;\n    }\n    static parse(lastNode, token, tokens) {\n        const valueTokens = Tree.getBlockTokens(tokens);\n        const values = [];\n        for (const arg of valueTokens) {\n            values.push(Tree.processTokens(arg));\n        }\n        return new ArrayNode(values);\n    }\n}\nclass ObjectNode extends Node {\n    constructor(keys, values) {\n        super();\n        this.keys = keys;\n        this.values = values;\n    }\n    _getChildNodes() {\n        return new Array(...this.values);\n    }\n    evaluate(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const obj = new Scope_1.Scope();\n            for (let i = 0; i < this.values.length; i++) {\n                const key = this.keys[i];\n                const val = this.values[i];\n                obj.set(yield key.evaluate(scope, dom), yield val.evaluate(scope, dom));\n            }\n            return obj;\n        });\n    }\n    static match(tokens) {\n        return tokens[0].type === TokenType.L_BRACE;\n    }\n    static parse(lastNode, token, tokens) {\n        const valueTokens = Tree.getNextStatementTokens(tokens);\n        const keys = [];\n        const values = [];\n        while (valueTokens.length > 0) {\n            const key = Tree.getTokensUntil(valueTokens, TokenType.COLON, false);\n            if (valueTokens[0].type !== TokenType.COLON)\n                throw Error('Invalid object literal syntax. Expecting :');\n            valueTokens.splice(0, 1); // Consume :\n            const val = Tree.getTokensUntil(valueTokens, TokenType.COMMA, true, false, true);\n            keys.push(Tree.processTokens(key));\n            values.push(Tree.processTokens(val));\n        }\n        return new ObjectNode(keys, values);\n    }\n}\nclass ElementQueryNode extends Node {\n    constructor(query) {\n        super();\n        this.query = query;\n        this.requiresPrep = true;\n    }\n    evaluate(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield dom.get(this.query, true);\n        });\n    }\n    prepare(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield dom.get(this.query, true);\n        });\n    }\n}\nclass ElementAttributeNode extends Node {\n    constructor(elementRef, attr) {\n        super();\n        this.elementRef = elementRef;\n        this.attr = attr;\n        this.requiresPrep = true;\n    }\n    get name() {\n        return new LiteralNode(`@${this.attributeName}`);\n    }\n    _getChildNodes() {\n        return [\n            this.elementRef\n        ];\n    }\n    get attributeName() {\n        if (this.attr.startsWith('.'))\n            return this.attr.substring(2);\n        return this.attr.substring(1);\n    }\n    evaluate(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tags = yield this.elementRef.evaluate(scope, dom);\n            return tags.map((tag) => tag.scope.get(`@${this.attributeName}`));\n        });\n    }\n    prepare(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.elementRef.prepare(scope, dom);\n            const tags = yield this.elementRef.evaluate(scope, dom);\n            for (const tag of tags)\n                yield tag.watchAttribute(this.attributeName);\n        });\n    }\n}\nexports.AttributableNodes = [\n    RootScopeMemberNode,\n    ScopeMemberNode,\n    ElementAttributeNode\n];\nclass Tree {\n    constructor(code) {\n        this.code = code;\n        if (Tree.cache[code]) {\n            this.rootNode = Tree.cache[code];\n        }\n        else {\n            this.parse();\n            Tree.cache[code] = this.rootNode;\n        }\n    }\n    parse() {\n        const tokens = Tree.tokenize(this.code);\n        this.rootNode = Tree.processTokens(tokens);\n    }\n    evaluate(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.rootNode.evaluate(scope, dom);\n        });\n    }\n    prepare(scope, dom) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.rootNode.isPreparationRequired())\n                return;\n            return yield this.rootNode.prepare(scope, dom);\n        });\n    }\n    bindToScopeChanges(scope, fnc) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const node of this.rootNode.findChildrenByTypes([RootScopeMemberNode, ScopeMemberNode])) {\n                let _scope = scope;\n                if (node instanceof ScopeMemberNode)\n                    _scope = yield node.scope.evaluate(scope, null);\n                const name = yield node.name.evaluate(scope, null);\n                _scope.bind(`change:${name}`, fnc);\n            }\n        });\n    }\n    static tokenize(code) {\n        const tokens = [];\n        if (!code || code.length === 0)\n            return tokens;\n        let foundToken;\n        do {\n            foundToken = false;\n            for (const tp of TOKEN_PATTERNS) {\n                const match = tp.pattern.exec(code);\n                if (match) {\n                    tokens.push({\n                        type: tp.type,\n                        value: match[match.length - 1]\n                    });\n                    code = code.substring(match[0].length);\n                    foundToken = true;\n                    break;\n                }\n            }\n        } while (code.length > 0 && foundToken);\n        return tokens;\n    }\n    static stripWhiteSpace(tokens) {\n        for (let i = 0; i < tokens.length; i++) {\n            if (tokens[i].type === TokenType.WHITESPACE) {\n                tokens.splice(i, 1);\n                i--;\n            }\n        }\n        return tokens;\n    }\n    static processTokens(tokens) {\n        let blockNodes = [];\n        let node = null;\n        let count = 0;\n        Tree.stripWhiteSpace(tokens);\n        while (tokens.length > 0) {\n            count++;\n            if (count > 1000)\n                break; // Limit to 1000 iterations while in development\n            if (tokens[0].type === TokenType.RETURN)\n                tokens.splice(0, 1);\n            const token = tokens[0];\n            if (token.type === TokenType.NAME) {\n                node = new RootScopeMemberNode(new LiteralNode(token.value));\n                tokens.splice(0, 1);\n            }\n            else if (token.type === TokenType.IF) {\n                node = IfStatementNode.parse(node, token, tokens);\n                blockNodes.push(node);\n                node = null;\n            }\n            else if (token.type === TokenType.FOR) {\n                node = ForStatementNode.parse(node, token, tokens);\n                blockNodes.push(node);\n                node = null;\n            }\n            else if (token.type === TokenType.STRING_LITERAL) {\n                node = new LiteralNode(token.value);\n                tokens.splice(0, 1);\n            }\n            else if (token.type === TokenType.NUMBER_LITERAL) {\n                node = new NumberLiteralNode(token.value);\n                tokens.splice(0, 1);\n            }\n            else if (tokens[0].type === TokenType.ELEMENT_REFERENCE) {\n                node = new ElementQueryNode(tokens[0].value);\n                tokens.splice(0, 1);\n            }\n            else if (tokens[0].type === TokenType.ELEMENT_QUERY) {\n                node = new ElementQueryNode(tokens[0].value);\n                tokens.splice(0, 1);\n            }\n            else if (tokens[0].type === TokenType.L_BRACKET) {\n                if (node) {\n                    node = IndexNode.parse(node, token, tokens);\n                }\n                else {\n                    node = ArrayNode.parse(node, token, tokens);\n                }\n            }\n            else if (tokens[0].type === TokenType.L_BRACE) {\n                node = ObjectNode.parse(node, token, tokens);\n            }\n            else if (tokens[0].type === TokenType.ELEMENT_ATTRIBUTE && node instanceof ElementQueryNode) {\n                node = new ElementAttributeNode(node, tokens[0].value);\n                tokens.splice(0, 1);\n            }\n            else if (node !== null && token.type === TokenType.PERIOD && tokens[1].type === TokenType.NAME) {\n                node = new ScopeMemberNode(node, new LiteralNode(tokens[1].value));\n                tokens.splice(0, 2);\n            }\n            else if (tokens[0].type === TokenType.L_PAREN) {\n                const funcArgs = Tree.getBlockTokens(tokens);\n                const nodes = [];\n                for (const arg of funcArgs) {\n                    nodes.push(Tree.processTokens(arg));\n                }\n                if (node) {\n                    node = new FunctionCallNode(node, // Previous node should be a NAME\n                    new FunctionArgumentNode(nodes));\n                }\n                else {\n                    node = new BlockNode(nodes);\n                }\n            }\n            else if (tokens[0].type === TokenType.SEMI_COLON) {\n                if (node) {\n                    blockNodes.push(node);\n                }\n                node = null;\n                tokens.splice(0, 1);\n            }\n            else if (ComparisonNode.match(tokens)) {\n                node = ComparisonNode.parse(node, token, tokens);\n            }\n            else if (ArithmeticNode.match(tokens)) {\n                node = ArithmeticNode.parse(node, token, tokens);\n            }\n            else if (ArithmeticAssignmentNode.match(tokens)) {\n                node = ArithmeticAssignmentNode.parse(node, token, tokens);\n            }\n            else if (tokens[0].type === TokenType.WHITESPACE) {\n                tokens.splice(0, 1);\n            }\n            else if (tokens[0].type === TokenType.BOOLEAN_LITERAL) {\n                node = new BooleanLiteralNode(tokens[0].value);\n                tokens.splice(0, 1);\n            }\n            else if (tokens[0].type === TokenType.NULL_LITERAL) {\n                node = new LiteralNode(null);\n                tokens.splice(0, 1);\n            }\n            else if (tokens[0].type === TokenType.EXCLAMATION_POINT) {\n                node = NotNode.parse(node, tokens[0], tokens);\n            }\n            else {\n                let code = Tree.toCode(tokens, 10);\n                throw Error(`Syntax Error. Near ${code}`);\n            }\n        }\n        if (node) {\n            blockNodes.push(node);\n        }\n        return new BlockNode(blockNodes);\n    }\n    static toCode(tokens, limit) {\n        let code = '';\n        limit = limit || tokens.length;\n        for (let i = 0; i < limit; i++) {\n            if (!tokens[i])\n                break;\n            code += tokens[i].value;\n        }\n        return code;\n    }\n    static getBlockInfo(tokens) {\n        let blockType;\n        const opener = tokens[0];\n        if (opener.type === TokenType.L_PAREN)\n            blockType = BlockType.PAREN;\n        else if (opener.type === TokenType.L_BRACE)\n            blockType = BlockType.BRACE;\n        else if (opener.type === TokenType.L_BRACKET)\n            blockType = BlockType.BRACKET;\n        else\n            blockType = BlockType.STATEMENT;\n        let open;\n        let close;\n        let openCharacter;\n        let closeCharacter;\n        switch (blockType) {\n            case BlockType.PAREN:\n                open = TokenType.L_PAREN;\n                close = TokenType.R_PAREN;\n                openCharacter = '(';\n                closeCharacter = ')';\n                break;\n            case BlockType.BRACE:\n                open = TokenType.L_BRACE;\n                close = TokenType.R_BRACE;\n                openCharacter = '{';\n                closeCharacter = '}';\n                break;\n            case BlockType.BRACKET:\n                open = TokenType.L_BRACKET;\n                close = TokenType.R_BRACKET;\n                openCharacter = '[';\n                closeCharacter = ']';\n                break;\n            default:\n                open = null;\n                close = TokenType.SEMI_COLON;\n                openCharacter = null;\n                closeCharacter = ';';\n                break;\n        }\n        return {\n            type: blockType,\n            open: open,\n            close: close,\n            openCharacter: openCharacter,\n            closeCharacter: closeCharacter\n        };\n    }\n    static getNextStatementTokens(tokens, consumeClosingToken = true, consumeOpeningToken = true, includeClosingToken = false) {\n        const blockInfo = Tree.getBlockInfo(tokens);\n        // Consume opening block token\n        if (consumeOpeningToken && tokens[0].type === blockInfo.open) {\n            tokens.splice(0, 1);\n        }\n        return Tree.getTokensUntil(tokens, blockInfo.close, consumeClosingToken, includeClosingToken);\n    }\n    static getBlockTokens(tokens, groupBy = TokenType.COMMA) {\n        const blockInfo = Tree.getBlockInfo(tokens);\n        let openBlocks = 0;\n        const args = [];\n        let arg = [];\n        for (let i = 0; i < tokens.length; i++) {\n            const token = tokens[i];\n            if (token.type === blockInfo.open) {\n                openBlocks += 1;\n                if (openBlocks > 1)\n                    arg.push(token);\n            }\n            else if (token.type === blockInfo.close) {\n                openBlocks -= 1;\n                if (openBlocks > 0)\n                    arg.push(token);\n            }\n            else if (groupBy !== null && token.type === groupBy && openBlocks == 1) {\n                args.push(arg);\n                arg = [];\n            }\n            else if (token.type !== TokenType.WHITESPACE) {\n                arg.push(token);\n            }\n            // Consume token\n            tokens.splice(0, 1);\n            i--;\n            if (openBlocks === 0) {\n                if (arg.length > 0)\n                    args.push(arg);\n                return args;\n            }\n        }\n        throw Error(`Invalid Syntax, missing ${blockInfo.closeCharacter}`);\n    }\n    static getTokensUntil(tokens, terminator = TokenType.SEMI_COLON, consumeTerminator = true, includeTerminator = false, validIfTerminatorNotFound = false) {\n        const statementTokens = [];\n        const blockInfo = Tree.getBlockInfo(tokens);\n        let openParens = 0;\n        let openBraces = 0;\n        let openBrackets = 0;\n        for (let i = 0; i < tokens.length; i++) {\n            const token = tokens[i];\n            if (!(token.type === blockInfo.open && i === 0)) { // Skip opener\n                if (token.type === TokenType.L_PAREN)\n                    openParens += 1;\n                if (token.type === TokenType.L_BRACE)\n                    openBraces += 1;\n                if (token.type === TokenType.L_BRACKET)\n                    openBrackets += 1;\n            }\n            if ([\n                terminator,\n                TokenType.R_BRACKET,\n                TokenType.R_BRACE,\n                TokenType.R_PAREN\n            ].indexOf(token.type) > -1) {\n                if (openParens > 0 && token.type === TokenType.R_PAREN) {\n                    openParens -= 1;\n                }\n                else if (openBraces > 0 && token.type === TokenType.R_BRACE) {\n                    openBraces -= 1;\n                }\n                else if (openBrackets > 0 && token.type === TokenType.R_BRACKET) {\n                    openBrackets -= 1;\n                }\n                else if (openParens === 0 && openBraces === 0 && openBrackets === 0 && token.type === terminator) {\n                    if (includeTerminator)\n                        statementTokens.push(token);\n                    if ((includeTerminator || consumeTerminator) && token.type !== TokenType.SEMI_COLON)\n                        tokens.splice(0, 1); // Consume end of block\n                    break;\n                }\n                else {\n                    if (validIfTerminatorNotFound)\n                        break;\n                    throw Error(`Invalid syntax, expecting ${terminator}.`);\n                }\n            }\n            statementTokens.push(token);\n            tokens.splice(0, 1); // Consume part of statement\n            i--;\n        }\n        return statementTokens;\n    }\n    static consumeTypes(tokens, types) {\n        const matching = [];\n        for (const token of tokens) {\n            if (types.indexOf(token.type) > -1) {\n                matching.push(token);\n            }\n            else {\n                break;\n            }\n        }\n        tokens.splice(0, matching.length);\n        return matching;\n    }\n}\nexports.Tree = Tree;\nTree.cache = {};\n\n\n//# sourceURL=webpack://vsn/./src/AST.ts?");

/***/ }),

/***/ "./src/Attribute.ts":
/*!**************************!*\
  !*** ./src/Attribute.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Attribute = void 0;\nclass Attribute {\n    constructor(tag, attributeName) {\n        this.tag = tag;\n        this.attributeName = attributeName;\n        this.configure();\n    }\n    configure() {\n        return __awaiter(this, void 0, void 0, function* () { });\n    }\n    ;\n    compile() {\n        return __awaiter(this, void 0, void 0, function* () { });\n    }\n    ;\n    setup() {\n        return __awaiter(this, void 0, void 0, function* () { });\n    }\n    ;\n    extract() {\n        return __awaiter(this, void 0, void 0, function* () { });\n    }\n    ;\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () { });\n    }\n    evaluate() {\n        return __awaiter(this, void 0, void 0, function* () { });\n    }\n    ;\n    getAttributeValue(fallback = null) {\n        return this.tag.getRawAttributeValue(this.attributeName, fallback);\n    }\n    getAttributeBinding(fallback = null) {\n        return this.tag.getAttributeBinding(this.attributeName) || fallback;\n    }\n    getAttributeModifiers(fallback = []) {\n        const modifiers = this.tag.getAttributeModifiers(this.attributeName);\n        return modifiers.length && modifiers || fallback;\n    }\n    hasModifier(mod) {\n        return this.getAttributeModifiers().indexOf(mod) > -1;\n    }\n    mutate(mutation) { }\n    set value(value) {\n        this.tag.element.setAttribute(this.attributeName, value);\n    }\n    get value() {\n        return this.tag.element.getAttribute(this.attributeName) || '';\n    }\n}\nexports.Attribute = Attribute;\nAttribute.scoped = false;\n\n\n//# sourceURL=webpack://vsn/./src/Attribute.ts?");

/***/ }),

/***/ "./src/Bencmark.ts":
/*!*************************!*\
  !*** ./src/Bencmark.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.benchmarkResultsAll = exports.benchmarkResultsMatch = exports.benchmarkResults = exports.benchmark = exports.BENCHMARKS = void 0;\nconst VisionHelper_1 = __webpack_require__(/*! ./helpers/VisionHelper */ \"./src/helpers/VisionHelper.ts\");\nexports.BENCHMARKS = [];\nfunction benchmark(name, print = false) {\n    return function (target, key, descriptor) {\n        if (VisionHelper_1.VisionHelper.inDevelopment) {\n            name = name || key;\n            const method = descriptor.value;\n            descriptor.value = function () {\n                const start = new Date();\n                const result = method.apply(this, arguments);\n                const end = new Date();\n                const data = {\n                    name: name,\n                    time: end.getTime() - start.getTime()\n                };\n                exports.BENCHMARKS.push(data);\n                if (print)\n                    console.log(data);\n                return result;\n            };\n        }\n    };\n}\nexports.benchmark = benchmark;\nfunction benchmarkResults(name) {\n    if (VisionHelper_1.VisionHelper.inDevelopment) {\n        let calls = 0;\n        let time = 0;\n        for (const bm of exports.BENCHMARKS)\n            if (bm.name === name) {\n                calls++;\n                time += bm.time;\n            }\n        return {\n            name: name,\n            calls: calls,\n            time: time,\n            average: time / calls\n        };\n    }\n}\nexports.benchmarkResults = benchmarkResults;\nfunction benchmarkResultsMatch(regexp) {\n    if (VisionHelper_1.VisionHelper.inDevelopment) {\n        const data = {};\n        let calls = 0;\n        let time = 0;\n        for (const bm of exports.BENCHMARKS) {\n            if (regexp.test(bm.name) && !data[bm.name]) {\n                data[bm.name] = benchmarkResults(bm.name);\n                calls += data[bm.name].calls;\n                time += data[bm.name].time;\n            }\n        }\n        data['ALL'] = {\n            name: 'ALL',\n            calls: calls,\n            time: time,\n            average: time / calls\n        };\n        return data;\n    }\n}\nexports.benchmarkResultsMatch = benchmarkResultsMatch;\nfunction benchmarkResultsAll() {\n    if (VisionHelper_1.VisionHelper.inDevelopment) {\n        console.log('wut');\n        const data = {};\n        let calls = 0;\n        let time = 0;\n        for (const bm of exports.BENCHMARKS) {\n            if (!data[bm.name]) {\n                data[bm.name] = benchmarkResults(bm.name);\n                calls += data[bm.name].calls;\n                time += data[bm.name].time;\n            }\n        }\n        data['ALL'] = {\n            name: 'ALL',\n            calls: calls,\n            time: time,\n            average: time / calls\n        };\n        return data;\n    }\n}\nexports.benchmarkResultsAll = benchmarkResultsAll;\nif (VisionHelper_1.VisionHelper.inDevelopment && VisionHelper_1.VisionHelper.window) {\n    window['benchmark'] = benchmark;\n    window['benchmarks'] = exports.BENCHMARKS;\n    window['benchmarkResults'] = benchmarkResults;\n    window['benchmarkResultsMatch'] = benchmarkResultsMatch;\n    window['benchmarkResultsAll'] = benchmarkResultsAll;\n}\n\n\n//# sourceURL=webpack://vsn/./src/Bencmark.ts?");

/***/ }),

/***/ "./src/Configuration.ts":
/*!******************************!*\
  !*** ./src/Configuration.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Configuration = void 0;\nconst simple_ts_event_dispatcher_1 = __webpack_require__(/*! simple-ts-event-dispatcher */ \"./node_modules/simple-ts-event-dispatcher/dist/EventDispatcher.js\");\nconst VisionHelper_1 = __webpack_require__(/*! ./helpers/VisionHelper */ \"./src/helpers/VisionHelper.ts\");\nclass Configuration extends simple_ts_event_dispatcher_1.EventDispatcher {\n    constructor() {\n        super();\n        this.data = VisionHelper_1.VisionHelper.window && window['$configuration'] || {};\n    }\n    get(key, defaultValue = null) {\n        return this.data[key] === undefined ? defaultValue : this.data[key];\n    }\n    set(key, value) {\n        const prev = this.data[key];\n        this.data[key] = value;\n        this.trigger(`change:${key}`, {\n            value: value,\n            previous: prev\n        });\n        this.trigger('change', {\n            key: key,\n            value: value,\n            previous: prev\n        });\n    }\n    static set(key, value) {\n        Configuration.instance.set(key, value);\n    }\n    static get(key, defaultValue = null) {\n        return Configuration.instance.get(key, defaultValue);\n    }\n    static get instance() {\n        if (!Configuration._instance)\n            Configuration._instance = new Configuration();\n        return Configuration._instance;\n    }\n}\nexports.Configuration = Configuration;\n\n\n//# sourceURL=webpack://vsn/./src/Configuration.ts?");

/***/ }),

/***/ "./src/DOM.ts":
/*!********************!*\
  !*** ./src/DOM.ts ***!
  \********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DOM = void 0;\nconst Tag_1 = __webpack_require__(/*! ./Tag */ \"./src/Tag.ts\");\nconst ElementHelper_1 = __webpack_require__(/*! ./helpers/ElementHelper */ \"./src/helpers/ElementHelper.ts\");\nconst simple_ts_event_dispatcher_1 = __webpack_require__(/*! simple-ts-event-dispatcher */ \"./node_modules/simple-ts-event-dispatcher/dist/EventDispatcher.js\");\nconst Configuration_1 = __webpack_require__(/*! ./Configuration */ \"./src/Configuration.ts\");\nconst AST_1 = __webpack_require__(/*! ./AST */ \"./src/AST.ts\");\nconst List_1 = __webpack_require__(/*! ./Tag/List */ \"./src/Tag/List.ts\");\nconst Bencmark_1 = __webpack_require__(/*! ./Bencmark */ \"./src/Bencmark.ts\");\nclass DOM extends simple_ts_event_dispatcher_1.EventDispatcher {\n    constructor(rootElement, build = true, debug = false) {\n        super();\n        this.rootElement = rootElement;\n        this.debug = debug;\n        this.queued = [];\n        this.observer = new MutationObserver(this.mutation.bind(this));\n        this.tags = [];\n        if (build) {\n            this.buildFrom(rootElement, true);\n        }\n        this.evaluate();\n        Configuration_1.Configuration.instance.bind('change', this.evaluate.bind(this));\n    }\n    get(selector, create = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const nodes = this.querySelectorAll(selector);\n            return yield this.getTagsForElement(Array.from(nodes), create);\n        });\n    }\n    registerElementInRoot(tag) {\n        const id = tag.element.getAttribute('id');\n        if (!!id)\n            this.root.scope.set(`#${id}`, tag.scope);\n    }\n    querySelectorAll(q) {\n        return this.rootElement.querySelectorAll(q);\n    }\n    querySelector(q) {\n        return this.rootElement.querySelector(q);\n    }\n    eval(code) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tree = new AST_1.Tree(code);\n            yield tree.prepare(this.root.scope, this);\n            return yield tree.evaluate(this.root.scope, this);\n        });\n    }\n    evaluate() {\n        return __awaiter(this, void 0, void 0, function* () {\n            clearTimeout(this.evaluateTimeout);\n            for (const tag of this.tags) {\n                yield tag.evaluate();\n            }\n        });\n    }\n    mutation(mutations) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const mutation of mutations) {\n                const tag = yield this.getTagForElement(mutation.target);\n                if (tag) {\n                    tag.mutate(mutation);\n                }\n            }\n        });\n    }\n    buildFrom(ele, isRoot = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Assign parents to each tag\n            const allElements = [];\n            if (isRoot) {\n                document.body.setAttribute('vsn-root', '');\n                document.ondragover = (e) => e.preventDefault(); // Allow dragging over document\n            }\n            for (const tag of this.tags)\n                allElements.push(tag.element);\n            // Create tags for each html element with a v-attribute\n            const newTags = [];\n            const toBuild = [];\n            if (ele && ele.querySelectorAll) {\n                for (const element of Array.from(ele.querySelectorAll(`*`))) { // Don't build items more than once\n                    if (!ElementHelper_1.ElementHelper.hasVisionAttribute(element))\n                        continue;\n                    if (this.queued.indexOf(element) > -1)\n                        continue;\n                    this.queued.push(element);\n                    toBuild.push(element);\n                }\n            }\n            for (const element of toBuild) {\n                if (allElements.indexOf(element) > -1)\n                    continue;\n                const tag = new Tag_1.Tag(element, this);\n                this.tags.push(tag);\n                newTags.push(tag);\n                allElements.push(element);\n            }\n            if (isRoot)\n                this.root = yield this.getTagForElement(document.body);\n            // Configure, setup & execute attributes\n            for (const tag of newTags)\n                yield tag.buildAttributes();\n            for (const tag of newTags)\n                yield tag.compileAttributes();\n            for (const tag of newTags) {\n                if (tag === this.root)\n                    continue;\n                // Find closest ancestor\n                let parentElement = tag.element.parentElement;\n                let foundParent = false;\n                while (parentElement) {\n                    if (allElements.indexOf(parentElement) > -1) {\n                        foundParent = true;\n                        tag.parentTag = yield this.getTagForElement(parentElement);\n                        break;\n                    }\n                    parentElement = parentElement.parentElement;\n                }\n                if (!foundParent)\n                    console.error('Could not find parent for ', tag);\n            }\n            for (const tag of newTags)\n                yield tag.setupAttributes();\n            for (const tag of newTags)\n                yield tag.extractAttributes();\n            for (const tag of newTags)\n                yield tag.connectAttributes();\n            for (const tag of newTags) {\n                yield tag.finalize();\n                this.queued.splice(this.queued.indexOf(tag.element), 1);\n            }\n            for (const tag of newTags)\n                this.observer.observe(tag.element, {\n                    attributes: true,\n                    characterData: true,\n                    childList: true,\n                    subtree: true\n                });\n            this.trigger('built');\n        });\n    }\n    getTagsForElement(elements, create = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tags = new List_1.TagList();\n            const found = [];\n            for (const tag of this.tags) {\n                if (elements.indexOf(tag.element) > -1) {\n                    tags.push(tag);\n                    found.push(tag.element);\n                }\n            }\n            if (create) {\n                const notFound = [...elements];\n                for (let i = notFound.length; i >= 0; i--) {\n                    const element = notFound[i];\n                    if (found.indexOf(element) > -1)\n                        notFound.pop();\n                }\n                for (const element of notFound) {\n                    tags.push(yield this.getTagForElement(element, create));\n                }\n            }\n            return tags;\n        });\n    }\n    getTagForElement(element, create = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const tag of this.tags) {\n                if (tag.element === element)\n                    return tag;\n            }\n            if (element && create) {\n                element.setAttribute('vsn-ref', '');\n                yield this.buildFrom(element.parentElement);\n                return yield this.getTagForElement(element, false);\n            }\n            return null;\n        });\n    }\n    static get instance() {\n        if (!DOM._instance)\n            DOM._instance = new DOM(document, false, false);\n        return DOM._instance;\n    }\n}\n__decorate([\n    Bencmark_1.benchmark(\"buildFrom\")\n], DOM.prototype, \"buildFrom\", null);\nexports.DOM = DOM;\n\n\n//# sourceURL=webpack://vsn/./src/DOM.ts?");

/***/ }),

/***/ "./src/Formats.ts":
/*!************************!*\
  !*** ./src/Formats.ts ***!
  \************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Formats = void 0;\nconst Registry_1 = __webpack_require__(/*! ./Registry */ \"./src/Registry.ts\");\nconst Configuration_1 = __webpack_require__(/*! ./Configuration */ \"./src/Configuration.ts\");\nclass Formats {\n    static currency(value) {\n        if (!Formats.CurrencyFormatter) {\n            const setup = () => {\n                const locale = Configuration_1.Configuration.get('locale', 'en-US');\n                const currency = Configuration_1.Configuration.get('currency', 'USD');\n                Formats.CurrencyFormatter = new Intl.NumberFormat(locale, {\n                    style: 'currency',\n                    currency: currency\n                });\n            };\n            Configuration_1.Configuration.instance.bind('change:locale', setup);\n            Configuration_1.Configuration.instance.bind('change:currency', setup);\n            setup();\n        }\n        value = `${value}`.replace(/[^0-9.]+/, '');\n        return Formats.CurrencyFormatter.format(parseFloat(value));\n    }\n    static date(value) {\n        return value ? value.toLocaleString() : '';\n    }\n}\n__decorate([\n    Registry_1.Registry.format('currency')\n], Formats, \"currency\", null);\n__decorate([\n    Registry_1.Registry.format('date')\n], Formats, \"date\", null);\nexports.Formats = Formats;\n\n\n//# sourceURL=webpack://vsn/./src/Formats.ts?");

/***/ }),

/***/ "./src/Query.ts":
/*!**********************!*\
  !*** ./src/Query.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Query = void 0;\nconst List_1 = __webpack_require__(/*! ./Tag/List */ \"./src/Tag/List.ts\");\nconst VisionHelper_1 = __webpack_require__(/*! ./helpers/VisionHelper */ \"./src/helpers/VisionHelper.ts\");\nconst DOM_1 = __webpack_require__(/*! ./DOM */ \"./src/DOM.ts\");\nfunction Query(selector, dom = null) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (VisionHelper_1.VisionHelper.document) {\n            dom = dom || DOM_1.DOM.instance;\n            return yield dom.get(selector, true);\n        }\n        return new List_1.TagList();\n    });\n}\nexports.Query = Query;\n\n\n//# sourceURL=webpack://vsn/./src/Query.ts?");

/***/ }),

/***/ "./src/Registry.ts":
/*!*************************!*\
  !*** ./src/Registry.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Registry = exports.RegistryStore = exports.register = void 0;\nconst simple_ts_event_dispatcher_1 = __webpack_require__(/*! simple-ts-event-dispatcher */ \"./node_modules/simple-ts-event-dispatcher/dist/EventDispatcher.js\");\nconst simple_ts_promise_1 = __webpack_require__(/*! simple-ts-promise */ \"./node_modules/simple-ts-promise/dist/Promise.js\");\nconst VisionHelper_1 = __webpack_require__(/*! ./helpers/VisionHelper */ \"./src/helpers/VisionHelper.ts\");\nfunction register(store, key = null, setup = null) {\n    return function (target, _key = null) {\n        key = key || target.prototype.constructor.name;\n        if (_key !== null)\n            target = target[_key];\n        Registry.instance[store].register(key, target);\n        if (setup)\n            setup();\n    };\n}\nexports.register = register;\nclass RegistryStore extends simple_ts_event_dispatcher_1.EventDispatcher {\n    constructor(defaults = null) {\n        super();\n        this.timeouts = {};\n        this.store = defaults || {};\n    }\n    register(key, item) {\n        this.store[key] = item;\n        this.trigger(`registered:${key}`, item);\n    }\n    get(key) {\n        const deferred = simple_ts_promise_1.Promise.defer();\n        if (!!this.store[key]) {\n            deferred.resolve(this.store[key]);\n        }\n        else {\n            console.warn(`Waiting for ${key} to be registered.`);\n            this.timeouts[key] = setTimeout(() => {\n                console.warn(`RegistryStore.get timed out after 5 seconds trying to find ${key}. Make sure the item is registered.`);\n            }, 5000);\n            this.once(`registered:${key}`, (cls) => {\n                clearTimeout(this.timeouts[key]);\n                deferred.resolve(cls);\n            });\n        }\n        return deferred.promise;\n    }\n    getSynchronous(key) {\n        return this.store[key];\n    }\n}\nexports.RegistryStore = RegistryStore;\nclass Registry extends simple_ts_event_dispatcher_1.EventDispatcher {\n    constructor() {\n        super();\n        const w = VisionHelper_1.VisionHelper.window || {};\n        this.classes = new RegistryStore(w['$classes'] || {});\n        this.models = new RegistryStore(w['$models'] || {});\n        this.templates = new RegistryStore(w['$templates'] || {});\n        this.types = new RegistryStore(w['$types'] || {});\n        this.formats = new RegistryStore(w['$formats'] || {});\n        this.attributes = new RegistryStore(w['$attributes'] || {});\n    }\n    static class(key = null, setup = null) {\n        return register('classes', key, setup);\n    }\n    static model(key = null, setup = null) {\n        return register('models', key, setup);\n    }\n    static template(key = null, setup = null) {\n        return register('templates', key, setup);\n    }\n    static type(key = null, setup = null) {\n        return register('types', key, setup);\n    }\n    static format(key = null, setup = null) {\n        return register('formats', key, setup);\n    }\n    static attribute(attributeName = null, setup = null) {\n        return register('attributes', attributeName, setup);\n    }\n    static get instance() {\n        if (!Registry._instance)\n            Registry._instance = new Registry();\n        return Registry._instance;\n    }\n}\nexports.Registry = Registry;\n\n\n//# sourceURL=webpack://vsn/./src/Registry.ts?");

/***/ }),

/***/ "./src/Scope.ts":
/*!**********************!*\
  !*** ./src/Scope.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Scope = exports.WrappedArray = exports.ScopeVariableType = exports.ScopeReference = void 0;\nconst simple_ts_models_1 = __webpack_require__(/*! simple-ts-models */ \"./node_modules/simple-ts-models/dist/index.js\");\nconst simple_ts_event_dispatcher_1 = __webpack_require__(/*! simple-ts-event-dispatcher */ \"./node_modules/simple-ts-event-dispatcher/dist/EventDispatcher.js\");\nconst Registry_1 = __webpack_require__(/*! ./Registry */ \"./src/Registry.ts\");\nclass ScopeReference {\n    constructor(scope, key, value) {\n        this.scope = scope;\n        this.key = key;\n        this.value = value;\n    }\n}\nexports.ScopeReference = ScopeReference;\nclass ScopeVariableType {\n}\nexports.ScopeVariableType = ScopeVariableType;\nScopeVariableType.Integer = 'integer';\nScopeVariableType.Float = 'float';\nScopeVariableType.Boolean = 'boolean';\nScopeVariableType.String = 'string';\nclass WrappedArray extends Array {\n    constructor(...items) {\n        super(...items);\n        this.$wrapped = true;\n        Object.setPrototypeOf(this, WrappedArray.prototype);\n        this._lastKey = 0;\n        this._listeners = {};\n    }\n    push(...items) {\n        const num = super.push(...items);\n        this.trigger('push', ...items);\n        for (const item of items) {\n            this.trigger('add', item);\n        }\n        return num;\n    }\n    splice(start, deleteCount) {\n        const removed = super.splice(start, deleteCount);\n        for (const item of removed) {\n            this.trigger('remove', item);\n        }\n        return removed;\n    }\n    get length() {\n        let c = 0;\n        for (const item of this) {\n            c += 1;\n        }\n        return c;\n    }\n    set length(num) {\n        let c = 0;\n        const toRemove = [];\n        for (const item of this) {\n            c += 1;\n            if (c >= num) {\n                toRemove.push(item);\n            }\n        }\n        for (const item of toRemove) {\n            this.splice(this.indexOf(item), 1);\n            this.trigger('remove', item);\n        }\n    }\n    bind(event, fct, context, once) {\n        once = once || false;\n        this._lastKey++;\n        this._listeners[event] = this._listeners[event] || [];\n        this._listeners[event].push(new simple_ts_event_dispatcher_1.EventCallback(fct, this._lastKey, once, context));\n        return this._lastKey;\n    }\n    once(event, fct, context) {\n        return this.bind(event, fct, context, true);\n    }\n    unbind(event, key) {\n        if (!(event in this._listeners))\n            return false;\n        if (key) {\n            for (const cb of this._listeners[event]) {\n                if (key == cb.key) {\n                    this._listeners[event].splice(this._listeners[event].indexOf(cb), 1);\n                    return true;\n                }\n            }\n        }\n        else {\n            this._listeners[event] = [];\n            return true;\n        }\n        return false;\n    }\n    unbindWithContext(event, context) {\n        if (!(event in this._listeners))\n            return 0;\n        let toRemove = [], cnt = 0;\n        for (const cb of this._listeners[event]) {\n            if (context == cb.context) {\n                toRemove.push(cb);\n            }\n        }\n        for (const cb of toRemove) {\n            this._listeners[event].splice(this._listeners[event].indexOf(cb), 1);\n            cnt++;\n        }\n        return cnt;\n    }\n    getListener(event, key) {\n        for (const cb of this._listeners[event]) {\n            if (key == cb.key)\n                return cb;\n        }\n    }\n    trigger(event, ...args) {\n        if (!(event in this._listeners))\n            return;\n        for (let i = 0; i < this._listeners[event].length; i++) {\n            const cb = this._listeners[event][i];\n            // We need to unbind callbacks before they're called to prevent\n            // infinite loops if the event is somehow triggered within the\n            // callback\n            if (cb.once) {\n                this.unbind(event, cb.key);\n                i--;\n            }\n            cb.call(args);\n        }\n    }\n}\nexports.WrappedArray = WrappedArray;\nclass Scope extends simple_ts_event_dispatcher_1.EventDispatcher {\n    constructor(parent) {\n        super();\n        this.types = {};\n        if (parent)\n            this.parentScope = parent;\n        this.children = [];\n        this.data = new simple_ts_models_1.DataModel({});\n        this.keys = [];\n    }\n    get parentScope() {\n        return this._parentScope;\n    }\n    set parentScope(scope) {\n        this._parentScope = scope;\n        scope.addChild(this);\n    }\n    addChild(scope) {\n        this.children.push(scope);\n    }\n    getReference(path, createIfNotFound = true) {\n        const scopePath = path.split('.');\n        let key = scopePath[0];\n        let scope = this;\n        let val = null;\n        let len = scopePath.length;\n        for (let i = 0; i < len; i++) {\n            key = scopePath[i];\n            val = scope.get(key, i === 0);\n            const isNull = [null, undefined].indexOf(val) > -1;\n            if (createIfNotFound && isNull && i + 1 < len) {\n                val = new Scope(scope);\n                scope.set(key, val);\n            }\n            else if (!createIfNotFound && isNull) {\n                return null;\n            }\n            if (val && val instanceof Scope) {\n                scope = val;\n            }\n        }\n        return new ScopeReference(scope, key, val);\n    }\n    get(key, searchParents = true) {\n        const value = this.data[key];\n        if (value === undefined) {\n            if (searchParents && this.parentScope)\n                return this.parentScope.get(key, searchParents);\n            return '';\n        }\n        return this.data[key];\n    }\n    set(key, value) {\n        if (this.data[key] === undefined)\n            this.data.createField(key);\n        if (typeof value === 'string') {\n            const valueType = this.getType(key);\n            const caster = Registry_1.Registry.instance.types.getSynchronous(valueType);\n            if (caster) {\n                value = caster(value);\n            }\n            if ([ScopeVariableType.Integer, ScopeVariableType.Float].indexOf(valueType) > -1 && isNaN(value)) {\n                value = null;\n            }\n        }\n        if (this.data[key] !== value) {\n            const previousValue = this.data[key];\n            this.data[key] = value;\n            const event = {\n                value: value,\n                previousValue: previousValue,\n                key: key\n            };\n            this.trigger(`change:${key}`, event);\n            this.trigger('change', key, event);\n        }\n        if (this.keys.indexOf(key) === -1)\n            this.keys.push(key);\n    }\n    has(key) {\n        return this.keys.indexOf(key) > -1;\n    }\n    setType(key, type) {\n        this.types[key] = type;\n        if (this.has(key))\n            this.set(key, this.get(key));\n    }\n    getType(key) {\n        return this.types[key] || ScopeVariableType.String;\n    }\n    extend(data) {\n        for (const key of data) {\n            this.set(key, data[key]);\n        }\n    }\n    clear() {\n        for (const key of this.keys) {\n            if (['function', 'object'].indexOf(typeof this.get(key)) > -1)\n                continue;\n            this.set(key, null);\n        }\n    }\n    cleanup() {\n        this.children.length = 0;\n        this.parentScope = null;\n    }\n    setData(obj) {\n        for (const d in obj) {\n            this.set(d, obj[d]);\n        }\n    }\n    wrap(toWrap, triggerUpdates = false, updateFromWrapped = true) {\n        if (toWrap instanceof Scope)\n            toWrap = toWrap.data;\n        if ([null, undefined].indexOf(this.wrapped) === -1)\n            throw Error(\"A scope can only wrap a single object\");\n        if (!toWrap) {\n            throw Error(\"Can only wrap objects.\");\n        }\n        if (toWrap['$wrapped']) {\n            throw Error(\"An object should only be wrapped once.\");\n        }\n        this.wrapped = toWrap;\n        this.wrapped['$wrapped'] = true;\n        for (const field in toWrap) {\n            if (['constructor'].indexOf(field) > -1 || field.startsWith('$'))\n                continue;\n            if (this.wrapped[field] instanceof Function) {\n                this.set(field, this.wrapped[field]);\n                continue;\n            }\n            if (this.wrapped[field] instanceof Array && !(this.wrapped[field] instanceof WrappedArray)) {\n                this.wrapped[field] = new WrappedArray(...toWrap[field]);\n            }\n            // Populate scope data from wrapped object before we update the getter\n            if (updateFromWrapped && [null, undefined].indexOf(this.wrapped[field]) === -1) {\n                this.set(field, this.wrapped[field]);\n            }\n            const getter = () => {\n                return this.get(field);\n            };\n            const setter = (value) => {\n                this.set(field, value);\n            };\n            Object.defineProperty(this.wrapped, field, {\n                get: getter,\n                set: setter,\n                enumerable: true,\n                configurable: true\n            });\n            if (triggerUpdates)\n                this.trigger(`change:${field}`);\n        }\n        this.wrapped.get = this.get.bind(this);\n        this.wrapped.set = this.set.bind(this);\n        this.wrapped.bind = this.bind.bind(this);\n        this.wrapped.once = this.once.bind(this);\n        this.wrapped.unbind = this.unbind.bind(this);\n    }\n    unwrap() {\n        if (!this.wrapped)\n            return;\n        const toUnwrap = this.wrapped;\n        this.wrapped = null;\n        toUnwrap.$wrapped = false;\n        for (const field in toUnwrap) {\n            delete toUnwrap[field];\n        }\n    }\n}\nexports.Scope = Scope;\n\n\n//# sourceURL=webpack://vsn/./src/Scope.ts?");

/***/ }),

/***/ "./src/Tag.ts":
/*!********************!*\
  !*** ./src/Tag.ts ***!
  \********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Tag = exports.TagState = void 0;\nconst Scope_1 = __webpack_require__(/*! ./Scope */ \"./src/Scope.ts\");\nconst simple_ts_event_dispatcher_1 = __webpack_require__(/*! simple-ts-event-dispatcher */ \"./node_modules/simple-ts-event-dispatcher/dist/EventDispatcher.js\");\nconst VisionHelper_1 = __webpack_require__(/*! ./helpers/VisionHelper */ \"./src/helpers/VisionHelper.ts\");\nconst StandardAttribute_1 = __webpack_require__(/*! ./attributes/StandardAttribute */ \"./src/attributes/StandardAttribute.ts\");\nconst On_1 = __webpack_require__(/*! ./attributes/On */ \"./src/attributes/On.ts\");\nconst Registry_1 = __webpack_require__(/*! ./Registry */ \"./src/Registry.ts\");\nvar TagState;\n(function (TagState) {\n    TagState[TagState[\"Instantiated\"] = 0] = \"Instantiated\";\n    TagState[TagState[\"AttributesBuilt\"] = 1] = \"AttributesBuilt\";\n    TagState[TagState[\"AttributesCompiled\"] = 2] = \"AttributesCompiled\";\n    TagState[TagState[\"AttributesSetup\"] = 3] = \"AttributesSetup\";\n    TagState[TagState[\"AttributesExtracted\"] = 4] = \"AttributesExtracted\";\n    TagState[TagState[\"AttributesConnected\"] = 5] = \"AttributesConnected\";\n    TagState[TagState[\"Built\"] = 6] = \"Built\";\n})(TagState = exports.TagState || (exports.TagState = {}));\nclass Tag extends simple_ts_event_dispatcher_1.EventDispatcher {\n    constructor(element, dom) {\n        super();\n        this.element = element;\n        this.dom = dom;\n        this._children = [];\n        this.inputTags = [\n            'input',\n            'select',\n            'textarea'\n        ];\n        this._uniqueScope = false;\n        this.rawAttributes = {};\n        this.parsedAttributes = {};\n        this.attributes = [];\n        this.onEventHandlers = {};\n        this.analyzeElementAttributes();\n        this._state = TagState.Instantiated;\n    }\n    get uniqueScope() {\n        return this._uniqueScope;\n    }\n    ;\n    get style() {\n        return this.element.style;\n    }\n    get computedStyle() {\n        return VisionHelper_1.VisionHelper.window && window.getComputedStyle(this.element) || null;\n    }\n    analyzeElementAttributes() {\n        if (!this.element.attributes || this.element.attributes.length <= 0)\n            return;\n        for (let i = 0; i < this.element.attributes.length; i++) {\n            const a = this.element.attributes[i];\n            this.rawAttributes[a.name] = a.value;\n            if (a.name.indexOf(':') > -1) {\n                const nameParts = a.name.split(':');\n                const values = nameParts.slice(1);\n                values.push(a.value);\n                this.parsedAttributes[nameParts[0]] = values;\n            }\n            else {\n                this.parsedAttributes[a.name] = [null, a.value];\n            }\n        }\n    }\n    evaluate() {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const attr of this.attributes) {\n                yield attr.evaluate();\n            }\n        });\n    }\n    mutate(mutation) {\n        for (const attr of this.attributes) {\n            attr.mutate(mutation);\n        }\n        this.trigger('mutate', mutation);\n    }\n    get(attr) {\n        this.element.getAttribute(attr);\n    }\n    set(attr, value) {\n        this.element.setAttribute(attr, value);\n    }\n    getAttributeClass(attr) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!attr.startsWith('vsn-'))\n                return null;\n            attr = this.getAttributeName(attr);\n            return Registry_1.Registry.instance.attributes.get(attr);\n        });\n    }\n    getAttributeName(attr) {\n        attr = attr.split('|')[0];\n        if (attr.indexOf(':') > -1) {\n            const parts = attr.split(':');\n            attr = parts[0];\n        }\n        return attr;\n    }\n    getAttributeBinding(attr) {\n        attr = attr.split('|')[0];\n        if (attr.indexOf(':') > -1) {\n            const parts = attr.split(':');\n            return parts[1];\n        }\n        return null;\n    }\n    getAttributeModifiers(attr) {\n        return attr.split('|').splice(1);\n    }\n    get isInput() {\n        return this.inputTags.indexOf(this.element.tagName.toLowerCase()) > -1;\n    }\n    set value(value) {\n        if (this.isInput) {\n            this.element.setAttribute('value', value);\n            this.element.value = value;\n        }\n        else {\n            this.element.innerText = value;\n        }\n    }\n    get value() {\n        if (this.isInput) {\n            return this.element.value;\n        }\n        else {\n            return this.element.textContent;\n        }\n    }\n    addChild(tag) {\n        this._children.push(tag);\n    }\n    get children() {\n        return [...this._children];\n    }\n    get parentTag() {\n        return this._parentTag;\n    }\n    set parentTag(tag) {\n        if (this.element === document.body)\n            return;\n        this._parentTag = tag;\n        tag.addChild(this);\n        if (this.scope !== tag.scope)\n            this.scope.parentScope = tag.scope;\n    }\n    get scope() {\n        if (!!this._scope)\n            return this._scope;\n        if (!!this._parentTag)\n            return this._parentTag.scope;\n        return null;\n    }\n    set scope(scope) {\n        this._scope = scope;\n    }\n    get controller() {\n        return this._controller;\n    }\n    set controller(controller) {\n        this._controller = controller;\n    }\n    wrap(obj, triggerUpdates = false, updateFromWrapped = true) {\n        if (VisionHelper_1.VisionHelper.isConstructor(obj)) {\n            obj = new obj();\n        }\n        this.scope.wrap(obj, triggerUpdates, updateFromWrapped);\n        obj['$scope'] = this.scope;\n        obj['$tag'] = this;\n        obj['$el'] = this.element;\n        return obj;\n    }\n    unwrap() {\n        this.scope.unwrap();\n    }\n    removeFromDOM() {\n        this.element.remove();\n    }\n    addToParentElement() {\n        this._parentTag.element.appendChild(this.element);\n    }\n    hide() {\n        this.element.hidden = true;\n    }\n    show() {\n        this.element.hidden = false;\n    }\n    findAncestorByAttribute(attr) {\n        if (this.hasAttribute(attr))\n            return this;\n        return this.parentTag ? this.parentTag.findAncestorByAttribute(attr) : null;\n    }\n    hasAttribute(attr) {\n        return !!this.parsedAttributes[attr];\n    }\n    getAttribute(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cls = yield Registry_1.Registry.instance.attributes.get(key);\n            if (!cls)\n                return;\n            for (const attr of this.attributes)\n                if (attr instanceof cls)\n                    return attr;\n        });\n    }\n    getRawAttributeValue(key, fallback = null) {\n        return this.rawAttributes[key] && this.rawAttributes[key] || fallback;\n    }\n    getParsedAttributeValue(key, index = 0, fallback = null) {\n        return this.parsedAttributes[key] && this.parsedAttributes[key][index] || fallback;\n    }\n    buildAttributes() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let requiresScope = false;\n            this.attributes.length = 0;\n            const isMobile = VisionHelper_1.VisionHelper.isMobile();\n            for (let attr in this.rawAttributes) {\n                if (this.hasModifier(attr, 'mobile')) {\n                    if (!isMobile) {\n                        continue;\n                    }\n                }\n                if (this.hasModifier(attr, 'desktop')) {\n                    if (isMobile) {\n                        continue;\n                    }\n                }\n                const attrClass = yield this.getAttributeClass(attr);\n                if (attrClass) {\n                    if (attrClass.scoped)\n                        requiresScope = true;\n                    const attrObj = new attrClass(this, attr);\n                    this.attributes.push(attrObj);\n                }\n            }\n            if (this.element.getAttribute('id'))\n                requiresScope = true;\n            if (requiresScope && !this.uniqueScope) {\n                this._uniqueScope = true;\n                this._scope = new Scope_1.Scope();\n            }\n            this._state = TagState.AttributesBuilt;\n        });\n    }\n    compileAttributes() {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const attr of this.attributes) {\n                yield attr.compile();\n            }\n            this._state = TagState.AttributesCompiled;\n        });\n    }\n    setupAttributes() {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const attr of this.attributes) {\n                yield attr.setup();\n            }\n            this.dom.registerElementInRoot(this);\n            this._state = TagState.AttributesSetup;\n            this.callOnWrapped('$setup');\n        });\n    }\n    extractAttributes() {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const attr of this.attributes) {\n                yield attr.extract();\n            }\n            this._state = TagState.AttributesExtracted;\n            this.callOnWrapped('$extracted');\n        });\n    }\n    connectAttributes() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.isInput) {\n                this.addEventHandler('input', [], this.inputMutation.bind(this));\n            }\n            for (const attr of this.attributes) {\n                yield attr.connect();\n            }\n            this._state = TagState.AttributesConnected;\n            this.callOnWrapped('$bound');\n        });\n    }\n    inputMutation(e) {\n        this.element.setAttribute('value', e.target.value);\n    }\n    finalize() {\n        this._state = TagState.Built;\n        this.callOnWrapped('$built', this, this.scope, this.element);\n    }\n    callOnWrapped(method, ...args) {\n        if (this._uniqueScope && this.scope && this.scope.wrapped && this.scope.wrapped[method]) {\n            this.scope.wrapped[method](...args);\n            return true;\n        }\n        return false;\n    }\n    handleEvent(eventType, e) {\n        if (e)\n            e.stopPropagation();\n        if (!this.onEventHandlers[eventType])\n            return;\n        this.scope.set('$event', e);\n        this.scope.set('$value', this.value);\n        for (const handler of this.onEventHandlers[eventType]) {\n            handler(e);\n        }\n    }\n    hasModifier(attribute, modifier) {\n        return attribute.indexOf(`|${modifier}`) > -1;\n    }\n    stripModifier(attribute, modifier) {\n        return attribute.replace(`|${modifier}`, '');\n    }\n    addEventHandler(eventType, modifiers, handler) {\n        let passiveValue = null;\n        if (modifiers.indexOf('active') > -1) {\n            passiveValue = false;\n        }\n        else if (modifiers.indexOf('passive') > -1) {\n            passiveValue = true;\n        }\n        if (!this.onEventHandlers[eventType]) {\n            this.onEventHandlers[eventType] = [];\n            const element = On_1.On.WindowEvents.indexOf(eventType) > -1 && window ? window : this.element;\n            const opts = {};\n            if (eventType.indexOf('touch') > -1 || passiveValue !== null)\n                opts['passive'] = passiveValue === null && true || passiveValue;\n            element.addEventListener(eventType, this.handleEvent.bind(this, eventType), opts);\n        }\n        this.onEventHandlers[eventType].push(handler);\n    }\n    watchAttribute(attributeName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const attribute of this.attributes) {\n                if (attribute instanceof StandardAttribute_1.StandardAttribute && attribute.attributeName == attributeName) {\n                    return attribute;\n                }\n            }\n            // Standard attribute requires a unique scope\n            // @todo: Does this cause any issues with attribute bindings on the parent scope prior to having its own scope? hmm...\n            if (!this.uniqueScope) {\n                this._uniqueScope = true;\n                this._scope = new Scope_1.Scope();\n                if (this.parentTag) {\n                    this.scope.parentScope = this.parentTag.scope;\n                }\n            }\n            const standardAttribute = new StandardAttribute_1.StandardAttribute(this, attributeName);\n            this.attributes.push(standardAttribute);\n            yield standardAttribute.compile();\n            yield standardAttribute.setup();\n            yield standardAttribute.extract();\n            yield standardAttribute.connect();\n            return standardAttribute;\n        });\n    }\n}\nexports.Tag = Tag;\n\n\n//# sourceURL=webpack://vsn/./src/Tag.ts?");

/***/ }),

/***/ "./src/Tag/List.ts":
/*!*************************!*\
  !*** ./src/Tag/List.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TagList = void 0;\nconst VisionHelper_1 = __webpack_require__(/*! ../helpers/VisionHelper */ \"./src/helpers/VisionHelper.ts\");\nclass TagList extends Array {\n}\nexports.TagList = TagList;\nif (VisionHelper_1.VisionHelper.inDevelopment && VisionHelper_1.VisionHelper.window)\n    window['TagList'] = TagList;\n\n\n//# sourceURL=webpack://vsn/./src/Tag/List.ts?");

/***/ }),

/***/ "./src/Types.ts":
/*!**********************!*\
  !*** ./src/Types.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Types = void 0;\nconst Registry_1 = __webpack_require__(/*! ./Registry */ \"./src/Registry.ts\");\nclass Types {\n    static string(value) {\n        return value;\n    }\n    static integer(value) {\n        return parseInt(value);\n    }\n    static float(value) {\n        value = `${value}`.replace(/[^0-9.]+/, '');\n        return parseFloat(value);\n    }\n    static boolean(value) {\n        return [0, '0', 'false', ''].indexOf(value) === -1;\n    }\n    static date(value) {\n        return new Date(Date.parse(value));\n    }\n}\n__decorate([\n    Registry_1.Registry.type('string')\n], Types, \"string\", null);\n__decorate([\n    Registry_1.Registry.type('integer')\n], Types, \"integer\", null);\n__decorate([\n    Registry_1.Registry.type('float')\n], Types, \"float\", null);\n__decorate([\n    Registry_1.Registry.type('boolean')\n], Types, \"boolean\", null);\n__decorate([\n    Registry_1.Registry.type('date')\n], Types, \"date\", null);\nexports.Types = Types;\n\n\n//# sourceURL=webpack://vsn/./src/Types.ts?");

/***/ }),

/***/ "./src/Vision.ts":
/*!***********************!*\
  !*** ./src/Vision.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.vision = exports.Vision = void 0;\nconst DOM_1 = __webpack_require__(/*! ./DOM */ \"./src/DOM.ts\");\nconst simple_ts_event_dispatcher_1 = __webpack_require__(/*! simple-ts-event-dispatcher */ \"./node_modules/simple-ts-event-dispatcher/dist/EventDispatcher.js\");\nconst Scope_1 = __webpack_require__(/*! ./Scope */ \"./src/Scope.ts\");\nconst simple_ts_models_1 = __webpack_require__(/*! simple-ts-models */ \"./node_modules/simple-ts-models/dist/index.js\");\nconst Registry_1 = __webpack_require__(/*! ./Registry */ \"./src/Registry.ts\");\n__webpack_require__(/*! ./Types */ \"./src/Types.ts\");\n__webpack_require__(/*! ./Formats */ \"./src/Formats.ts\");\n__webpack_require__(/*! ./attributes/_imports */ \"./src/attributes/_imports.ts\");\nconst Configuration_1 = __webpack_require__(/*! ./Configuration */ \"./src/Configuration.ts\");\nconst VisionHelper_1 = __webpack_require__(/*! ./helpers/VisionHelper */ \"./src/helpers/VisionHelper.ts\");\nconst AST_1 = __webpack_require__(/*! ./AST */ \"./src/AST.ts\");\nconst Query_1 = __webpack_require__(/*! ./Query */ \"./src/Query.ts\");\nclass Vision extends simple_ts_event_dispatcher_1.EventDispatcher {\n    constructor() {\n        super();\n        this.registry = Registry_1.Registry.instance;\n        this.config = Configuration_1.Configuration.instance;\n        if (VisionHelper_1.VisionHelper.document) {\n            document.addEventListener(\"DOMContentLoaded\", this.setup.bind(this));\n        }\n        else {\n            console.warn('No dom, running in CLI mode.');\n        }\n        this.registry.classes.register('Object', Object);\n        this.registry.classes.register('WrappedArray', Scope_1.WrappedArray);\n        this.registry.classes.register('DataModel', simple_ts_models_1.DataModel);\n    }\n    get dom() {\n        return this._dom;\n    }\n    eval(code) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this._dom.eval(code);\n        });\n    }\n    setup() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const body = document.body;\n            body.setAttribute('vsn-root', '');\n            this._dom = DOM_1.DOM.instance;\n            const startTime = new Date().getTime();\n            yield this._dom.buildFrom(document, true);\n            console.warn(`Took ${new Date().getTime() - startTime}ms to start up VisionJS`);\n        });\n    }\n    static get instance() {\n        if (!Vision._instance)\n            Vision._instance = new Vision();\n        return Vision._instance;\n    }\n}\nexports.Vision = Vision;\nexports.vision = Vision.instance;\nif (VisionHelper_1.VisionHelper.window) {\n    window['Vision'] = Vision;\n    window['vision'] = window['vsn'] = exports.vision;\n    window['Tree'] = AST_1.Tree;\n    window['$'] = Query_1.Query;\n}\n\n\n//# sourceURL=webpack://vsn/./src/Vision.ts?");

/***/ }),

/***/ "./src/attributes/AddClassIf.ts":
/*!**************************************!*\
  !*** ./src/attributes/AddClassIf.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AddClassIf = void 0;\nconst If_1 = __webpack_require__(/*! ./If */ \"./src/attributes/If.ts\");\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nlet AddClassIf = class AddClassIf extends If_1.If {\n    onChange() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield this.tree.evaluate(this.tag.scope, this.tag.dom);\n            if (result) {\n                this.tag.element.classList.add(this.getAttributeBinding());\n            }\n            else {\n                this.tag.element.classList.remove(this.getAttributeBinding());\n            }\n        });\n    }\n};\nAddClassIf = __decorate([\n    Registry_1.Registry.attribute('vsn-add-class-if')\n], AddClassIf);\nexports.AddClassIf = AddClassIf;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/AddClassIf.ts?");

/***/ }),

/***/ "./src/attributes/Bind.ts":
/*!********************************!*\
  !*** ./src/attributes/Bind.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Bind = void 0;\nconst Attribute_1 = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\nconst AST_1 = __webpack_require__(/*! ../AST */ \"./src/AST.ts\");\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nlet Bind = class Bind extends Attribute_1.Attribute {\n    constructor() {\n        super(...arguments);\n        this.direction = 'both';\n        this.formatter = (v) => v;\n    }\n    compile() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tree = new AST_1.Tree(this.getAttributeValue());\n            yield tree.prepare(this.tag.scope, this.tag.dom);\n        });\n    }\n    setup() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.property = this.getAttributeBinding();\n            const mods = this.getAttributeModifiers();\n            if (mods.length) {\n                if (mods.indexOf('from') > -1) {\n                    this.direction = 'from';\n                }\n                else if (mods.indexOf('to') > -1) {\n                    this.direction = 'to';\n                }\n            }\n        });\n    }\n    extract() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let scopeKey = this.getAttributeValue();\n            let ref;\n            try {\n                ref = this.tag.scope.getReference(scopeKey);\n            }\n            catch (e) {\n                console.error('error', e);\n                return;\n            }\n            this.key = ref.key;\n            this.boundScope = ref.scope;\n            if (!!this.valueFromElement)\n                this.updateFrom();\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.doUpdateTo) {\n                this.updateTo();\n                this.boundScope.bind(`change:${this.key}`, this.updateTo, this);\n            }\n        });\n    }\n    evaluate() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const elementValue = this.valueFromElement;\n            if (!!elementValue)\n                this.updateFrom();\n            this.updateTo();\n        });\n    }\n    set value(v) {\n        if (this.boundScope) {\n            this.boundScope.set(this.key, v);\n        }\n    }\n    get value() {\n        if (!this.boundScope)\n            return null;\n        return this.boundScope.get(this.key, false);\n    }\n    get valueFromElement() {\n        let value;\n        if (this.property) {\n            value = this.tag.element.getAttribute(this.property);\n        }\n        else {\n            value = this.tag.value;\n        }\n        return value;\n    }\n    mutate(mutation) {\n        super.mutate(mutation);\n        if (!this.doUpdateFrom)\n            return;\n        // Element innerText binding\n        if (!this.property && [\n            'characterData',\n            'childList'\n        ].indexOf(mutation.type) > -1)\n            this.updateFrom();\n        // Input value binding\n        else if (!this.property && mutation.type == 'attributes' && mutation.attributeName === 'value')\n            this.updateFrom();\n        // Attribute binding\n        else if (mutation.type === 'attributes' && mutation.attributeName == this.property)\n            this.updateFrom();\n    }\n    get doUpdateFrom() {\n        return ['both', 'to'].indexOf(this.direction) > -1;\n    }\n    updateFrom() {\n        if (!this.doUpdateFrom)\n            return;\n        let valueFromElement = this.valueFromElement;\n        valueFromElement = typeof valueFromElement === 'string' && valueFromElement.trim() || valueFromElement;\n        let valueFromScope = this.value;\n        valueFromScope = typeof valueFromScope === 'string' && valueFromScope.trim() || valueFromScope;\n        valueFromScope = this.formatter(valueFromScope); // Apply format for comparison\n        if (!valueFromScope || valueFromElement != valueFromScope)\n            this.value = valueFromElement;\n    }\n    get doUpdateTo() {\n        return ['both', 'from'].indexOf(this.direction) > -1;\n    }\n    updateTo() {\n        if (!this.doUpdateTo)\n            return;\n        const value = this.formatter(this.value);\n        if (this.property) {\n            this.tag.element.setAttribute(this.property, value);\n        }\n        else {\n            this.tag.value = value;\n        }\n    }\n    setFormatter(formatter) {\n        this.formatter = formatter;\n    }\n};\nBind = __decorate([\n    Registry_1.Registry.attribute('vsn-bind')\n], Bind);\nexports.Bind = Bind;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/Bind.ts?");

/***/ }),

/***/ "./src/attributes/ClassConstructor.ts":
/*!********************************************!*\
  !*** ./src/attributes/ClassConstructor.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ClassConstructor = void 0;\nconst Attribute_1 = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nlet ClassConstructor = class ClassConstructor extends Attribute_1.Attribute {\n    setup() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const parentScope = this.tag.parentTag.scope;\n            if (!parentScope)\n                return;\n            this.attributeKey = this.getAttributeBinding();\n            this.className = this.getAttributeValue();\n            const cls = yield Registry_1.Registry.instance.classes.get(this.className);\n            this.instantiateClass(cls);\n            if (this.attributeKey && parentScope)\n                parentScope.set(this.attributeKey, this.tag.scope);\n        });\n    }\n    instantiateClass(cls) {\n        this.tag.wrap(cls);\n    }\n};\nClassConstructor.scoped = true;\nClassConstructor = __decorate([\n    Registry_1.Registry.attribute('vsn-controller')\n], ClassConstructor);\nexports.ClassConstructor = ClassConstructor;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/ClassConstructor.ts?");

/***/ }),

/***/ "./src/attributes/ClickRemoveClass.ts":
/*!********************************************!*\
  !*** ./src/attributes/ClickRemoveClass.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ClickRemoveClass = void 0;\nconst Attribute_1 = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nlet ClickRemoveClass = class ClickRemoveClass extends Attribute_1.Attribute {\n    constructor() {\n        super(...arguments);\n        this.cssClass = '';\n        this.target = null;\n    }\n    setup() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.cssClass = this.getAttributeBinding('active');\n            this.target = this.getAttributeValue();\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.tag.addEventHandler('click', this.getAttributeModifiers(), this.onClick.bind(this));\n        });\n    }\n    onClick(e) {\n        let element = this.tag.element;\n        if (!!this.target) {\n            element = document.getElementById(this.target);\n        }\n        if (element)\n            element.classList.remove(this.cssClass);\n    }\n};\nClickRemoveClass = __decorate([\n    Registry_1.Registry.attribute('vsn-click-remove-class')\n], ClickRemoveClass);\nexports.ClickRemoveClass = ClickRemoveClass;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/ClickRemoveClass.ts?");

/***/ }),

/***/ "./src/attributes/ClickToggleClass.ts":
/*!********************************************!*\
  !*** ./src/attributes/ClickToggleClass.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ClickToggleClass = void 0;\nconst Attribute_1 = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nlet ClickToggleClass = class ClickToggleClass extends Attribute_1.Attribute {\n    constructor() {\n        super(...arguments);\n        this.cssClass = '';\n        this.target = null;\n    }\n    setup() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.cssClass = this.getAttributeBinding('active');\n            this.target = this.getAttributeValue();\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.tag.addEventHandler('click', this.getAttributeModifiers(), this.onClick.bind(this));\n        });\n    }\n    onClick(e) {\n        let element = this.tag.element;\n        if (!!this.target) {\n            element = document.getElementById(this.target);\n        }\n        if (element)\n            element.classList.toggle(this.cssClass);\n    }\n};\nClickToggleClass = __decorate([\n    Registry_1.Registry.attribute('vsn-click-toggle-class')\n], ClickToggleClass);\nexports.ClickToggleClass = ClickToggleClass;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/ClickToggleClass.ts?");

/***/ }),

/***/ "./src/attributes/ControllerAttribute.ts":
/*!***********************************************!*\
  !*** ./src/attributes/ControllerAttribute.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ControllerAttribute = void 0;\nconst ClassConstructor_1 = __webpack_require__(/*! ./ClassConstructor */ \"./src/attributes/ClassConstructor.ts\");\nclass ControllerAttribute extends ClassConstructor_1.ClassConstructor {\n}\nexports.ControllerAttribute = ControllerAttribute;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/ControllerAttribute.ts?");

/***/ }),

/***/ "./src/attributes/DisableIf.ts":
/*!*************************************!*\
  !*** ./src/attributes/DisableIf.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DisableIf = void 0;\nconst If_1 = __webpack_require__(/*! ./If */ \"./src/attributes/If.ts\");\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nlet DisableIf = class DisableIf extends If_1.If {\n    onChange() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield this.tree.evaluate(this.tag.scope, this.tag.dom);\n            if (result) {\n                this.tag.element.setAttribute('disabled', 'disabled');\n            }\n            else {\n                this.tag.element.removeAttribute('disabled');\n            }\n        });\n    }\n};\nDisableIf = __decorate([\n    Registry_1.Registry.attribute('vsn-disable-if')\n], DisableIf);\nexports.DisableIf = DisableIf;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/DisableIf.ts?");

/***/ }),

/***/ "./src/attributes/Exec.ts":
/*!********************************!*\
  !*** ./src/attributes/Exec.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Exec = void 0;\nconst Attribute_1 = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\nconst AST_1 = __webpack_require__(/*! ../AST */ \"./src/AST.ts\");\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nlet Exec = class Exec extends Attribute_1.Attribute {\n    compile() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.tree = new AST_1.Tree(this.getAttributeValue());\n            yield this.tree.prepare(this.tag.scope, this.tag.dom);\n        });\n    }\n    extract() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.tree.evaluate(this.tag.scope, this.tag.dom);\n        });\n    }\n};\nExec = __decorate([\n    Registry_1.Registry.attribute('vsn-exec')\n], Exec);\nexports.Exec = Exec;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/Exec.ts?");

/***/ }),

/***/ "./src/attributes/Format.ts":
/*!**********************************!*\
  !*** ./src/attributes/Format.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Format = void 0;\nconst Attribute_1 = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nlet Format = class Format extends Attribute_1.Attribute {\n    extract() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const value = this.getAttributeValue(null);\n            const attribute = this.getAttributeBinding(null);\n            const formatter = yield Registry_1.Registry.instance.formats.get(value);\n            const bindingKey = attribute ? `vsn-bind:${attribute}` : 'vsn-bind';\n            const binding = yield this.tag.getAttribute(bindingKey);\n            binding.setFormatter(formatter);\n        });\n    }\n};\nFormat = __decorate([\n    Registry_1.Registry.attribute('vsn-format')\n], Format);\nexports.Format = Format;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/Format.ts?");

/***/ }),

/***/ "./src/attributes/If.ts":
/*!******************************!*\
  !*** ./src/attributes/If.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.If = void 0;\nconst Attribute_1 = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\nconst AST_1 = __webpack_require__(/*! ../AST */ \"./src/AST.ts\");\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nlet If = class If extends Attribute_1.Attribute {\n    compile() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const statement = this.getAttributeValue();\n            this.tree = new AST_1.Tree(statement);\n            yield this.tree.prepare(this.tag.scope, this.tag.dom);\n        });\n    }\n    extract() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.evaluate();\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.tree.bindToScopeChanges(this.tag.scope, this.onChange.bind(this));\n        });\n    }\n    evaluate() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.onChange();\n        });\n    }\n    onChange() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield this.tree.evaluate(this.tag.scope, this.tag.dom);\n            if (result) {\n                this.tag.show();\n            }\n            else {\n                this.tag.hide();\n            }\n        });\n    }\n};\nIf = __decorate([\n    Registry_1.Registry.attribute('vsn-if')\n], If);\nexports.If = If;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/If.ts?");

/***/ }),

/***/ "./src/attributes/KeyAbstract.ts":
/*!***************************************!*\
  !*** ./src/attributes/KeyAbstract.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KeyAbstract = void 0;\nconst On_1 = __webpack_require__(/*! ./On */ \"./src/attributes/On.ts\");\nclass KeyAbstract extends On_1.On {\n    constructor() {\n        super(...arguments);\n        this.specificKey = null;\n    }\n    compile() {\n        const _super = Object.create(null, {\n            compile: { get: () => super.compile }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.compile.call(this);\n            this.specificKey = this.getAttributeBinding();\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.tag.addEventHandler('keydown', this.getAttributeModifiers(), this.handleEvent.bind(this));\n        });\n    }\n    handleEvent(e) {\n        const _super = Object.create(null, {\n            handleEvent: { get: () => super.handleEvent }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            let triggerEvent = false;\n            if ([undefined, null, ''].indexOf(this.specificKey) === -1) {\n                if (e.key.toLowerCase() === this.specificKey || e.code.toLowerCase() === this.specificKey)\n                    triggerEvent = true;\n            }\n            else\n                triggerEvent = true;\n            if (triggerEvent)\n                yield _super.handleEvent.call(this, e);\n        });\n    }\n}\nexports.KeyAbstract = KeyAbstract;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/KeyAbstract.ts?");

/***/ }),

/***/ "./src/attributes/KeyDown.ts":
/*!***********************************!*\
  !*** ./src/attributes/KeyDown.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KeyDown = void 0;\nconst KeyAbstract_1 = __webpack_require__(/*! ./KeyAbstract */ \"./src/attributes/KeyAbstract.ts\");\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nlet KeyDown = class KeyDown extends KeyAbstract_1.KeyAbstract {\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.tag.addEventHandler('keydown', this.getAttributeModifiers(), this.handleEvent.bind(this));\n        });\n    }\n};\nKeyDown = __decorate([\n    Registry_1.Registry.attribute('vsn-key-down')\n], KeyDown);\nexports.KeyDown = KeyDown;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/KeyDown.ts?");

/***/ }),

/***/ "./src/attributes/KeyUp.ts":
/*!*********************************!*\
  !*** ./src/attributes/KeyUp.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KeyUp = void 0;\nconst KeyAbstract_1 = __webpack_require__(/*! ./KeyAbstract */ \"./src/attributes/KeyAbstract.ts\");\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nlet KeyUp = class KeyUp extends KeyAbstract_1.KeyAbstract {\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.tag.addEventHandler('keyup', this.getAttributeModifiers(), this.handleEvent.bind(this));\n        });\n    }\n};\nKeyUp = __decorate([\n    Registry_1.Registry.attribute('vsn-key-up')\n], KeyUp);\nexports.KeyUp = KeyUp;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/KeyUp.ts?");

/***/ }),

/***/ "./src/attributes/List.ts":
/*!********************************!*\
  !*** ./src/attributes/List.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.List = void 0;\nconst Attribute_1 = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\nconst Scope_1 = __webpack_require__(/*! ../Scope */ \"./src/Scope.ts\");\nconst AST_1 = __webpack_require__(/*! ../AST */ \"./src/AST.ts\");\nconst ElementHelper_1 = __webpack_require__(/*! ../helpers/ElementHelper */ \"./src/helpers/ElementHelper.ts\");\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nlet List = class List extends Attribute_1.Attribute {\n    compile() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const listAttr = this.getAttributeBinding();\n            this.tree = new AST_1.Tree(listAttr);\n            yield this.tree.prepare(this.tag.scope, this.tag.dom);\n        });\n    }\n    setup() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.tag.element.children.length > 0) {\n                const template = this.tag.element.children[0];\n                if (template.hasAttribute('vsn-template')) {\n                    template.removeAttribute('vsn-template');\n                    this.tag.element.removeChild(template);\n                    this.template = template;\n                }\n                else {\n                    this.template = template.cloneNode(true);\n                }\n            }\n        });\n    }\n    extract() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const items = yield this.tree.evaluate(this.tag.scope, this.tag.dom);\n            yield this.addExistingItems(items);\n        });\n    }\n    addExistingItems(defaultList) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.items = defaultList || new Scope_1.WrappedArray();\n            this.tags = [];\n            if (defaultList)\n                for (const existingItem of defaultList) {\n                    yield this.add(existingItem);\n                }\n            for (const element of Array.from(this.tag.element.querySelectorAll('*'))) {\n                if (!ElementHelper_1.ElementHelper.hasVisionAttribute(element, 'vsn-list-item'))\n                    continue;\n                const tag = yield this.tag.dom.getTagForElement(element);\n                if (tag) {\n                    this.tags.push(tag);\n                    this.items.push(tag.scope.wrapped || tag.scope);\n                }\n            }\n            if (!(this.items instanceof Scope_1.WrappedArray)) {\n                this.items = new Scope_1.WrappedArray(this.items);\n            }\n            this.items.bind('add', (item) => {\n                this.add(item);\n            });\n            this.items.bind('remove', (item) => {\n                this.remove(item);\n            });\n            this.tag.scope.set('add', this.add.bind(this));\n            this.tag.scope.set('remove', this.remove.bind(this));\n        });\n    }\n    get listItemName() {\n        return this.tag.getRawAttributeValue('vsn-list-item-name', 'item');\n    }\n    get listItemModel() {\n        return this.tag.getRawAttributeValue('vsn-list-item-model', 'Object');\n    }\n    remove(item) {\n        for (let i = 0; i < this.tags.length; i++) {\n            const tag = this.tags[i];\n            const listItem = tag.scope.get(this.listItemName);\n            if ([listItem, listItem.wrapped].indexOf(item) > -1) {\n                tag.removeFromDOM();\n                this.tags.splice(i, 1);\n                return;\n            }\n        }\n    }\n    add(obj) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const element = this.template.cloneNode(true);\n            this.tag.element.appendChild(element);\n            yield this.tag.dom.buildFrom(this.tag.element);\n            const tag = yield this.tag.dom.getTagForElement(element);\n            this.tags.push(tag);\n            tag.scope.clear();\n            if (obj) {\n                tag.unwrap();\n                tag.wrap(obj);\n            }\n            this.tag.trigger('add', obj);\n        });\n    }\n};\nList.scoped = true;\nList = __decorate([\n    Registry_1.Registry.attribute('vsn-list')\n], List);\nexports.List = List;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/List.ts?");

/***/ }),

/***/ "./src/attributes/ListItem.ts":
/*!************************************!*\
  !*** ./src/attributes/ListItem.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar ListItem_1;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ListItem = void 0;\nconst Attribute_1 = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nlet ListItem = ListItem_1 = class ListItem extends Attribute_1.Attribute {\n    get list() {\n        return this._list;\n    }\n    setup() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._list = this.tag.findAncestorByAttribute('vsn-list');\n            if (!this._list)\n                throw Error(ListItem_1.ERROR_NO_PARENT);\n            this.tag.scope.set(this.listItemName, this.tag.scope);\n            const modelName = (yield this.getList()).listItemModel;\n            const cls = yield Registry_1.Registry.instance.classes.get(modelName);\n            this.instantiateModel(cls);\n        });\n    }\n    get listItemName() {\n        return this.getAttributeBinding('item');\n    }\n    getList() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this._list.getAttribute('vsn-list');\n        });\n    }\n    configure() {\n        return __awaiter(this, void 0, void 0, function* () {\n        });\n    }\n    instantiateModel(model) {\n        this.tag.wrap(model, false, true);\n    }\n};\nListItem.scoped = true;\nListItem.ERROR_NO_PARENT = \"Cannot find list parent.\";\nListItem = ListItem_1 = __decorate([\n    Registry_1.Registry.attribute('vsn-list-item')\n], ListItem);\nexports.ListItem = ListItem;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/ListItem.ts?");

/***/ }),

/***/ "./src/attributes/ListItemModel.ts":
/*!*****************************************!*\
  !*** ./src/attributes/ListItemModel.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ListItemModel = void 0;\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nconst Attribute_1 = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\nlet ListItemModel = class ListItemModel extends Attribute_1.Attribute {\n};\nListItemModel = __decorate([\n    Registry_1.Registry.attribute('vsn-list-item-model')\n], ListItemModel);\nexports.ListItemModel = ListItemModel;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/ListItemModel.ts?");

/***/ }),

/***/ "./src/attributes/ModelAttribute.ts":
/*!******************************************!*\
  !*** ./src/attributes/ModelAttribute.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModelAttribute = void 0;\nconst ClassConstructor_1 = __webpack_require__(/*! ./ClassConstructor */ \"./src/attributes/ClassConstructor.ts\");\nclass ModelAttribute extends ClassConstructor_1.ClassConstructor {\n}\nexports.ModelAttribute = ModelAttribute;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/ModelAttribute.ts?");

/***/ }),

/***/ "./src/attributes/Name.ts":
/*!********************************!*\
  !*** ./src/attributes/Name.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Name = void 0;\nconst Attribute_1 = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nlet Name = class Name extends Attribute_1.Attribute {\n    setup() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const parentScope = this.tag.scope.parentScope;\n            if (parentScope) {\n                parentScope.set(this.tag.parsedAttributes['vsn-name'][1], this.tag.scope);\n            }\n        });\n    }\n};\nName.scoped = true;\nName = __decorate([\n    Registry_1.Registry.attribute('vsn-name')\n], Name);\nexports.Name = Name;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/Name.ts?");

/***/ }),

/***/ "./src/attributes/On.ts":
/*!******************************!*\
  !*** ./src/attributes/On.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.On = void 0;\nconst Attribute_1 = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\nconst AST_1 = __webpack_require__(/*! ../AST */ \"./src/AST.ts\");\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nlet On = class On extends Attribute_1.Attribute {\n    compile() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const code = this.getAttributeValue();\n            this.handler = new AST_1.Tree(code);\n            yield this.handler.prepare(this.tag.scope, this.tag.dom);\n        });\n    }\n    handleEvent(e) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.handler.evaluate(this.tag.scope, this.tag.dom);\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.tag.addEventHandler(this.getAttributeBinding(), this.getAttributeModifiers(), this.handleEvent.bind(this));\n        });\n    }\n};\nOn.WindowEvents = [\n    'abort',\n    'afterprint',\n    'beforeprint',\n    'error',\n    'hashchange',\n    'load',\n    'popstate',\n    'resize',\n    'unload',\n];\nOn = __decorate([\n    Registry_1.Registry.attribute('vsn-on')\n], On);\nexports.On = On;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/On.ts?");

/***/ }),

/***/ "./src/attributes/Referenced.ts":
/*!**************************************!*\
  !*** ./src/attributes/Referenced.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Referenced = void 0;\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nconst Attribute_1 = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\nlet Referenced = class Referenced extends Attribute_1.Attribute {\n};\nReferenced = __decorate([\n    Registry_1.Registry.attribute('vsn-ref')\n], Referenced);\nexports.Referenced = Referenced;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/Referenced.ts?");

/***/ }),

/***/ "./src/attributes/RootAttribute.ts":
/*!*****************************************!*\
  !*** ./src/attributes/RootAttribute.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RootAttribute = void 0;\nconst Attribute_1 = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\nconst VisionHelper_1 = __webpack_require__(/*! ../helpers/VisionHelper */ \"./src/helpers/VisionHelper.ts\");\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nlet RootAttribute = class RootAttribute extends Attribute_1.Attribute {\n    setup() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.tag.scope.set('$mobile', VisionHelper_1.VisionHelper.isMobile());\n        });\n    }\n};\nRootAttribute.scoped = true;\nRootAttribute = __decorate([\n    Registry_1.Registry.attribute('vsn-root')\n], RootAttribute);\nexports.RootAttribute = RootAttribute;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/RootAttribute.ts?");

/***/ }),

/***/ "./src/attributes/ScopeAttribute.ts":
/*!******************************************!*\
  !*** ./src/attributes/ScopeAttribute.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ScopeAttribute = void 0;\nconst Attribute_1 = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nlet ScopeAttribute = class ScopeAttribute extends Attribute_1.Attribute {\n};\nScopeAttribute.scoped = true;\nScopeAttribute = __decorate([\n    Registry_1.Registry.attribute('vsn-scope')\n], ScopeAttribute);\nexports.ScopeAttribute = ScopeAttribute;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/ScopeAttribute.ts?");

/***/ }),

/***/ "./src/attributes/ScopeChange.ts":
/*!***************************************!*\
  !*** ./src/attributes/ScopeChange.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ScopeChange = void 0;\nconst Attribute_1 = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\nconst AST_1 = __webpack_require__(/*! ../AST */ \"./src/AST.ts\");\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nlet ScopeChange = class ScopeChange extends Attribute_1.Attribute {\n    compile() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const code = this.getAttributeValue();\n            this.handler = new AST_1.Tree(code);\n            yield this.handler.prepare(this.tag.scope, this.tag.dom);\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const binding = this.getAttributeBinding();\n            const ref = this.tag.scope.getReference(binding, false);\n            ref.scope.bind(`change:${ref.key}`, this.handleEvent.bind(this));\n        });\n    }\n    handleEvent(e) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.handler.evaluate(this.tag.scope, this.tag.dom);\n        });\n    }\n};\nScopeChange = __decorate([\n    Registry_1.Registry.attribute('vsn-scope-change')\n], ScopeChange);\nexports.ScopeChange = ScopeChange;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/ScopeChange.ts?");

/***/ }),

/***/ "./src/attributes/SetAttribute.ts":
/*!****************************************!*\
  !*** ./src/attributes/SetAttribute.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SetAttribute = void 0;\nconst Attribute_1 = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nlet SetAttribute = class SetAttribute extends Attribute_1.Attribute {\n    set value(v) {\n        if (this.boundScope) {\n            this.boundScope.set(this.key, v);\n        }\n    }\n    get value() {\n        if (!this.boundScope)\n            return null;\n        return this.boundScope.get(this.key, false);\n    }\n    setup() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.property = this.getAttributeBinding();\n            let ref;\n            try {\n                ref = this.tag.scope.getReference(this.property);\n            }\n            catch (e) {\n                return;\n            }\n            this.key = ref.key;\n            this.boundScope = ref.scope;\n        });\n    }\n    extract() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let value = this.getAttributeValue(null);\n            const typeIndex = value && value.indexOf('|') || -1;\n            if (typeIndex > -1) {\n                this.boundScope.setType(this.key, value.substr(typeIndex + 1));\n                value = value.substr(0, typeIndex);\n            }\n            this.boundScope.set(this.key, value);\n        });\n    }\n};\nSetAttribute = __decorate([\n    Registry_1.Registry.attribute('vsn-set')\n], SetAttribute);\nexports.SetAttribute = SetAttribute;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/SetAttribute.ts?");

/***/ }),

/***/ "./src/attributes/StandardAttribute.ts":
/*!*********************************************!*\
  !*** ./src/attributes/StandardAttribute.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StandardAttribute = void 0;\nconst Attribute_1 = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\nclass StandardAttribute extends Attribute_1.Attribute {\n    setup() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (StandardAttribute.magicAttributes.indexOf(this.key) === -1 && !this.tag.element.hasAttribute(this.attributeName)) {\n                this.tag.element.setAttribute(this.attributeName, '');\n            }\n        });\n    }\n    extract() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.updateFrom();\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.tag.scope.bind(`change:${this.key}`, this.updateTo.bind(this));\n        });\n    }\n    mutate(mutation) {\n        super.mutate(mutation);\n        this.updateFrom();\n    }\n    get needsToBeSynced() {\n        let currentScopeValue = this.tag.scope.get(this.key) || '';\n        let value = this.value;\n        if (currentScopeValue && currentScopeValue.trim)\n            currentScopeValue = currentScopeValue.trim();\n        if (value && value.trim)\n            value = value.trim();\n        if (currentScopeValue instanceof Array) {\n            if (!(value instanceof Array) || currentScopeValue.length !== value.length)\n                return true;\n            return currentScopeValue.map(v => value.indexOf(v) > -1).indexOf(false) > -1;\n        }\n        return currentScopeValue !== value;\n    }\n    updateTo() {\n        if (this.needsToBeSynced)\n            this.value = this.tag.scope.get(`@${this.attributeName}`);\n    }\n    updateFrom() {\n        if (this.needsToBeSynced)\n            this.tag.scope.set(this.key, this.value);\n    }\n    get key() {\n        return `@${this.attributeName}`;\n    }\n    set value(value) {\n        if (this.key === '@text')\n            this.tag.element.innerText = value;\n        else if (this.key === '@html')\n            this.tag.element.innerHTML = value;\n        else if (this.key === '@value')\n            this.tag.value = value;\n        else if (this.key === '@class' && value) {\n            this.tag.element.classList.remove(...Array.from(this.tag.element.classList));\n            const classes = value instanceof Array ? value : [value];\n            if (classes.length)\n                this.tag.element.classList.add(...classes);\n        }\n        else\n            this.tag.element.setAttribute(this.attributeName, value);\n    }\n    get value() {\n        if (this.key === '@text')\n            return this.tag.element.innerText;\n        else if (this.key === '@html')\n            return this.tag.element.innerHTML;\n        else if (this.key === '@value')\n            return this.tag.value;\n        else if (this.key === '@class') {\n            return Array.from(this.tag.element.classList);\n        }\n        else\n            return this.tag.element.getAttribute(this.attributeName);\n    }\n}\nexports.StandardAttribute = StandardAttribute;\nStandardAttribute.magicAttributes = [\n    '@text',\n    '@html',\n    '@class',\n    '@value'\n];\n\n\n//# sourceURL=webpack://vsn/./src/attributes/StandardAttribute.ts?");

/***/ }),

/***/ "./src/attributes/Template.ts":
/*!************************************!*\
  !*** ./src/attributes/Template.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Template = void 0;\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nconst Attribute_1 = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\nlet Template = class Template extends Attribute_1.Attribute {\n};\nTemplate = __decorate([\n    Registry_1.Registry.attribute('vsn-template')\n], Template);\nexports.Template = Template;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/Template.ts?");

/***/ }),

/***/ "./src/attributes/TypeAttribute.ts":
/*!*****************************************!*\
  !*** ./src/attributes/TypeAttribute.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TypeAttribute = void 0;\nconst Attribute_1 = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\nconst Registry_1 = __webpack_require__(/*! ../Registry */ \"./src/Registry.ts\");\nlet TypeAttribute = class TypeAttribute extends Attribute_1.Attribute {\n    extract() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const key = this.getAttributeBinding();\n            let type = this.getAttributeValue();\n            let ref;\n            try {\n                ref = this.tag.scope.getReference(key);\n            }\n            catch (e) {\n                console.error('error', e);\n                return;\n            }\n            ref.scope.setType(ref.key, type);\n        });\n    }\n};\nTypeAttribute = __decorate([\n    Registry_1.Registry.attribute('vsn-type')\n], TypeAttribute);\nexports.TypeAttribute = TypeAttribute;\n\n\n//# sourceURL=webpack://vsn/./src/attributes/TypeAttribute.ts?");

/***/ }),

/***/ "./src/attributes/_imports.ts":
/*!************************************!*\
  !*** ./src/attributes/_imports.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__webpack_require__(/*! ./AddClassIf */ \"./src/attributes/AddClassIf.ts\");\n__webpack_require__(/*! ./Bind */ \"./src/attributes/Bind.ts\");\n__webpack_require__(/*! ./ClickRemoveClass */ \"./src/attributes/ClickRemoveClass.ts\");\n__webpack_require__(/*! ./ClickToggleClass */ \"./src/attributes/ClickToggleClass.ts\");\n__webpack_require__(/*! ./ControllerAttribute */ \"./src/attributes/ControllerAttribute.ts\");\n__webpack_require__(/*! ./DisableIf */ \"./src/attributes/DisableIf.ts\");\n__webpack_require__(/*! ./Exec */ \"./src/attributes/Exec.ts\");\n__webpack_require__(/*! ./Format */ \"./src/attributes/Format.ts\");\n__webpack_require__(/*! ./If */ \"./src/attributes/If.ts\");\n__webpack_require__(/*! ./KeyDown */ \"./src/attributes/KeyDown.ts\");\n__webpack_require__(/*! ./KeyUp */ \"./src/attributes/KeyUp.ts\");\n__webpack_require__(/*! ./List */ \"./src/attributes/List.ts\");\n__webpack_require__(/*! ./ListItem */ \"./src/attributes/ListItem.ts\");\n__webpack_require__(/*! ./ListItemModel */ \"./src/attributes/ListItemModel.ts\");\n__webpack_require__(/*! ./ModelAttribute */ \"./src/attributes/ModelAttribute.ts\");\n__webpack_require__(/*! ./Name */ \"./src/attributes/Name.ts\");\n__webpack_require__(/*! ./On */ \"./src/attributes/On.ts\");\n__webpack_require__(/*! ./Referenced */ \"./src/attributes/Referenced.ts\");\n__webpack_require__(/*! ./RootAttribute */ \"./src/attributes/RootAttribute.ts\");\n__webpack_require__(/*! ./ScopeAttribute */ \"./src/attributes/ScopeAttribute.ts\");\n__webpack_require__(/*! ./ScopeChange */ \"./src/attributes/ScopeChange.ts\");\n__webpack_require__(/*! ./SetAttribute */ \"./src/attributes/SetAttribute.ts\");\n__webpack_require__(/*! ./StandardAttribute */ \"./src/attributes/StandardAttribute.ts\");\n__webpack_require__(/*! ./Template */ \"./src/attributes/Template.ts\");\n__webpack_require__(/*! ./TypeAttribute */ \"./src/attributes/TypeAttribute.ts\");\n\n\n//# sourceURL=webpack://vsn/./src/attributes/_imports.ts?");

/***/ }),

/***/ "./src/helpers/ElementHelper.ts":
/*!**************************************!*\
  !*** ./src/helpers/ElementHelper.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ElementHelper = void 0;\nclass ElementHelper {\n    static hasVisionAttribute(element, testAttr = 'vsn-') {\n        if (!element.attributes || element.attributes.length <= 0)\n            return false;\n        for (let i = 0; i < element.attributes.length; i++) {\n            const attr = element.attributes[i];\n            if (attr.name.startsWith(testAttr)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static normalizeElementID(id) {\n        return id ? id.replace(/-([a-zA-Z0-9])/g, function (g) { return g[1].toUpperCase(); }) : null;\n    }\n}\nexports.ElementHelper = ElementHelper;\n\n\n//# sourceURL=webpack://vsn/./src/helpers/ElementHelper.ts?");

/***/ }),

/***/ "./src/helpers/VisionHelper.ts":
/*!*************************************!*\
  !*** ./src/helpers/VisionHelper.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VisionHelper = void 0;\nclass VisionHelper {\n    static isConstructor(obj) {\n        return obj &&\n            obj.hasOwnProperty(\"prototype\") &&\n            !!obj.prototype &&\n            !!obj.prototype.constructor &&\n            !!obj.prototype.constructor.name;\n    }\n    static get document() {\n        return typeof document === 'object' ? document : null;\n    }\n    static get window() {\n        return typeof window === 'object' ? window : null;\n    }\n    static isMobile() {\n        let check = false;\n        if (navigator && VisionHelper.window) {\n            (function (a) {\n                if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0, 4)))\n                    check = true;\n            })(navigator.userAgent || navigator.vendor || window['opera']);\n        }\n        return check;\n    }\n    static get inDevelopment() {\n        console.log('in dev?', true);\n        return true;\n    }\n    static get inLegacy() {\n        return process.env.BUILD_TARGET === 'es5';\n    }\n}\nexports.VisionHelper = VisionHelper;\n\n\n//# sourceURL=webpack://vsn/./src/helpers/VisionHelper.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/Vision.ts");
/******/ 	
/******/ })()
;